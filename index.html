<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - Job連結 / KPI=搬送量(h) / 画像レイヤ(貼り付けOK)</title>
<style>
  :root { --brand:#006666; --panel:#004d4d; --grid:#e6e6e6; --panelThin:#003c3c; --scrollTrack:#e0e5e5; --scrollThumb:#ffffff; }
  * { box-sizing:border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  html, body { height:100%; }
  body { margin:0; display:flex; height:100vh; overflow:hidden; background:#fff; }

  .sidebar {
    width:520px; flex-shrink:0; color:#fff; background:var(--brand);
    padding:12px 14px; display:flex; flex-direction:column; gap:12px;
    overflow-y:auto; overflow-x:hidden;
  }
  h1 { font-size:18px; margin:6px 0 8px; font-weight:700; }
  .section { background:var(--panel); border-radius:10px; padding:10px; }
  .row { display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap; }
  .btn { cursor:pointer; border:none; border-radius:8px; padding:6px 8px; font-weight:700; font-size:13px; }
  .btn.primary { background:#fff; color:var(--brand); }
  .btn.ghost { background:transparent; border:1px solid #fff; color:#fff; }
  .btn.slim { padding:4px 8px; font-size:12px; border-radius:8px; }
  .status { background:#003d3d; padding:8px; border-radius:8px; font-size:13px; line-height:1.4; }
  .note { font-size:12px; opacity:.92; }
  .small { font-size:12px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

  .canvas-wrap { position:relative; flex:1; background:#fff; min-width:260px; }
  canvas#map { position:absolute; inset:0; width:100%; height:100%; display:block; }

  .canvas-ui { position:absolute; display:flex; align-items:center; gap:8px; }
  .ui-top-right { top:8px; right:8px; background:rgba(0,0,0,.55); color:#fff; padding:6px 8px; border-radius:10px; z-index:6; }
  .ui-bottom-left { left:8px; bottom:28px; background:rgba(0,0,0,.55); color:#fff; padding:4px 8px; border-radius:8px; font-size:12px; pointer-events:none; z-index:6; }
  .speed-btn { cursor:pointer; border:none; width:28px; height:28px; border-radius:8px; background:#fff; color:#333; font-weight:800; display:grid; place-items:center; }
  .speed-label { min-width:44px; text-align:center; font-weight:700; }

  .toast { position:fixed; left:50%; top:18px; transform:translateX(-50%); background:#333; color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transition:opacity .2s ease; pointer-events:none; z-index:9; }
  .toast.show { opacity:.95; }

  /* 画像レイヤUI */
  .img-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .img-list { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
  .img-item { background:#003c3c; border-radius:8px; padding:6px 8px; display:grid; grid-template-columns: 1fr auto auto; gap:8px; align-items:center; }
  .img-item strong { font-weight:700; }
  .slider-row { margin-top:8px; display:flex; align-items:center; gap:8px; }
  .slider-row input[type="range"] { flex:1; }

  /* ルート一覧 */
  .routes-list { display:flex; flex-direction:column; gap:8px; }
  .route-item { background:#003c3c; border-radius:8px; padding:8px; display:grid; grid-template-columns: 1fr 70px 110px 86px; gap:8px; align-items:center; }
  .route-name { font-weight:700; }
  .route-toggle { min-width:110px; }
  .route-sub { grid-column: 1 / -1; display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:6px; }
  .route-sub label { font-size:12px; opacity:.95; }
  .route-sub input { width:80px; padding:2px 4px; font-size:12px; border-radius:6px; border:none; }
  .route-sub .pill { background:#0b5151; padding:3px 8px; border-radius:999px; font-size:12px; }

  /* ジョブ一覧 */
  .jobs-list { display:flex; flex-direction:column; gap:8px; }
  .job-item { background:#003c3c; border-radius:8px; padding:8px; display:grid; grid-template-columns: 1fr 70px auto; gap:8px; align-items:center; }
  .job-sub { grid-column: 1 / -1; display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px; }
  .job-sub select, .job-sub input { font-size:12px; border-radius:6px; border:none; padding:4px 6px; }
  .job-sub .seq { background:#0b5151; padding:4px 8px; border-radius:8px; font-size:12px; }
  .job-sub .seq b { font-weight:800; }

  .sim-btn { min-width:280px; }

  /* 車体一覧 */
  .vehicle-grid {
    display:grid;
    grid-template-columns: 56px 84px 84px 96px 84px;
    gap:6px; align-items:center; justify-items:start;
  }
  .vehicle-grid .head { font-weight:700; opacity:.9; }
  .vehicle-grid input { width:64px; padding:2px 3px; font-size:12px; border-radius:6px; border:none; }

  /* パン用スライダー（スクロールバー風） */
  .pan-slider-x, .pan-slider-y { position:absolute; z-index:7; background:transparent; pointer-events:auto; }
  .pan-slider-x { left:8px; right:28px; bottom:6px; height:14px; }
  .pan-slider-y { top:8px; bottom:28px; right:8px; width:14px; background: var(--scrollTrack); border-radius:8px; }

  .pan-slider-x input[type="range"]{
    -webkit-appearance:none; appearance:none; width:100%; height:14px; margin:0; background:transparent; outline:none;
  }
  .pan-slider-x input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:14px; height:14px; margin-top:-4px;
    border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15);
    box-shadow: 0 1px 1px rgba(0,0,0,.05); cursor:pointer;
  }
  .pan-slider-x input[type="range"]::-moz-range-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]::-moz-range-thumb{
    width:14px; height:14px; border-radius:8px; background:var(--scrollThumb);
    border:1px solid rgba(0,0,0,.15); cursor:pointer;
  }

  .pan-slider-y input[type="range"]{
    -webkit-appearance:none; appearance:none; position:absolute;
    top:50%; left:50%;
    transform: translate(-50%, -50%) rotate(-90deg);
    transform-origin: center center;
    width: calc(100% - 6px);
    height:14px;
    margin:0; background:transparent; outline:none;
  }
  .pan-slider-y input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-y input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:14px; height:14px; margin-top:-4px;
    border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15);
    box-shadow: 0 1px 1px rgba(0,0,0,.05); cursor:pointer;
  }
  .pan-slider-y input[type="range"]::-moz-range-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-y input[type="range"]::-moz-range-thumb{
    width:14px; height:14px; border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); cursor:pointer;
  }

  .kbd { background:rgba(255,255,255,.14); border:1px solid rgba(255,255,255,.25); border-bottom-color:rgba(0,0,0,.25);
    padding:1px 6px; border-radius:6px; font-size:12px; }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>AGV シミュレーター（Job連結 / 画像貼り付けOK）</h1>

    <div class="section">
      <div class="row"><strong>操作</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>ルートを <b>＋</b> で追加し、<b>経路生成ON</b> のルートだけ編集</li>
        <li>交点クリックで <b>P1→P2→…</b>（水平/垂直のみ）</li>
        <li>交点ダブルクリックで <b>S → G</b>（この順で1回ずつ）</li>
        <li><span class="kbd">Shift</span> + ダブルクリックで <b>待機点</b> 追加（秒数入力）</li>
        <li>ジョブは <b>同一AGV</b> のルートのみ追加可（不一致はエラー）</li>
      </ol>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>画像レイヤ（貼り付け/ファイル）</strong>
        <span class="note">グリッドは常に前面</span>
      </div>

      <div class="img-controls">
        <input id="imageFile" type="file" accept="image/*" />
        <button id="addImageBtn" class="btn primary">＋ ファイル追加</button>
        <span class="note">または 画面に画像を<span class="kbd">Ctrl+V</span>で貼付</span>
      </div>
      <div class="slider-row">
        <label class="small" for="imgOpacity" style="min-width:64px;">不透明度</label>
        <input id="imgOpacity" type="range" min="0" max="100" value="100" />
        <span id="imgOpacityLabel" class="small" style="min-width:40px; text-align:right;">100%</span>
      </div>
      <div class="note">移動/リサイズ：選択ONの画像のみ。四隅ドラッグ（Shiftで縦横比解除）／削除：Delete</div>
      <div id="imgList" class="img-list"></div>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ルート一覧</strong>
        <span class="note">（表示番号は連番）</span>
      </div>
      <div id="routesList" class="routes-list"></div>
      <div class="row">
        <button id="addRoute" class="btn primary">＋ ルート追加</button>
        <button id="removeRoute" class="btn ghost">− 最後のルート削除</button>
      </div>
      <div class="row">
        <button id="exportPngBtn" class="btn ghost slim" title="PNG書き出し">PNG</button>
        <button id="exportBtn" class="btn ghost">JSON書き出し</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn ghost">JSON読み込み</button>
      </div>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ジョブ一覧（ルート連結）</strong>
        <span class="note">Job内は同一AGVのみ</span>
      </div>
      <div id="jobsList" class="jobs-list"></div>
      <div class="row">
        <button id="addJob" class="btn primary">＋ Job追加</button>
        <button id="removeJob" class="btn ghost">− 最後のJob削除</button>
      </div>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>車体一覧（A〜J）</strong>
        <span class="note">速度・荷積/荷下ろし・旋回（90°あたり）</span>
      </div>
      <div id="vehicles" class="vehicle-grid"></div>
    </div>

    <div class="section status">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ステータス</strong>
        <span class="note">搬送量= 1時間あたりの搬送回数</span>
      </div>

      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="chargePct">充電率ダウンタイム（0–30%）</label>
        <input id="chargePct" type="number" min="0" max="30" step="1" value="0" style="width:64px;"/>
        <span class="note">※停止割合</span>
      </div>
      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="safetyPct">安全率（0–50%）</label>
        <input id="safetyPct" type="number" min="0" max="50" step="1" value="0" style="width:64px;"/>
        <span class="note">※余裕係数</span>
      </div>
      <div class="note">
        計算式：<b>稼働率(係数)</b> ＝ (1 − 充電率/100) × (1 − 安全率/100)<br/>
        例：充電率10% → 3600s中 360s停止 / 安全率15% → 稼働を0.85倍
      </div>

      <div id="routesSummary" style="display:flex; flex-direction:column; gap:4px; margin-top:8px;"></div>
      <div id="jobsSummary" style="display:flex; flex-direction:column; gap:6px; margin-top:10px;"></div>
      <div class="row" style="justify-content:space-between; align-items:center; margin-top:8px;">
        <strong>合計</strong>
        <span id="totalSummary" class="mono">-</span>
      </div>
    </div>

    <div class="section">
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除（アクティブルート）</button>
      </div>
      <div class="row">
        <button id="clear" class="btn ghost">アクティブルート全消去</button>
      </div>
      <div class="row">
        <button id="simulateToggle" class="btn primary sim-btn">シミュレーション開始（Jobを無限リピート）</button>
      </div>
      <div class="note">Ctrl+Z でも1つ戻せます / 走行中は「走行中ルート」を発光表示</div>
    </div>
  </aside>

  <div class="canvas-wrap">
    <canvas id="map"></canvas>
    <div class="pan-slider-y"><input id="panY" type="range" min="0" max="100" value="0" orient="vertical"></div>
    <div class="pan-slider-x"><input id="panX" type="range" min="0" max="100" value="0"></div>

    <div class="canvas-ui ui-top-right" id="speedBox">
      <button id="speedDec" class="speed-btn" title="速度を下げる">◀</button>
      <span class="speed-label" id="speedLabel">1×</span>
      <button id="speedInc" class="speed-btn" title="速度を上げる">▶</button>
    </div>
    <div class="canvas-ui ui-bottom-left"><span id="zoomLabel">100%</span></div>
  </div>

  <div id="toast" class="toast"></div>

<script defer>
(function(){
  /* ========================
     定数・状態
  =========================*/
  var PX_PER_M = 40, GRID = PX_PER_M, EPS = 0.5, SNAP_TOL = GRID * 0.40;
  var ROUTE_COLORS = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad','#16a085','#f39c12','#c0392b','#2980b9','#7f8c8d'];
  var WORLD = { width: 8000, height: 6000 };

  // 画像
  var images = []; var nextImgId = 1; var selectedImgId = null; var IMG_HANDLE = 10;
  var imgDrag = { active:false, mode:null, start:{x:0,y:0}, base:{x:0,y:0,w:0,h:0}, keepAR:true };

  // 速度
  var SPEED_STEPS = [0.5, 1, 2, 4], speedIndex = 1;
  function currentSpeed(){ return SPEED_STEPS[speedIndex]; }

  // 表示（ズーム/パン）
  var view = { scale:1.0, min:0.1, max:2.0, offsetX:0, offsetY:0, dragging:false, dragStart:{x:0,y:0}, startOffset:{x:0,y:0} };

  // ルート/ジョブ
  var routes = {}; var activeRouteId = null; var nextRouteId = 1;
  var jobs = []; var activeJobId = null; var nextJobId = 1;

  // 車体
  var vehicles = {};
  'ABCDEFGHIJ'.split('').forEach(function(ch){
    vehicles[ch] = { speed:1.0, load:5, unload:5, turn90:2 };
  });

  // シミュレーション
  var simRunning = false;
  // sims[agv] = { agv, jobId, routeIndex, curRouteId, sgPath, segIndex, pos, heading, phase, ... }
  var sims = {};

  // DOM
  var canvas, ctx, toastEl, zoomLabelEl, speedLabelEl, speedDecBtn, speedIncBtn;
  var panXEl, panYEl;
  var routesListEl, addRouteBtn, removeRouteBtn, undoBtn, clearBtn, simulateBtn;
  var vehiclesEl, exportBtn, importBtn, importFile, routesSummaryEl, jobsSummaryEl, totalSummaryEl, chargePctEl, safetyPctEl, exportPngBtn;
  var jobsListEl, addJobBtn, removeJobBtn;
  var imageFileEl, addImageBtn, imgOpacityEl, imgOpacityLabelEl, imgListEl;

  /* Utils */
  function toast(msg){
    if(!toastEl) return;
    toastEl.textContent=msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'),1400);
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function approx(a,b,eps){ return Math.abs(a-b) <= (eps||EPS); }
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

  function anyBuilding(){ return Object.keys(routes).some(k=>!!routes[k].building); }

  function clientToCanvasXY(clientX, clientY){ var r=canvas.getBoundingClientRect(); return { x: clientX - r.left, y: clientY - r.top }; }
  function screenToWorld(sx, sy){ return { x: (sx - view.offsetX)/view.scale, y: (sy - view.offsetY)/view.scale }; }
  function worldToScreen(wx, wy){ return { x: wx*view.scale + view.offsetX, y: wy*view.scale + view.offsetY }; }

  function applyTransform(){ ctx.setTransform(view.scale,0,0,view.scale,view.offsetX,view.offsetY); }
  function resetTransform(){ ctx.setTransform(1,0,0,1,0,0); }

  function clampOffsets(){
    var minX = Math.min(0, canvas.width - WORLD.width * view.scale), maxX = 0;
    var minY = Math.min(0, canvas.height - WORLD.height * view.scale), maxY = 0;
    view.offsetX = clamp(view.offsetX, minX, maxX);
    view.offsetY = clamp(view.offsetY, minY, maxY);
  }
  function updatePanSlidersFromView(){
    var vx = -view.offsetX / view.scale, vy = -view.offsetY / view.scale;
    var spanX = Math.max(1, WORLD.width - canvas.width / view.scale);
    var spanY = Math.max(1, WORLD.height - canvas.height / view.scale);
    panXEl.value = clamp(Math.round((vx / spanX) * 100), 0, 100);
    panYEl.value = clamp(Math.round((vy / spanY) * 100), 0, 100);
  }
  function updateViewFromPanSliders(){
    var spanX = Math.max(0, WORLD.width - canvas.width / view.scale);
    var spanY = Math.max(0, WORLD.height - canvas.height / view.scale);
    var vx = (spanX * (+panXEl.value) / 100);
    var vy = (spanY * (+panYEl.value) / 100);
    view.offsetX = -vx * view.scale; view.offsetY = -vy * view.scale;
    clampOffsets(); drawAll();
  }

  /* ========================
     画像レイヤ（貼付/ファイル）
  =========================*/
  async function fileToBitmap(file){
    if(!file) return null;
    try{
      var url = URL.createObjectURL(file);
      var img = new Image(); img.decoding='async';
      await new Promise((res,rej)=>{ img.onload=()=>res(true); img.onerror=()=>rej(new Error('画像読み込み失敗')); img.src=url; });
      var bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return { bitmap:bmp, width:bmp.width, height:bmp.height, name:file.name||'pasted' };
    }catch(e){
      toast('画像読み込み失敗: '+e.message);
      return null;
    }
  }

  function addImageLayer(name, bm, w, h){
    var targetW = Math.min((canvas.width/view.scale)*0.7, w);
    var sc = targetW / w; var targetH = h * sc;
    images.push({ id: nextImgId++, name: name||'image', bitmap: bm, x:40, y:40, w:targetW, h:targetH, opacity:1.0 });
    renderImageList(); drawAll();
  }

  function renderImageList(){
    imgListEl.innerHTML = '';
    images.forEach(function(it){
      var div = document.createElement('div'); div.className='img-item';
      var name = document.createElement('div');
      name.innerHTML = '<strong>#'+it.id+'</strong> <span class="small">'+escapeHtml(it.name)+'</span>';

      var toggle = document.createElement('button'); toggle.className='btn route-toggle';
      var isOn = (selectedImgId === it.id);
      if(isOn){ toggle.textContent='選択ON'; toggle.style.background='#fff'; toggle.style.color='#006666'; toggle.style.border='none'; }
      else { toggle.textContent='選択OFF'; toggle.style.background='transparent'; toggle.style.color='#fff'; toggle.style.border='1px solid #fff'; }
      toggle.addEventListener('click', function(e){
        e.stopPropagation();
        selectedImgId = (selectedImgId===it.id) ? null : it.id;
        if(selectedImgId===it.id){
          imgOpacityEl.value = Math.round(it.opacity*100);
          imgOpacityLabelEl.textContent = Math.round(it.opacity*100)+'%';
        }
        renderImageList(); drawAll();
      });

      var delBtn = document.createElement('button'); delBtn.className='btn ghost'; delBtn.textContent='削除';
      delBtn.addEventListener('click', function(e){
        e.stopPropagation();
        images = images.filter(x=>x.id!==it.id);
        if(selectedImgId===it.id) selectedImgId=null;
        renderImageList(); drawAll();
      });

      div.appendChild(name); div.appendChild(toggle); div.appendChild(delBtn);
      imgListEl.appendChild(div);
    });
  }

  function getSelectedImage(){ return selectedImgId ? (images.find(it=>it.id===selectedImgId)||null) : null; }

  function drawImages(){
    images.forEach(function(it){
      if(!it.bitmap) return;
      ctx.save();
      ctx.globalAlpha = clamp(it.opacity,0,1);
      ctx.drawImage(it.bitmap, it.x, it.y, it.w, it.h);
      ctx.restore();
    });
    if(selectedImgId){
      var it = getSelectedImage();
      if(it){
        ctx.save();
        ctx.lineWidth=1/view.scale;
        ctx.strokeStyle='#00bcd4';
        ctx.setLineDash([6/view.scale, 4/view.scale]);
        ctx.strokeRect(it.x,it.y,it.w,it.h);
        ctx.setLineDash([]);
        var handles=[{x:it.x,y:it.y},{x:it.x+it.w,y:it.y},{x:it.x,y:it.y+it.h},{x:it.x+it.w,y:it.y+it.h}];
        ctx.fillStyle='#00bcd4';
        handles.forEach(h=>{
          ctx.beginPath();
          ctx.arc(h.x,h.y,IMG_HANDLE/view.scale,0,Math.PI*2);
          ctx.fill();
        });
        ctx.restore();
      }
    }
  }

  function hitImageHandle(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY), w=screenToWorld(s.x, s.y);
    var pts=[{x:it.x,y:it.y,c:'nw'},{x:it.x+it.w,y:it.y,c:'ne'},{x:it.x,y:it.y+it.h,c:'sw'},{x:it.x+it.w,y:it.y+it.h,c:'se'}];
    for(var i=0;i<pts.length;i++){
      var p=pts[i];
      var dx=Math.abs(w.x-p.x)*view.scale, dy=Math.abs(w.y-p.y)*view.scale;
      if(Math.hypot(dx,dy)<=IMG_HANDLE+2) return p.c;
    }
    return null;
  }
  function hitImageBody(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY), w=screenToWorld(s.x, s.y);
    return (w.x>=it.x && w.x<=it.x+it.w && w.y>=it.y && w.y<=it.y+it.h);
  }
  function pickImage(clientX, clientY){
    for(var i=images.length-1;i>=0;i--){
      var it=images[i];
      var h=hitImageHandle(it, clientX, clientY);
      if(h) return {it,mode:h};
      if(hitImageBody(it, clientX, clientY)) return {it,mode:'move'};
    }
    return null;
  }

  /* ========================
     ルート：幾何
  =========================*/
  function getOrderedRouteIds(){ return Object.keys(routes).map(k=>+k).sort((a,b)=>a-b); }
  function getDisplayIndex(id){ var ids=getOrderedRouteIds(); var idx=ids.indexOf(id); return idx===-1? null : (idx+1); }

  function polylineFromPoints(r){
    if(!r || !r.points || r.points.length<2) return [];
    var clean=[];
    for(var i=0;i<r.points.length;i++){
      var p={x:r.points[i][0], y:r.points[i][1]};
      if(!clean.length){ clean.push(p); continue; }
      var a=clean[clean.length-1];
      if(approx(a.x,p.x) && approx(a.y,p.y)) continue;
      if(!approx(a.x,p.x) && !approx(a.y,p.y)) continue; // 斜めは無視
      if(clean.length>=2){
        var b=clean[clean.length-2];
        if(approx(b.x,a.x) && approx(a.x,p.x)){ clean[clean.length-1]=p; continue; }
        if(approx(b.y,a.y) && approx(a.y,p.y)){ clean[clean.length-1]=p; continue; }
      }
      clean.push(p);
    }
    return clean;
  }

  function projectToPolyline(xy, path, tolPx){
    if(!path || path.length<2) return null;
    var best=null, bestDist=Infinity, tol=(tolPx||SNAP_TOL);
    for (var i=0;i<path.length-1;i++){
      var A=path[i], B=path[i+1];
      if(approx(A.x,B.x)){
        var dx=Math.abs(xy[0]-A.x);
        if(dx<=tol){
          var y=clamp(xy[1], Math.min(A.y,B.y), Math.max(A.y,B.y));
          var d=dx+Math.abs(xy[1]-y);
          if(d<bestDist){ bestDist=d; best={x:A.x,y:y,i:i}; }
        }
      } else if(approx(A.y,B.y)){
        var dy=Math.abs(xy[1]-A.y);
        if(dy<=tol){
          var x=clamp(xy[0], Math.min(A.x,B.x), Math.max(A.x,B.x));
          var d=dy+Math.abs(xy[0]-x);
          if(d<bestDist){ bestDist=d; best={x:x,y:A.y,i:i}; }
        }
      }
    }
    return best;
  }

  function segLenPx(A,B){ return Math.abs(B.x-A.x) + Math.abs(B.y-A.y); }
  function totalLenPx(path){ var S=0; for(var i=0;i<path.length-1;i++) S+=segLenPx(path[i], path[i+1]); return S; }

  function progressAlong(path, point){
    var proj=projectToPolyline([point.x, point.y], path, SNAP_TOL);
    if(!proj) return null;
    var s=0;
    for(var k=0;k<proj.i;k++) s += segLenPx(path[k], path[k+1]);
    s += segLenPx(path[proj.i], {x:proj.x, y:proj.y});
    return { s:s, pt:{x:proj.x, y:proj.y} };
  }

  function pointAtProgress(path, s){
    s=clamp(s,0,totalLenPx(path));
    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      if(acc + L >= s - EPS){
        var t=(s-acc)/Math.max(1e-6,L);
        var A=path[i], B=path[i+1];
        return approx(A.x,B.x) ? { x:A.x, y:A.y + (B.y-A.y)*t } : { x:A.x + (B.x-A.x)*t, y:A.y };
      }
      acc+=L;
    }
    return { x:path[path.length-1].x, y:path[path.length-1].y };
  }

  function clipPathByProgress(path, s0, s1){
    if(!path || path.length<2) return [];
    var a=Math.min(s0,s1), b=Math.max(s0,s1);
    if(b-a<EPS) return [];
    var out=[], P0=pointAtProgress(path,a), P1=pointAtProgress(path,b);
    out.push(P0);
    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      var accNext=acc+L;
      if(accNext>a+EPS && accNext<b-EPS) out.push({x:path[i+1].x, y:path[i+1].y});
      acc=accNext;
    }
    out.push(P1);

    // clean
    var clean=[];
    for(var m=0;m<out.length;m++){
      if(!clean.length){ clean.push(out[m]); continue; }
      var aP=clean[clean.length-1], bP=out[m];
      if(approx(aP.x,bP.x)&&approx(aP.y,bP.y)) continue;
      clean.push(bP);
    }
    return clean;
  }

  function sgSubpathAndMeters(r){
    if(!r || !r.start || !r.goal) return {path:[], meters:0};
    var base=polylineFromPoints(r);
    if(!base.length) return {path:[], meters:0};
    var prS=progressAlong(base,{x:r.start[0], y:r.start[1]});
    var prG=progressAlong(base,{x:r.goal[0], y:r.goal[1]});
    if(!prS||!prG) return {path:[], meters:0};
    var sub=clipPathByProgress(base, prS.s, prG.s);
    var dist_m=Math.abs(prG.s-prS.s)/PX_PER_M;
    return { path:sub, meters:dist_m };
  }

  function waitSumSeconds(r){
    return (r.waits||[]).reduce((s,w)=>s+Math.max(0,+w.sec||0),0);
  }

  /* ========================
     旋回（ビジュアル）
  =========================*/
  function headingOf(A,B){
    if(B.x>A.x) return 0;
    if(B.x<A.x) return 180;
    if(B.y>A.y) return 90;
    if(B.y<A.y) return 270; // -90 の代わりに 270
    return 0;
  }
  function angleDelta(a,b){
    var d=((b-a+540)%360)-180;
    return d;
  }
  function normHeading(h){ h=((h%360)+360)%360; return h; }

  function turnDurationMs(agv, deltaDeg){
    var v=vehicles[agv] || {turn90:0};
    var per90 = Math.max(0, +v.turn90 || 0);
    var steps = Math.abs(deltaDeg)/90;
    return steps * per90 * 1000;
  }

  /* ========================
     時間計算（精度UP）
  =========================*/
  function routeOneWayTimeSeconds(r){
    var sg = sgSubpathAndMeters(r);
    if(!sg.path.length || sg.meters<=0) return null;

    var v = vehicles[r.agv] || { speed:1.0, load:5, unload:5, turn90:2 };

    var travel = sg.meters / Math.max(0.01, +v.speed || 1.0);
    var turn = Math.max(0, +r.turnCount || 0) * Math.max(0, +v.turn90 || 0); // 90度換算回数×(s/90°)
    var waitS = waitSumSeconds(r);
    var loadT = Math.max(0, +v.load || 0);
    var unloadT = Math.max(0, +v.unload || 0);

    return travel + turn + waitS + loadT + unloadT;
  }

  /* ========================
     描画
  =========================*/
  function drawGrid(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    var minW=(-view.offsetX)/view.scale, minH=(-view.offsetY)/view.scale;
    var maxW=(canvas.width - view.offsetX)/view.scale, maxH=(canvas.height - view.offsetY)/view.scale;

    applyTransform();
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,WORLD.width,WORLD.height);

    // 背面画像
    drawImages();

    // グリッド前面
    ctx.strokeStyle='#e6e6e6';
    ctx.lineWidth=1/view.scale;

    var startX=Math.max(0, Math.floor(minW/GRID)*GRID);
    for(var x=startX; x<=Math.min(maxW, WORLD.width); x+=GRID){
      ctx.beginPath(); ctx.moveTo(x, Math.max(0,minH)); ctx.lineTo(x, Math.min(maxH, WORLD.height)); ctx.stroke();
    }
    var startY=Math.max(0, Math.floor(minH/GRID)*GRID);
    for(var y=startY; y<=Math.min(maxH, WORLD.height); y+=GRID){
      ctx.beginPath(); ctx.moveTo(Math.max(0,minW), y); ctx.lineTo(Math.min(maxW, WORLD.width), y); ctx.stroke();
    }
    resetTransform();
  }

  function drawRoutes(){
    applyTransform();
    getOrderedRouteIds().forEach(function(id){
      var r=routes[id]; var dispIdx=getDisplayIndex(id);
      var base=polylineFromPoints(r);
      if(base.length>=2){
        ctx.lineWidth=2/view.scale;
        ctx.strokeStyle=r.color;
        ctx.globalAlpha=0.85;
        ctx.beginPath();
        ctx.moveTo(base[0].x, base[0].y);
        for(var i=1;i<base.length;i++) ctx.lineTo(base[i].x, base[i].y);
        ctx.stroke();
        ctx.globalAlpha=1;
      }
      // 点
      for(var j=0;j<r.points.length;j++){
        var p=r.points[j];
        ctx.fillStyle=r.color;
        ctx.beginPath();
        ctx.arc(p[0],p[1],4/view.scale,0,Math.PI*2);
        ctx.fill();
      }
      // S/G
      ctx.fillStyle='#000';
      ctx.font=(16/view.scale)+'px system-ui, sans-serif';
      ctx.textBaseline='top';
      if(r.start) ctx.fillText('S'+dispIdx, r.start[0]-10/view.scale, r.start[1]-18/view.scale);
      if(r.goal)  ctx.fillText('G'+dispIdx, r.goal[0]-10/view.scale, r.goal[1]-18/view.scale);

      // 待機点
      (r.waits||[]).forEach(function(wp, k){
        ctx.save();
        ctx.fillStyle='#111';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, 4.5/view.scale, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle='#000';
        ctx.font=(14/view.scale)+'px system-ui, sans-serif';
        ctx.fillText('W'+(k+1), wp.x+6/view.scale, wp.y-18/view.scale);
        ctx.restore();
      });
    });
    resetTransform();
  }

  // ★走行中ルートを発光（誘導 + 走行中）
  function drawGlowForCurrent(){
    if(!simRunning) return;
    applyTransform();

    Object.keys(sims).forEach(function(agv){
      var sim = sims[agv];
      if(!sim) return;

      var path = null;
      if(sim.phase==='glow' && sim.pending && sim.pending.sgPath) path = sim.pending.sgPath;
      else path = sim.sgPath;

      if(!path || path.length<2) return;

      var r = routes[sim.curRouteId];
      ctx.save();
      ctx.lineCap='round';

      var isGlow = (sim.phase==='glow');
      var a1 = isGlow ? 0.42 : 0.22;
      var a2 = isGlow ? 0.42 : 0.22;

      // 白外側
      ctx.globalAlpha = a1;
      ctx.lineWidth = (isGlow ? 16 : 12)/view.scale;
      ctx.strokeStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for(var i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
      ctx.stroke();

      // 色内側
      ctx.globalAlpha = a2;
      ctx.lineWidth = (isGlow ? 12 : 9)/view.scale;
      ctx.strokeStyle = (r && r.color) ? r.color : '#00ffff';
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for(var j=1;j<path.length;j++) ctx.lineTo(path[j].x, path[j].y);
      ctx.stroke();

      ctx.restore();
    });

    resetTransform();
  }

  function drawAGVs(){
    if(!simRunning) return;
    applyTransform();
    Object.keys(sims).forEach(function(agv){
      var sim=sims[agv]; if(!sim) return;
      var r=routes[sim.curRouteId];
      var color = r ? r.color : '#666';
      var L=22, W=14;
      var rad=(sim.heading||0)*Math.PI/180;
      ctx.save();
      ctx.translate(sim.pos.x, sim.pos.y);
      ctx.rotate(rad);
      ctx.fillStyle=color;
      ctx.fillRect(-L/2, -W/2, L, W);
      ctx.fillStyle='#000';
      ctx.beginPath();
      ctx.moveTo(L/2,0); ctx.lineTo(L/2-4,-3); ctx.lineTo(L/2-4,3); ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
    resetTransform();
  }

  function drawAll(){
    clampOffsets();
    drawGrid();
    drawRoutes();
    drawGlowForCurrent();
    drawAGVs();

    updatePanSlidersFromView();
    if(zoomLabelEl) zoomLabelEl.textContent = Math.round(view.scale*100) + '%';
    if(speedLabelEl) speedLabelEl.textContent = currentSpeed().toString() + '×';

    renderStatus();
  }

  /* ========================
     ルートUI
  =========================*/
  function addRoute(){
    var id=nextRouteId++;
    var color=ROUTE_COLORS[(id-1)%ROUTE_COLORS.length];
    routes[id]={ id:id, agv:'A', color:color, building:false, points:[], start:null, goal:null, turnCount:0, waits:[] };
    activeRouteId=id;
    renderRoutesUI(); drawAll(); updateCursor();
  }

  function removeLastRoute(){
    var ids=getOrderedRouteIds();
    if(!ids.length) return;
    var lastId=ids[ids.length-1];

    // ジョブからも削除
    jobs.forEach(j=>{
      j.routeIds = (j.routeIds||[]).filter(rid=>rid!==lastId);
    });

    delete routes[lastId];
    if(activeRouteId===lastId){
      ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[ids.length-1]:null;
    }
    renderRoutesUI();
    renderJobsUI();
    drawAll();
    updateCursor();
  }

  function setActiveRoute(id){
    if(id==null){
      var ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[0]:null;
    }else activeRouteId=id;
    drawAll(); updateCursor();
  }

  function setRouteAGV(id,agv){
    if(!routes[id]) return;
    routes[id].agv=agv;

    // ジョブの整合性チェック（入っているjobがあれば同一AGV条件）
    jobs.forEach(j=>{
      if((j.routeIds||[]).includes(id)){
        // jobAGVを固定している場合は不一致なら取り除く
        if(j.agv && j.agv!==agv){
          toast('エラー：Job'+j.id+'はAGV'+j.agv+'固定のため、ルートを外しました');
          j.routeIds = j.routeIds.filter(rid=>rid!==id);
        }
      }
    });

    renderJobsUI();
    drawAll();
  }

  function toggleRouteBuilding(id){
    if(!routes[id]) return;
    var wasOn=!!routes[id].building;
    Object.keys(routes).forEach(k=>routes[k].building=false);
    routes[id].building=!wasOn;
    activeRouteId=id;
    renderRoutesUI();
    drawAll();
    updateCursor();
  }

  function removeRouteSG(id){
    if(routes[id]){
      routes[id].start=null;
      routes[id].goal=null;
      drawAll();
    }
  }

  function clearRouteWaits(id){
    if(routes[id]){
      routes[id].waits = [];
      drawAll();
    }
  }

  function renderRoutesUI(){
    routesListEl.innerHTML='';
    var ids=getOrderedRouteIds();
    ids.forEach(function(id){
      var r=routes[id];
      var dispIdx=getDisplayIndex(id);

      var item=document.createElement('div');
      item.className='route-item';

      var name=document.createElement('div');
      name.className='route-name';
      name.textContent='Route '+dispIdx+' ';
      var chip=document.createElement('span');
      chip.style.cssText='display:inline-block;width:10px;height:10px;border-radius:999px;background:'+r.color+';margin-left:6px;';
      name.appendChild(chip);

      var sel=document.createElement('select');
      sel.style.cssText='border:none;border-radius:8px;padding:6px;';
      'ABCDEFGHIJ'.split('').forEach(function(ch){
        var opt=document.createElement('option');
        opt.value=ch; opt.textContent=ch;
        if(ch===r.agv) opt.selected=true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', function(e){
        e.stopPropagation();
        setRouteAGV(id, this.value);
      });

      var btn=document.createElement('button');
      btn.className='btn route-toggle';
      if(r.building){ btn.textContent='経路生成ON'; btn.style.background='#fff'; btn.style.color='#006666'; btn.style.border='none'; }
      else { btn.textContent='経路生成OFF'; btn.style.background='transparent'; btn.style.color='#fff'; btn.style.border='1px solid #fff'; }
      btn.addEventListener('click', function(e){ e.stopPropagation(); toggleRouteBuilding(id); });

      var sgBtn=document.createElement('button');
      sgBtn.className='btn ghost';
      sgBtn.textContent='S/G削除';
      sgBtn.addEventListener('click', function(e){ e.stopPropagation(); removeRouteSG(id); });

      item.addEventListener('click', function(){ setActiveRoute(id); });

      item.appendChild(name);
      item.appendChild(sel);
      item.appendChild(btn);
      item.appendChild(sgBtn);

      // サブ（旋回数・待機）
      var sub=document.createElement('div');
      sub.className='route-sub';

      var turnLbl=document.createElement('label');
      turnLbl.textContent='旋回数(90°換算)';
      var turnInp=document.createElement('input');
      turnInp.type='number'; turnInp.min='0'; turnInp.step='1';
      turnInp.value = (r.turnCount||0);
      turnInp.addEventListener('change', function(e){
        e.stopPropagation();
        routes[id].turnCount = Math.max(0, parseInt(this.value,10)||0);
        drawAll();
      });

      var waitPill=document.createElement('span');
      waitPill.className='pill';
      waitPill.textContent='待機点 '+(r.waits? r.waits.length:0)+' / 合計 '+waitSumSeconds(r).toFixed(0)+'s';

      var wClear=document.createElement('button');
      wClear.className='btn ghost slim';
      wClear.textContent='待機全消去';
      wClear.addEventListener('click', function(e){
        e.stopPropagation();
        clearRouteWaits(id);
      });

      var hint=document.createElement('span');
      hint.className='note';
      hint.textContent='待機点追加：Shift+ダブルクリック';

      sub.appendChild(turnLbl);
      sub.appendChild(turnInp);
      sub.appendChild(waitPill);
      sub.appendChild(wClear);
      sub.appendChild(hint);

      // route-item の下に差し込み
      routesListEl.appendChild(item);
      routesListEl.appendChild(sub);
    });
  }

  /* ========================
     Job UI
  =========================*/
  function addJob(){
    var id=nextJobId++;
    jobs.push({ id:id, name:'Job'+id, agv:'A', routeIds:[] });
    activeJobId=id;
    renderJobsUI(); drawAll();
  }

  function removeLastJob(){
    if(!jobs.length) return;
    var last=jobs[jobs.length-1];
    jobs.pop();
    if(activeJobId===last.id) activeJobId = jobs.length ? jobs[jobs.length-1].id : null;
    renderJobsUI(); drawAll();
  }

  function getJob(id){ return jobs.find(j=>j.id===id) || null; }

  function renderJobsUI(){
    jobsListEl.innerHTML='';
    jobs.forEach(function(j){
      var item=document.createElement('div'); item.className='job-item';

      var name=document.createElement('div');
      name.innerHTML = '<b>'+escapeHtml(j.name)+'</b> <span class="note">（Job'+j.id+'）</span>';

      var sel=document.createElement('select');
      sel.style.cssText='border:none;border-radius:8px;padding:6px;';
      'ABCDEFGHIJ'.split('').forEach(function(ch){
        var opt=document.createElement('option');
        opt.value=ch; opt.textContent='AGV '+ch;
        if(ch===j.agv) opt.selected=true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', function(e){
        e.stopPropagation();
        j.agv = this.value;
        // 不一致ルートを外す
        var before=(j.routeIds||[]).slice();
        j.routeIds = (j.routeIds||[]).filter(rid=>routes[rid] && routes[rid].agv===j.agv);
        if(before.length!==j.routeIds.length) toast('JobのAGV変更により不一致ルートを除外しました');
        renderJobsUI(); drawAll();
      });

      var delBtn=document.createElement('button');
      delBtn.className='btn ghost';
      delBtn.textContent='削除';
      delBtn.addEventListener('click', function(e){
        e.stopPropagation();
        jobs = jobs.filter(x=>x.id!==j.id);
        if(activeJobId===j.id) activeJobId = jobs.length ? jobs[jobs.length-1].id : null;
        renderJobsUI(); drawAll();
      });

      item.addEventListener('click', function(){ activeJobId=j.id; });

      item.appendChild(name);
      item.appendChild(sel);
      item.appendChild(delBtn);

      var sub=document.createElement('div'); sub.className='job-sub';

      // ルート追加セレクト
      var routeSel=document.createElement('select');
      var opt0=document.createElement('option'); opt0.value=''; opt0.textContent='Route追加';
      routeSel.appendChild(opt0);

      getOrderedRouteIds().forEach(function(rid){
        var r=routes[rid];
        if(!r) return;
        // 同一AGVだけ出す
        if(r.agv!==j.agv) return;
        var di=getDisplayIndex(rid);
        var o=document.createElement('option');
        o.value=rid;
        o.textContent='Route '+di+' (AGV '+r.agv+')';
        routeSel.appendChild(o);
      });

      var addBtn=document.createElement('button');
      addBtn.className='btn primary slim';
      addBtn.textContent='追加';
      addBtn.addEventListener('click', function(e){
        e.stopPropagation();
        var rid = parseInt(routeSel.value,10);
        if(!rid){ toast('追加するRouteを選択してください'); return; }
        if(!routes[rid]) return;
        if(routes[rid].agv!==j.agv){ toast('エラー：AGV不一致'); return; }
        j.routeIds = j.routeIds || [];
        j.routeIds.push(rid);
        renderJobsUI(); drawAll();
      });

      var upBtn=document.createElement('button');
      upBtn.className='btn ghost slim';
      upBtn.textContent='↑';
      upBtn.title='最後のRouteを上へ';
      upBtn.addEventListener('click', function(e){
        e.stopPropagation();
        if(!j.routeIds || j.routeIds.length<2) return;
        var n=j.routeIds.length;
        var tmp=j.routeIds[n-2]; j.routeIds[n-2]=j.routeIds[n-1]; j.routeIds[n-1]=tmp;
        renderJobsUI(); drawAll();
      });

      var popBtn=document.createElement('button');
      popBtn.className='btn ghost slim';
      popBtn.textContent='−';
      popBtn.title='最後のRouteを削除';
      popBtn.addEventListener('click', function(e){
        e.stopPropagation();
        if(!j.routeIds || !j.routeIds.length) return;
        j.routeIds.pop();
        renderJobsUI(); drawAll();
      });

      var seq=document.createElement('span');
      seq.className='seq';
      var seqText = (j.routeIds||[]).map(rid=>{
        var di=getDisplayIndex(rid);
        return 'R'+di;
      }).join(' → ');
      seq.innerHTML = '<b>順番</b>：'+(seqText||'（未設定）');

      sub.appendChild(routeSel);
      sub.appendChild(addBtn);
      sub.appendChild(upBtn);
      sub.appendChild(popBtn);
      sub.appendChild(seq);

      jobsListEl.appendChild(item);
      jobsListEl.appendChild(sub);
    });
  }

  /* ========================
     入力（ルート作成 / 待機点 / パン / ズーム / 画像操作）
  =========================*/
  function updateCursor(){ canvas.style.cursor = anyBuilding()? 'crosshair' : 'grab'; }

  function onCanvasClick(e){
    var r=routes[activeRouteId];
    if(r && r.building){
      var s=clientToCanvasXY(e.clientX,e.clientY), w=screenToWorld(s.x,s.y);
      var xy=[Math.round(w.x/GRID)*GRID, Math.round(w.y/GRID)*GRID];

      if(r.points.length>0){
        var a={x:r.points[r.points.length-1][0], y:r.points[r.points.length-1][1]};
        if(approx(a.x,xy[0])&&approx(a.y,xy[1])) return;
        if(!approx(a.x,xy[0]) && !approx(a.y,xy[1])){ toast('直前の点と水平/垂直にしてください'); return; }
      }
      r.points.push(xy);
      drawAll();
      return;
    }
  }

  function onCanvasDblClick(e){
    var r=routes[activeRouteId]; if(!r) return;
    if(!r.building) return;
    e.preventDefault();

    var s=clientToCanvasXY(e.clientX,e.clientY), w=screenToWorld(s.x,s.y);
    var xy=[Math.round(w.x/GRID)*GRID, Math.round(w.y/GRID)*GRID];
    var base=polylineFromPoints(r);
    if(base.length<2){ toast('先にポイントを2点以上追加してください'); return; }
    var snapped=projectToPolyline(xy, base, SNAP_TOL);
    if(!snapped){ toast('ルート線上に設定してください'); return; }

    // Shift + dblclick = wait
    if(e.shiftKey){
      var secStr = prompt('待機秒数[s]（数字）', '5');
      if(secStr==null) return;
      var sec = Math.max(0, parseFloat(secStr)||0);
      r.waits = r.waits || [];
      r.waits.push({ x:snapped.x, y:snapped.y, sec:sec });
      drawAll();
      return;
    }

    // 通常 dblclick = S→G
    var sxy=[snapped.x,snapped.y];
    if(!r.start){ r.start=sxy; drawAll(); return; }
    if(!r.goal){ r.goal=sxy; drawAll(); return; }
    toast('S/Gは各ルート1回ずつです（S/G削除でやり直し）');
  }

  function onMouseDown(e){
    if(anyBuilding()) return;

    // 画像が選択されているなら、画像操作を優先
    var itSel=getSelectedImage();
    if(itSel){
      var pick=pickImage(e.clientX, e.clientY);
      if(pick && pick.it.id===itSel.id){
        imgDrag.active=true; imgDrag.mode=pick.mode; imgDrag.start=clientToCanvasXY(e.clientX,e.clientY);
        imgDrag.keepAR=!e.shiftKey;
        imgDrag.base={ x:itSel.x, y:itSel.y, w:itSel.w, h:itSel.h };
        e.preventDefault();
        return;
      }
    }

    // パン
    view.dragging=true;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.dragStart=s;
    view.startOffset={ x:view.offsetX, y:view.offsetY };
    canvas.style.cursor='grabbing';
    e.preventDefault();
  }

  function onMouseMove(e){
    // 画像ドラッグ
    if(imgDrag.active && selectedImgId){
      var it=getSelectedImage(); if(!it) return;
      var cur=clientToCanvasXY(e.clientX,e.clientY);
      var dx=(cur.x-imgDrag.start.x)/view.scale;
      var dy=(cur.y-imgDrag.start.y)/view.scale;

      if(imgDrag.mode==='move'){
        it.x=imgDrag.base.x+dx;
        it.y=imgDrag.base.y+dy;
      }else{
        var bx=imgDrag.base.x, by=imgDrag.base.y, bw=imgDrag.base.w, bh=imgDrag.base.h;
        var ar=bw/Math.max(1e-6,bh);

        var nx=bx, ny=by, nw=bw, nh=bh;
        if(imgDrag.mode==='nw'){ nx=bx+dx; ny=by+dy; nw=bw-dx; nh=bh-dy; }
        else if(imgDrag.mode==='ne'){ ny=by+dy; nw=bw+dx; nh=bh-dy; }
        else if(imgDrag.mode==='sw'){ nx=bx+dx; nw=bw-dx; nh=bh+dy; }
        else if(imgDrag.mode==='se'){ nw=bw+dx; nh=bh+dy; }

        nw=Math.max(10,nw); nh=Math.max(10,nh);

        if(imgDrag.keepAR){
          if(Math.abs(nw-bw) > Math.abs(nh-bh)) nh=nw/ar; else nw=nh*ar;
          if(imgDrag.mode==='nw'){ nx=bx+(bw-nw); ny=by+(bh-nh); }
          if(imgDrag.mode==='ne'){ ny=by+(bh-nh); }
          if(imgDrag.mode==='sw'){ nx=bx+(bw-nw); }
        }

        it.x=nx; it.y=ny; it.w=nw; it.h=nh;
      }
      drawAll();
      return;
    }

    // パン
    if(!view.dragging) return;
    var s=clientToCanvasXY
