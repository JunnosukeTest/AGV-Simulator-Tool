<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - SG-only (Manhattan), animated 90° turns, KPI=SG + turnCount</title>
<style>
  :root { --brand:#006666; --accent:#ff9900; --panel:#004d4d; --grid:#e6e6e6; }
  * { box-sizing:border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  body { margin:0; display:flex; height:100vh; overflow:hidden; }
  .sidebar { width:360px; flex-shrink:0; color:#fff; background:var(--brand); padding:12px 14px; display:flex; flex-direction:column; gap:12px; overflow-y:auto; }
  h1 { font-size:18px; margin:6px 0 8px; font-weight:700; }
  .section { background:var(--panel); border-radius:10px; padding:10px; }
  .row { display:flex; align-items:center; gap:8px; margin:6px 0; }
  .btn { cursor:pointer; border:none; border-radius:8px; padding:6px 8px; font-weight:700; font-size:13px; }
  .btn.primary { background:#fff; color:var(--brand); }
  .btn.ghost { background:transparent; border:1px solid #fff; color:#fff; }
  .note { font-size:12px; opacity:.9; }
  .status { background:#003d3d; padding:8px; border-radius:8px; font-size:13px; line-height:1.4; }
  canvas { flex:1; display:block; background:#fff; min-width:260px; }
  .routes-list { display:flex; flex-direction:column; gap:8px; }
  .route-item { background:#003c3c; border-radius:8px; padding:8px; display:grid; grid-template-columns: 1fr auto auto auto; gap:8px; align-items:center; }
  .route-name { font-weight:700; }
  .route-toggle { min-width:100px; }
  .toast { position:fixed; left:50%; top:18px; transform:translateX(-50%); background:#333; color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transition:opacity .2s ease; pointer-events:none; z-index:9; }
  .toast.show { opacity:.95; }
  .banner { position:fixed; left:0; right:0; top:0; padding:8px 12px; background:#c62828; color:#fff; font-weight:700; display:none; z-index:10; }
  .sim-btn { min-width:220px; }

  /* 車体テーブル（A〜J）: 速度 / 積み下ろし / 旋回 / 旋回数 */
  .vehicle-grid { display:grid; grid-template-columns: 56px 70px 76px 64px 64px; gap:6px; align-items:center; }
  .vehicle-grid .head { font-weight:700; opacity:.9; }
  .vehicle-grid input { width:50px; padding:1px 3px; font-size:13px; }

  .summary-line { display:flex; justify-content:space-between; gap:8px; }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>AGV ルート作成（S↔G 間のみ走行）</h1>

    <div class="section">
      <div class="row"><strong>操作手順</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>ルートを <b>＋</b> で追加し、AGVを選択</li>
        <li>そのルートの <b>経路生成ON</b> を押す（ONのルートだけ編集可。再押しでOFF）</li>
        <li>キャンバスの交点をクリックでポイント追加（<b>水平・垂直のみ</b>）※走行はS↔Gのみ</li>
        <li>交点をダブルクリックで <b>S→G</b> を設定</li>
        <li>必要なら <b>S/G削除</b> で消して打ち直し</li>
      </ol>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ルート一覧</strong>
        <span class="note">（表示番号は小さい順の連番）</span>
      </div>
      <div id="routesList" class="routes-list"></div>
      <div class="row">
        <button id="addRoute" class="btn primary">＋ ルート追加</button>
        <button id="removeRoute" class="btn ghost">− 最後のルート削除</button>
      </div>
      <div class="row">
        <button id="exportBtn" class="btn ghost">JSON書き出し</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn ghost">JSON読み込み</button>
        <button id="exportHtmlBtn" class="btn ghost">HTML書き出し</button>
      </div>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>車体一覧（A〜J）</strong>
        <span class="note">速度[m/s]・積み下ろし[s]・旋回[s]・旋回数</span>
      </div>
      <div id="vehicles" class="vehicle-grid"></div>
    </div>

    <div class="section status">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ステータス（距離・KPI）</strong>
        <span class="note">1マス=1m / 端点反転=180°=turn×2秒×2箇所→合計4×turn</span>
      </div>
      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="chargePct">充電率ダウンタイム（0–30%）</label>
        <input id="chargePct" type="number" min="0" max="30" step="1" value="0" style="width:64px;"/>
        <span class="note">※KPI稼働率=(1-充電率)</span>
      </div>
      <div id="routesSummary" style="display:flex; flex-direction:column; gap:4px;"></div>
    </div>

    <div class="section">
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除（アクティブルート）</button>
      </div>
      <div class="row">
        <button id="clear" class="btn ghost">アクティブルート全消去</button>
      </div>
      <div class="row">
        <button id="simulateToggle" class="btn primary sim-btn">シミュレーション開始（S/G間のみ往復・アクティブルート）</button>
      </div>
      <div class="note">Ctrl+Z でも1つ戻せます</div>
    </div>
  </aside>

  <canvas id="map"></canvas>
  <div id="toast" class="toast"></div>
  <div id="banner" class="banner"></div>

<script defer>
(function(){
  var PX_PER_M = 40;   // 表示1マス=40px（論理1m）
  var GRID = PX_PER_M;
  var ROUTE_COLORS = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad','#16a085','#f39c12','#c0392b','#2980b9','#7f8c8d'];

  var canvas, ctx, toastEl;
  var routes = {};        // { id, agv, color, building, points:[], start:null, goal:null }
  var activeRouteId = null;
  var nextId = 1;         // 内部ID連番

  var vehicles = {};      // { 'A': {speed, load, turn, turnCount}, ... }
  'ABCDEFGHIJ'.split('').forEach(function(ch){
    vehicles[ch] = { speed:0.5, load:2, turn:2, turnCount:0 };
  });

  var simRunning = false;
  // SGのみ：path は S -> elbow -> G の2セグメント（往復）
  var sims = {}; // { routeId: {path:[], segIndex, forward, pixPerSec, lastTs, pos:{x,y}, heading, phase, dwellEnd, turnEnd, targetHeading, turnStartHeading, turnStartTime, turnDuration, turnQueue:[], turnAfterDwell:false} }

  var routesListEl, addRouteBtn, removeRouteBtn, undoBtn, clearBtn, simulateBtn;
  var vehiclesEl, exportBtn, importBtn, importFile, routesSummaryEl, exportHtmlBtn, chargePctEl;

  function showBanner(msg){ var b=document.getElementById('banner'); b.textContent=msg; b.style.display='block'; }
  function toast(msg){ if(!toastEl) return; toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(function(){toastEl.classList.remove('show');}, 1100); }
  function getOrderedIds(){ return Object.keys(routes).map(function(k){return parseInt(k,10);}).sort(function(a,b){return a-b;}); }
  function getDisplayIndex(id){ var ids=getOrderedIds(); var idx=ids.indexOf(id); return idx===-1? null : (idx+1); }

  // 補助：S↔G のみ用 L字パス（マンハッタン：S→(Gx,Sy)→G）
  function buildSGPath(r){
    if(!r || !r.start || !r.goal) return [];
    var A = {x:r.start[0], y:r.start[1]};
    var C = {x:r.goal[0],  y:r.start[1]}; // エルボー
    var B = {x:r.goal[0],  y:r.goal[1]};
    var path = [A];
    // 同一点/斜め防止（L字）: A->C（水平）/ C->B（垂直）。A==C または C==B ならスキップ
    if(!(A.x===C.x && A.y===C.y)) path.push(C);
    if(!(C.x===B.x && C.y===B.y)) path.push(B);
    return path;
  }

  // ポリラインの整形（編集用の細線描画に使うだけ）
  function buildPath(r){
    if(!r) return [];
    var path = [];
    if(r.start) path.push({x:r.start[0], y:r.start[1]});
    for(var i=0;i<r.points.length;i++) path.push({x:r.points[i][0], y:r.points[i][1]});
    if(r.goal)  path.push({x:r.goal[0], y:r.goal[1]});
    var clean=[];
    for(var j=0;j<path.length;j++){
      if(!clean.length){ clean.push(path[j]); continue; }
      var a=clean[clean.length-1], b=path[j];
      if(a.x===b.x && a.y===b.y) continue;
      if(a.x!==b.x && a.y!==b.y) continue;
      clean.push(b);
    }
    return clean;
  }

  function manhattanSGMeters(r){
    if(!r || !r.start || !r.goal) return 0;
    var dx = Math.abs(r.goal[0]-r.start[0]);
    var dy = Math.abs(r.goal[1]-r.start[1]);
    return (dx+dy) / PX_PER_M; // S→Gのマス目距離
  }

  // --- KPI（S↔G距離ベース、旋回数 turnCount を反映） ---
  function computeCycleTimeSeconds(r){
    if(!r || !r.start || !r.goal) return null;
    var v = vehicles[r.agv] || {speed:0.5, load:2, turn:2, turnCount:0};

    var dist_m_oneway = manhattanSGMeters(r);
    var travel = (2 * dist_m_oneway) / Math.max(0.01, v.speed);    // 走行

    var tcount = Math.max(0, (v.turnCount|0));                     // 旋回数（90°）
    var turnTime = (4 + tcount) * Math.max(0, v.turn);             // 旋回（端点4＋中間の旋回数）

    var dwell = 2 * Math.max(0, v.load);                           // 積み下ろし

    return travel + turnTime + dwell; // 秒
  }

  function renderKPI(){
    var ids=getOrderedIds(); routesSummaryEl.innerHTML='';
    var chargePct = Math.min(30, Math.max(0, parseFloat(chargePctEl.value)||0));
    var avail = 1 - (chargePct/100);
    var totalPerH = 0;
    if(!ids.length){ routesSummaryEl.textContent='ルート無し'; return; }

    ids.forEach(function(id){
      var r=routes[id]; var dispIdx=getDisplayIndex(id);
      var m=manhattanSGMeters(r);                      // 表示距離はS→G
      var v=vehicles[r.agv] || {speed:0.5, load:2, turn:2, turnCount:0};
      var cyc = computeCycleTimeSeconds(r);
      var perH = (cyc? (3600 / (cyc/Math.max(0.01, avail))) : 0);
      totalPerH += perH||0;

      // 内訳も表示
      var travel = (2 * m) / Math.max(0.01, v.speed);
      var tcount = Math.max(0, (v.turnCount|0));
      var turnTime = (4 + tcount) * Math.max(0, v.turn);
      var dwell = 2 * Math.max(0, v.load);

      var line=document.createElement('div'); line.className='summary-line';
      var kpiStr = (cyc? ('KPI: '+perH.toFixed(2)+' 回/時') : 'KPI: −');
      line.innerHTML =
        '<span>ルート'+dispIdx+'</span>'
      + '<span>距離: '+m.toFixed(1)+' m｜'+kpiStr
      + '（走行 '+travel.toFixed(1)+'s, 旋回 (4+'+tcount+')×'+v.turn+'s='+(turnTime.toFixed(1))+'s, 積み下ろし '+dwell.toFixed(1)+'s）</span>';
      routesSummaryEl.appendChild(line);
    });

    var sum=document.createElement('div'); sum.className='summary-line';
    sum.innerHTML='<span><strong>合計</strong></span><span><strong>'+ totalPerH.toFixed(2) +' 回/時</strong></span>';
    routesSummaryEl.appendChild(sum);
  }

  function ready(){
    canvas = document.getElementById('map') || document.getElementById('mapCanvas');
    if(!canvas){ showBanner('Canvasが見つかりません（id="map" または "mapCanvas"）'); return; }
    ctx = canvas.getContext('2d');
    toastEl = document.getElementById('toast');

    routesListEl = document.getElementById('routesList');
    addRouteBtn = document.getElementById('addRoute');
    removeRouteBtn = document.getElementById('removeRoute');
    undoBtn = document.getElementById('undo');
    clearBtn = document.getElementById('clear');
    simulateBtn = document.getElementById('simulateToggle');
    vehiclesEl = document.getElementById('vehicles');
    exportBtn = document.getElementById('exportBtn');
    importBtn = document.getElementById('importBtn');
    importFile = document.getElementById('importFile');
    routesSummaryEl = document.getElementById('routesSummary');
    exportHtmlBtn = document.getElementById('exportHtmlBtn');
    chargePctEl = document.getElementById('chargePct');

    addRouteBtn.addEventListener('click', addRoute);
    removeRouteBtn.addEventListener('click', removeLastRoute);
    undoBtn.addEventListener('click', undoPoint);
    clearBtn.addEventListener('click', clearActiveRoute);
    simulateBtn.addEventListener('click', onSimToggle);
    exportBtn.addEventListener('click', onExport);
    importBtn.addEventListener('click', function(){ importFile.click(); });
    importFile.addEventListener('change', onImport);
    if(exportHtmlBtn) exportHtmlBtn.addEventListener('click', onExportHtml);
    chargePctEl.addEventListener('change', renderKPI);

    window.addEventListener('resize', function(){ resize(); drawAll(); });
    canvas.addEventListener('click', onCanvasClick, {passive:true});
    canvas.addEventListener('dblclick', onCanvasDblClick, {passive:false});
    window.addEventListener('keydown', onKey);

    resize();
    addRoute();
    setActiveRoute(activeRouteId);
    renderVehiclesUI();
    drawAll();
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', ready); else ready();

  function resize(){
    var sidebar = document.querySelector('.sidebar');
    var sw = sidebar ? sidebar.offsetWidth : 360;
    var w = Math.max(260, window.innerWidth - sw);
    canvas.width = w; canvas.height = window.innerHeight;
  }
  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#e6e6e6'; ctx.lineWidth = 1;
    for(var x=0; x<=canvas.width; x+=GRID){ ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,canvas.height); ctx.stroke(); }
    for(var y=0; y<=canvas.height; y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y+.5); ctx.lineTo(canvas.width,y+.5); ctx.stroke(); }
  }
  function drawRoutes(){
    var ids = getOrderedIds();
    ids.forEach(function(id){
      var r = routes[id];
      var dispIdx = getDisplayIndex(id);
      var path = buildPath(r); // 細線は従来の編集ルートを描画（走行には使わない）
      if(path.length>=2){
        ctx.lineWidth = 2; ctx.strokeStyle = r.color;
        for(var i=0;i<path.length-1;i++){
          var A=path[i], B=path[i+1];
          ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
        }
      }
      for(var j=0;j<r.points.length;j++){
        var p=r.points[j]; ctx.fillStyle=r.color; ctx.beginPath(); ctx.arc(p[0],p[1],4,0,Math.PI*2); ctx.fill(); }
      ctx.fillStyle = '#000'; ctx.font='bold 16px system-ui, sans-serif';
      if(r.start) ctx.fillText('S'+dispIdx, r.start[0]-10, r.start[1]-8);
      if(r.goal)  ctx.fillText('G'+dispIdx, r.goal[0]-10,  r.goal[1]-8);
    });
  }

  // ★ シミュレーション中だけ S↔G（L字：S→(Gx,Sy)→G）を太線でハイライト
  function drawActiveSGBold(){
    if(!simRunning) return;
    var id = activeRouteId;
    var r = routes[id];
    if(!r || !r.start || !r.goal) return;

    var sg = buildSGPath(r);
    if(sg.length < 2) return;

    ctx.save();
    ctx.lineCap = 'round';

    // 下地の太線（半透明）
    ctx.lineWidth = 12;
    ctx.strokeStyle = r.color;
    ctx.globalAlpha = 0.28;
    ctx.beginPath();
    ctx.moveTo(sg[0].x, sg[0].y);
    for (var i=1;i<sg.length;i++) ctx.lineTo(sg[i].x, sg[i].y);
    ctx.stroke();

    // 中心の実線
    ctx.globalAlpha = 1;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(sg[0].x, sg[0].y);
    for (var j=1;j<sg.length;j++) ctx.lineTo(sg[j].x, sg[j].y);
    ctx.stroke();

    ctx.restore();
  }

  function drawAGVs(){
    if(!simRunning) return;
    Object.keys(sims).forEach(function(idStr){
      var id = +idStr; var r = routes[id]; var s = sims[idStr];
      if(!r || !s) return;
      var L = 22, W = 14; // 本体サイズ(px)
      var rad = (s.heading||0) * Math.PI/180;
      ctx.save();
      ctx.translate(s.pos.x, s.pos.y);
      ctx.rotate(rad);
      ctx.fillStyle = r.color; ctx.fillRect(-L/2, -W/2, L, W);
      ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(L/2, 0); ctx.lineTo(L/2-4, -3); ctx.lineTo(L/2-4, 3); ctx.closePath(); ctx.fill();
      ctx.restore();
    });
  }

  function drawAll(){ 
    drawGrid(); 
    drawRoutes(); 
    drawActiveSGBold();   // シミュ中のみ太線強調（S↔G のみ）
    drawAGVs(); 
    renderKPI(); 
  }

  function addRoute(){
    var id = nextId++;
    var color = ROUTE_COLORS[(id-1)%ROUTE_COLORS.length];
    routes[id] = { id:id, agv:'A', color:color, building:false, points:[], start:null, goal:null };
    activeRouteId = id;
    renderRoutesUI(); drawAll();
  }
  function removeLastRoute(){
    var ids = getOrderedIds(); if(!ids.length) return;
    var lastId = ids[ids.length-1];
    delete routes[lastId];
    if(activeRouteId === lastId){ ids = getOrderedIds(); activeRouteId = ids.length ? ids[ids.length-1] : null; }
    if(simRunning && sims[lastId]){ delete sims[lastId]; checkSimEnd(); }
    renderRoutesUI(); drawAll();
  }
  function setActiveRoute(id){
    if(id==null){ var ids=getOrderedIds(); activeRouteId = ids.length ? ids[0] : null; }
    else { activeRouteId=id; }
    drawAll();
  }
  function setRouteAGV(id, agv){ if(routes[id]) routes[id].agv = agv; drawAll(); }
  function toggleRouteBuilding(id){
    if(!routes[id]) return;
    var wasOn = !!routes[id].building;
    Object.keys(routes).forEach(function(k){ routes[k].building = false; });
    routes[id].building = !wasOn; activeRouteId = id;
    renderRoutesUI(); drawAll();
  }

  function renderRoutesUI(){
    routesListEl.innerHTML = '';
    var ids = getOrderedIds();
    ids.forEach(function(id){
      var r = routes[id];
      var dispIdx = getDisplayIndex(id);
      var item = document.createElement('div'); item.className = 'route-item';

      var name = document.createElement('div'); name.className='route-name'; name.textContent = 'ルート'+dispIdx+' ';
      var chip = document.createElement('span'); chip.style.display='inline-block'; chip.style.width='10px'; chip.style.height='10px'; chip.style.borderRadius='999px'; chip.style.background=r.color; chip.style.marginLeft='6px'; name.appendChild(chip);

      var sel = document.createElement('select');
      'ABCDEFGHIJ'.split('').forEach(function(ch){ var opt=document.createElement('option'); opt.value=ch; opt.textContent=ch; if(ch===r.agv) opt.selected=true; sel.appendChild(opt); });
      sel.addEventListener('change', function(e){ e.stopPropagation(); setRouteAGV(id, this.value); });

      var btn = document.createElement('button'); btn.className='btn route-toggle';
      btn.textContent = r.building? '経路生成ON':'経路生成OFF';
      btn.style.background = r.building? '#fff':'透明';
      btn.style.color = r.building? '#006666':'#fff';
      btn.addEventListener('click', function(e){ e.stopPropagation(); toggleRouteBuilding(id); });

      var sgBtn = document.createElement('button'); sgBtn.className='btn ghost'; sgBtn.textContent='S/G削除';
      sgBtn.addEventListener('click', function(e){ e.stopPropagation(); if(routes[id]){ routes[id].start=null; routes[id].goal=null; drawAll(); } });

      item.addEventListener('click', function(){ setActiveRoute(id); });

      item.appendChild(name); item.appendChild(sel); item.appendChild(btn); item.appendChild(sgBtn);
      routesListEl.appendChild(item);
    });
  }

  function renderVehiclesUI(){
    var v = vehicles, html='';
    html += '<div></div>'
         +  '<div class="head">速度[m/s]</div>'
         +  '<div class="head">積み下ろし[s]</div>'
         +  '<div class="head">旋回[s]</div>'
         +  '<div class="head">旋回数</div>';
    'ABCDEFGHIJ'.split('').forEach(function(ch){
      html += '<div><strong>'+ch+'</strong></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="speed" type="number" step="0.1" value="'+v[ch].speed+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="load"  type="number" step="0.1" value="'+v[ch].load+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="turn"  type="number" step="0.1" value="'+v[ch].turn+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="turnCount" type="number" step="1" min="0" value="'+(v[ch].turnCount||0)+'"></div>';
    });
    vehiclesEl.innerHTML = html;
    vehiclesEl.querySelectorAll('input').forEach(function(inp){
      inp.addEventListener('change', function(){
        var k=this.getAttribute('data-vkey');
        var f=this.getAttribute('data-field');
        var raw=this.value;
        var val = (f==='turnCount') ? parseInt(raw,10) : parseFloat(raw);
        if(!isFinite(val) || val<0) val = 0;
        vehicles[k][f]=val;
        drawAll();
      });
    });
  }

  function snapToGrid(clientX, clientY){ var r=canvas.getBoundingClientRect(); var x=Math.round((clientX-r.left)/GRID)*GRID; var y=Math.round((clientY-r.top)/GRID)*GRID; return [x,y]; }
  function onCanvasClick(e){ var r=routes[activeRouteId]; if(!r){ toast('ルートを選択'); return; } if(!r.building){ toast('編集するルートで「経路生成ON」を押してください'); return; } var xy=snapToGrid(e.clientX,e.clientY); if(r.points.length>0){ var last=r.points[r.points.length-1]; if(last[0]===xy[0] && last[1]===xy[1]){ return; } if(last[0]!==xy[0] && last[1]!==xy[1]){ toast('斜めは不可'); return; } } r.points.push(xy); drawAll(); }
  function onCanvasDblClick(e){ var r=routes[activeRouteId]; if(!r) return; e.preventDefault(); var xy=snapToGrid(e.clientX,e.clientY); if(!r.start){ r.start=xy; } else if(r.start && !r.goal){ r.goal=xy; } drawAll(); }
  function onKey(e){ if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ undoPoint(); } }
  function undoPoint(){ var r=routes[activeRouteId]; if(!r) return; r.points.pop(); drawAll(); }
  function clearActiveRoute(){ var r=routes[activeRouteId]; if(!r) return; r.points.length=0; r.start=null; r.goal=null; drawAll(); }

  function onExport(){ var data={ routes: routes, vehicles: vehicles, meta:{ pxPerM:PX_PER_M, ts:Date.now() } }; var blob=new Blob([JSON.stringify(data,null,2)], {type:'application/json'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='agv_routes.json'; a.click(); URL.revokeObjectURL(a.href); }
  function onImport(evt){ var file=evt.target.files && evt.target.files[0]; if(!file) return; var reader=new FileReader(); reader.onload=function(){ try{ var obj=JSON.parse(reader.result); if(obj.vehicles) vehicles=obj.vehicles; if(obj.routes){ routes={}; Object.keys(obj.routes).forEach(function(k){ routes[+k]=obj.routes[k]; }); } nextId=(Math.max(0, ...Object.keys(routes).map(function(k){return +k;})) || 0)+1; renderVehiclesUI(); renderRoutesUI(); setActiveRoute(null); drawAll(); toast('JSONを読み込みました'); }catch(err){ toast('読み込みエラー: '+err.message); } }; reader.readAsText(file); }
  function onExportHtml(){ try{ var html='<!DOCTYPE html>'+document.documentElement.outerHTML; var blob=new Blob([html], {type:'text/html'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='agv_simulator.html'; a.click(); URL.revokeObjectURL(a.href); toast('HTMLを書き出しました'); }catch(e){ toast('HTML書き出しでエラー: '+e.message); } }

  // 向きユーティリティ（90°系）
  function headingOf(A,B){ if(B.x>A.x) return 0; if(B.x<A.x) return 180; if(B.y>A.y) return 90; if(B.y<A.y) return -90; return 0; }
  function angleDelta(a,b){ var d=((b-a+540)%360)-180; return Math.round(d); }
  function lerpAngle(a,b,t){ var d = angleDelta(a,b); return a + d * t; }
  function normHeading(h){ h = ((h % 360)+360)%360; return h===-0?0:h; }

  // 90°分割回頭（180°は 90°×2 に分割）
  function pushTurnSegments(state, deltaDeg, turnS){
    var steps = []; var d = Math.abs(deltaDeg);
    if(d===180){ steps.push({delta: Math.sign(deltaDeg)*90}); steps.push({delta: Math.sign(deltaDeg)*90}); }
    else if(d===90){ steps.push({delta: Math.sign(deltaDeg)*90}); }
    state.turnQueue = steps.map(function(seg){ return { target:null, delta: seg.delta, duration: turnS*1000 }; });
  }
  function startNextTurnSegment(state, now){
    if(!state.turnQueue || !state.turnQueue.length) return false;
    var seg = state.turnQueue.shift();
    var tgt = normHeading(state.heading + seg.delta);
    state.targetHeading = tgt;
    state.turnStartHeading = state.heading;
    state.turnStartTime = now;
    state.turnDuration = seg.duration;
    state.turnEnd = now + seg.duration;
    return true;
  }

  // シミュレーション（S↔G のみ：L字パスで往復）
  function onSimToggle(){
    if(simRunning){
      simRunning=false; sims={};
      simulateBtn.textContent='シミュレーション開始（S/G間のみ往復・アクティブルート）';
      drawAll(); return;
    }
    sims={};
    var id = activeRouteId;
    var r = routes[id];
    if(!r || !r.start || !r.goal){ toast('アクティブルートにS/Gを設定してください'); return; }

    var clean = buildSGPath(r);            // ★ S→(Gx,Sy)→G のみ使用
    if(clean.length<2){ toast('SとGを含むルートを作ってください'); return; }

    var agv=r.agv; var speed=vehicles[agv]?vehicles[agv].speed:0.5;
    var heading0=headingOf(clean[0],clean[1]);
    sims[id]={ path:clean, segIndex:0, forward:true, pixPerSec:speed*PX_PER_M, lastTs:performance.now(), pos:{x:clean[0].x,y:clean[0].y}, heading:heading0, phase:'move', dwellEnd:null, turnEnd:null, targetHeading:null, turnStartHeading:null, turnStartTime:null, turnDuration:null, turnQueue:[], turnAfterDwell:false };
    simRunning=true; simulateBtn.textContent='シミュレーション停止'; requestAnimationFrame(stepSimAll);
  }

  function stepSimAll(ts){
    if(!simRunning) return;
    var id = activeRouteId; var s=sims[id]; var r = routes[id]; if(!s||!r){ simRunning=false; simulateBtn.textContent='シミュレーション開始（S/G間のみ往復・アクティブルート）'; return; }
    var agv=r.agv; var turnS=(vehicles[agv] && +vehicles[agv].turn)||0; var loadS=(vehicles[agv] && +vehicles[agv].load)||0; var now=ts; var dt=(now - s.lastTs)/1000; s.lastTs=now;

    // 1) Dwell（端点で積み下ろし）
    if(s.phase==='dwell'){
      if(now < s.dwellEnd){ drawAll(); return requestAnimationFrame(stepSimAll); }
      // dwell完了 → 180°反転（90°×2）
      s.phase='turn'; s.turnAfterDwell=true;
      pushTurnSegments(s, 180, turnS);
      startNextTurnSegment(s, now);
      drawAll(); return requestAnimationFrame(stepSimAll);
    }

    // 2) Turn（向き合わせ/反転）
    if(s.phase==='turn'){
      if(now < s.turnEnd){
        var total=(s.turnDuration!=null ? s.turnDuration : (turnS*1000));
        var ratio=Math.max(0, Math.min(1, (now - s.turnStartTime)/total)); s.heading=lerpAngle(s.turnStartHeading, s.targetHeading, ratio);
        drawAll(); return requestAnimationFrame(stepSimAll);
      }
      // セグメント完了
      s.heading=s.targetHeading; s.turnEnd=null; s.targetHeading=null; s.turnDuration=null; s.turnStartHeading=null; s.turnStartTime=null;
      if(s.turnQueue && s.turnQueue.length){
        startNextTurnSegment(s, now);
        drawAll(); return requestAnimationFrame(stepSimAll);
      }
      // 全ターン完了
      if(s.turnAfterDwell){ s.forward=!s.forward; s.turnAfterDwell=false; }
      s.phase='move';
    }

    // 3) Move（L字パス上を移動）
    var path=s.path; var aIdx=s.segIndex; var bIdx=s.forward ? aIdx+1 : aIdx-1;

    // 終端チェック
    if(bIdx<0 || bIdx>=path.length){
      // 端点：積み下ろし→反転へ
      s.phase='dwell';
      s.dwellEnd = now + Math.max(0, loadS)*1000;
      drawAll(); return requestAnimationFrame(stepSimAll);
    }

    var A=path[aIdx], B=path[bIdx];
    var desiredHeading=headingOf(A,B);
    var d = angleDelta(s.heading, desiredHeading); // -180..180
    if(d!==0 && turnS>0){
      // 線分に入る前の向き合わせ（90° or 180°を分割）
      s.phase='turn'; s.turnAfterDwell=false;
      pushTurnSegments(s, d, turnS);
      startNextTurnSegment(s, now);
      drawAll(); return requestAnimationFrame(stepSimAll);
    } else { s.heading=desiredHeading; }

    // 平行移動（水平/垂直）
    var move=s.pixPerSec*dt;
    if(A.x!==B.x){
      var dirx=Math.sign(B.x-s.pos.x); var remain=Math.abs(B.x-s.pos.x);
      if(move>=remain){ s.pos.x=B.x; s.pos.y=B.y; s.segIndex=bIdx; }
      else { s.pos.x += dirx*move; }
    } else {
      var diry=Math.sign(B.y-s.pos.y); var remainy=Math.abs(B.y-s.pos.y);
      if(move>=remainy){ s.pos.x=B.x; s.pos.y=B.y; s.segIndex=bIdx; }
      else { s.pos.y += diry*move; }
    }

    // コーナー到達時、次線分の方向に合わせる（次フレームでTurnへ）
    if(s.pos.x===B.x && s.pos.y===B.y){
      var nextA=s.segIndex, nextB=s.forward ? nextA+1 : nextA-1;
      if(nextB>=0 && nextB<path.length){
        var nextHeading=headingOf(path[nextA], path[nextB]);
        var d2 = angleDelta(s.heading, nextHeading);
        if(d2!==0 && turnS>0){
          s.phase='turn'; s.turnAfterDwell=false;
          pushTurnSegments(s, d2, turnS);
          startNextTurnSegment(s, now);
          drawAll(); return requestAnimationFrame(stepSimAll);
        }
      }
    }

    drawAll(); requestAnimationFrame(stepSimAll);
  }

  function checkSimEnd(){ if(!simRunning) return; var id=activeRouteId; var s=sims[id]; if(!s){ simRunning=false; simulateBtn.textContent='シミュレーション開始（S/G間のみ往復・アクティブルート）'; } }
})();
</script>
</body>
</html>
