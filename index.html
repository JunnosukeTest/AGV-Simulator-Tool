<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - Step0 Minimal</title>
<style>
  :root {
    --brand: #006666;       /* 濃い青緑 */
    --accent: #ff9900;      /* アクセント */
    --panel: #004d4d;
    --grid: #e6e6e6;
  }
  * { box-sizing: border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  body { margin: 0; display: flex; height: 100vh; overflow: hidden; }
  .sidebar {
    width: 340px; flex-shrink: 0; color: #fff; background: var(--brand);
    padding: 12px 14px; display: flex; flex-direction: column; gap: 12px; overflow-y: auto;
  }
  h1 { font-size: 18px; margin: 6px 0 8px; font-weight: 700; }
  .section { background: var(--panel); border-radius: 10px; padding: 10px; }
  .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
  .row label { flex: 1; }
  .row input[type="number"] { width: 110px; }
  .btn { cursor: pointer; border: none; border-radius: 8px; padding: 8px 10px; font-weight: 700; }
  .btn.primary { background: #fff; color: var(--brand); }
  .btn.ghost { background: transparent; border: 1px solid #fff; color: #fff; }
  .note { font-size: 12px; opacity: 0.9; }
  .status { background: #003d3d; padding: 8px; border-radius: 8px; font-size: 13px; line-height: 1.4; }
  canvas { flex: 1; display: block; background: #fff; }
  .pill { display:inline-block; background:#002f2f; color:#fff; padding:2px 8px; border-radius:999px; font-size:12px; margin-left:6px; }
  .toast {
    position: fixed; left: 50%; top: 18px; transform: translateX(-50%);
    background: #333; color: #fff; padding: 8px 12px; border-radius: 8px; font-size: 13px;
    opacity: 0; transition: opacity .2s ease; pointer-events: none; z-index: 9;
  }
  .toast.show { opacity: 0.95; }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>AGV ルート作成（Step0）<span class="pill">最小構成</span></h1>

    <div class="section">
      <div class="row"><strong>操作手順</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>ルート生成を <b>ON</b> にする</li>
        <li>キャンバスの <b>交点</b> をクリックしてポイントを追加（<b>水平・垂直のみ</b>）</li>
        <li>スタート/ゴールは <b>交点をダブルクリック</b>（交互に S→G→S→G…）</li>
        <li>やり直しは「最後のポイント削除」または「全消去」</li>
      </ol>
    </div>

    <div class="section">
      <div class="row">
        <label>ルート生成</label>
        <button id="toggleBuild" class="btn primary">ON</button>
      </div>
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除</button>
        <button id="clear" class="btn ghost">全消去</button>
      </div>
      <div class="note">グリッドは <b>1m/マス</b>（見やすさ用に 40px/マスで描画）</div>
    </div>

    <div class="section status" id="statusBox">
      追加ポイント: <span id="ptCount">0</span> 個<br/>
      スタート: <span id="sPos">-</span><br/>
      ゴール: <span id="gPos">-</span>
    </div>
  </aside>

  <canvas id="map"></canvas>
  <div id="toast" class="toast"></div>

<script>
(() => {
  // ==== 基本設定 ====
  const PX_PER_M = 40;       // 表示上の1マス＝40px（実質1m扱い）
  const GRID = PX_PER_M;     // グリッド間隔
  const map = document.getElementById('map');
  const ctx = map.getContext('2d');

  // レイアウト
  function resize() {
    const sidebarWidth = document.querySelector('.sidebar').offsetWidth;
    map.width = window.innerWidth - sidebarWidth;
    map.height = window.innerHeight;
    drawAll();
  }
  window.addEventListener('resize', resize);
  resize();

  // ==== ルート状態 ====
  let building = true;               // ルート生成モード ON/OFF
  const points = [];                 // [[x,y], ...]（交点のみ）
  let start = null;                  // [x,y] or null
  let goal  = null;                  // [x,y] or null

  // ==== UI ====
  const $ = (id) => document.getElementById(id);
  const toggleBtn = $('toggleBuild');
  const undoBtn   = $('undo');
  const clearBtn  = $('clear');
  const ptCountEl = $('ptCount');
  const sPosEl    = $('sPos');
  const gPosEl    = $('gPos');
  const toastEl   = $('toast');

  toggleBtn.addEventListener('click', () => {
    building = !building;
    toggleBtn.textContent = building ? 'ON' : 'OFF';
    drawAll();
  });

  undoBtn.addEventListener('click', () => {
    points.pop();
    drawAll();
  });

  clearBtn.addEventListener('click', () => {
    points.length = 0;
    start = goal = null;
    drawAll();
  });

  // ==== ユーティリティ ====
  function snapToGrid(clientX, clientY) {
    const r = map.getBoundingClientRect();
    const x = Math.round((clientX - r.left) / GRID) * GRID;
    const y = Math.round((clientY - r.top)  / GRID) * GRID;
    return [x, y];
  }

  function showToast(msg, ms = 1200) {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(() => toastEl.classList.remove('show'), ms);
  }

  function updateStatus() {
    ptCountEl.textContent = String(points.length);
    sPosEl.textContent = start ? `(${start[0]/GRID}m, ${start[1]/GRID}m)` : '-';
    gPosEl.textContent = goal  ? `(${goal[0]/GRID}m, ${goal[1]/GRID}m)` : '-';
  }

  // ==== 描画 ====
  function drawGrid() {
    ctx.clearRect(0, 0, map.width, map.height);
    ctx.strokeStyle = '#e6e6e6';
    ctx.lineWidth = 1;

    // 縦
    for (let x = 0; x <= map.width; x += GRID) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, map.height); ctx.stroke();
    }
    // 横
    for (let y = 0; y <= map.height; y += GRID) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5); ctx.lineTo(map.width, y + 0.5); ctx.stroke();
    }
  }

  // 直線 or 90度カーブ（対角禁止）
  function drawSegments() {
    if (points.length < 2) return;
    ctx.lineWidth = 2;
    ctx.strokeStyle = building ? '#ff9900' : '#0066cc';

    for (let i = 0; i < points.length - 1; i++) {
      const [x1, y1] = points[i];
      const [x2, y2] = points[i+1];

      const isDiagonal = (x1 !== x2 && y1 !== y2);
      if (isDiagonal) { 
        // 対角は禁止 → スキップ＆警告
        showToast('斜めは不可です（直線または直角のみ）');
        continue;
      }

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
  }

  function drawPointsAndMarks() {
    // ポイント
    points.forEach(([x,y]) => {
      ctx.fillStyle = '#22aa22';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
    });
    // S/G マーク
    ctx.fillStyle = '#000';
    ctx.font = 'bold 16px system-ui, sans-serif';
    if (start) ctx.fillText('S', start[0]-5, start[1]-8);
    if (goal)  ctx.fillText('G', goal[0]-5,  goal[1]-8);
  }

  function drawAll() {
    drawGrid();
    drawSegments();
    drawPointsAndMarks();
    updateStatus();
  }

  // ==== キャンバス操作 ====
  // クリック：ポイント追加（ルート生成 ON のときのみ）
  map.addEventListener('click', (e) => {
    if (!building) return;
    const [x,y] = snapToGrid(e.clientX, e.clientY);

    // 直前の点からの移動が斜めなら無視（最初の点はOK）
    if (points.length > 0) {
      const [px, py] = points[points.length-1];
      if (px !== x && py !== y) {
        showToast('斜めは不可です（直線または直角のみ）');
        return;
      }
    }
    points.push([x,y]);
    drawAll();
  });

  // ダブルクリック：S/G を交互に設定（交点のみ）
  map.addEventListener('dblclick', (e) => {
    const [x,y] = snapToGrid(e.clientX, e.clientY);
    // 交互：未設定→S、次→G、次→S… のトグル
    if (!start || (start && goal)) {
      start = [x,y];
      goal  = null; // Sを置き直したらGはリセット
    } else {
      // start があるときは G を置く
      goal = [x,y];
    }
    drawAll();
  });

  // Ctrl+Z：最後のポイント削除（簡易Undo）
  window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      points.pop();
      drawAll();
    }
  });

  // 初期表示
  drawAll();
})();
</script>
</body>
</html>
