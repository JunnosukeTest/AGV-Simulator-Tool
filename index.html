<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - Multi Route (R12: follow polyline, turn animated)</title>
<style>
  :root { --brand:#006666; --accent:#ff9900; --panel:#004d4d; --grid:#e6e6e6; }
  * { box-sizing:border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  body { margin:0; display:flex; height:100vh; overflow:hidden; }
  .sidebar { width:360px; flex-shrink:0; color:#fff; background:var(--brand); padding:12px 14px; display:flex; flex-direction:column; gap:12px; overflow-y:auto; }
  h1 { font-size:18px; margin:6px 0 8px; font-weight:700; }
  .section { background:var(--panel); border-radius:10px; padding:10px; }
  .row { display:flex; align-items:center; gap:8px; margin:6px 0; }
  .btn { cursor:pointer; border:none; border-radius:8px; padding:6px 8px; font-weight:700; font-size:13px; }
  .btn.primary { background:#fff; color:var(--brand); }
  .btn.ghost { background:transparent; border:1px solid #fff; color:#fff; }
  .note { font-size:12px; opacity:.9; }
  .status { background:#003d3d; padding:8px; border-radius:8px; font-size:13px; line-height:1.4; }
  canvas { flex:1; display:block; background:#fff; min-width:260px; }
  .routes-list { display:flex; flex-direction:column; gap:8px; }
  .route-item { background:#003c3c; border-radius:8px; padding:8px; display:grid; grid-template-columns: 1fr auto auto auto; gap:8px; align-items:center; }
  .route-name { font-weight:700; }
  .route-toggle { min-width:100px; }
  .toast { position:fixed; left:50%; top:18px; transform:translateX(-50%); background:#333; color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transition:opacity .2s ease; pointer-events:none; z-index:9; }
  .toast.show { opacity:.95; }
  .banner { position:fixed; left:0; right:0; top:0; padding:8px 12px; background:#c62828; color:#fff; font-weight:700; display:none; z-index:10; }
  .sim-btn { min-width:160px; }
  /* 車体テーブル（A〜J） */
  .vehicle-grid { display:grid; grid-template-columns: 56px 80px 80px 80px; gap:6px; align-items:center; }
  .vehicle-grid .head { font-weight:700; opacity:.9; }
  .vehicle-grid input { width:60px; padding:1px 3px; font-size:13px; }
  .summary-line { display:flex; justify-content:space-between; gap:8px; }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>AGV ルート作成（複数ルート対応）</h1>

    <div class="section">
      <div class="row"><strong>操作手順</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>ルートを <b>＋</b> で追加し、AGVを選択</li>
        <li>そのルートの <b>経路生成ON</b> を押す（ONのルートだけ編集可。再押しでOFF）</li>
        <li>キャンバスの交点をクリックでポイント追加（<b>水平・垂直のみ</b>）</li>
        <li>交点をダブルクリックで <b>S→G</b> を設定</li>
        <li>必要なら <b>S/G削除</b> で消して打ち直し</li>
      </ol>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ルート一覧</strong>
        <span class="note">（表示番号は小さい順の連番）</span>
      </div>
      <div id="routesList" class="routes-list"></div>
      <div class="row">
        <button id="addRoute" class="btn primary">＋ ルート追加</button>
        <button id="removeRoute" class="btn ghost">− 最後のルート削除</button>
      </div>
      <div class="row">
        <button id="exportBtn" class="btn ghost">JSON書き出し</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn ghost">JSON読み込み</button>
        <button id="exportHtmlBtn" class="btn ghost">HTML書き出し</button>
      </div>
    </div>

    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>車体一覧（A〜J）</strong>
        <span class="note">速度[m/s]・積み下ろし[s]・旋回[s]</span>
      </div>
      <div id="vehicles" class="vehicle-grid"></div>
    </div>

    <div class="section status">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ステータス（距離・KPI）</strong>
        <span class="note">1マス=1m / KPIはS→G距離ベース</span>
      </div>
      <div id="routesSummary" style="display:flex; flex-direction:column; gap:4px;"></div>
    </div>

    <div class="section">
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除（アクティブルート）</button>
      </div>
      <div class="row">
        <button id="clear" class="btn ghost">アクティブルート全消去</button>
      </div>
      <div class="row">
        <button id="simulateToggle" class="btn primary sim-btn">シミュレーション開始（ルート線上を往復）</button>
      </div>
      <div class="note">Ctrl+Z でも1つ戻せます</div>
    </div>
  </aside>

  <canvas id="map"></canvas>
  <div id="toast" class="toast"></div>
  <div id="banner" class="banner"></div>

<script defer>
(function(){
  var PX_PER_M = 40;   // 表示1マス=40px（論理1m）
  var GRID = PX_PER_M;
  var ROUTE_COLORS = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad','#16a085','#f39c12','#c0392b','#2980b9','#7f8c8d'];

  var canvas, ctx, toastEl;
  var routes = {};        // { id, agv, color, building, points:[], start:null, goal:null }
  var activeRouteId = null;
  var nextId = 1;         // 内部ID連番

  var vehicles = {};      // { 'A': {speed, load, turn}, ... }
  'ABCDEFGHIJ'.split('').forEach(function(ch){ vehicles[ch] = { speed:0.5, load:2, turn:2 }; });

  var simRunning = false;
  // ルート線に沿って往復：各ルートごとに状態を持つ（今回はアクティブのみ運転）
  // segIndex: 現在の節(A->BのA側index), forward: 進行方向, phase: move|dwell|turn など
  var sims = {}; // { routeId: {path:[], segIndex, forward, pixPerSec, lastTs, pos:{x,y}, heading, phase, dwellEnd, turnEnd, targetHeading, turnStartHeading, turnStartTime, turnDuration} }

  var routesListEl, addRouteBtn, removeRouteBtn, undoBtn, clearBtn, simulateBtn;
  var vehiclesEl, exportBtn, importBtn, importFile, routesSummaryEl, exportHtmlBtn;

  function showBanner(msg){ var b=document.getElementById('banner'); b.textContent=msg; b.style.display='block'; }
  function toast(msg){ if(!toastEl) return; toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(function(){toastEl.classList.remove('show');}, 1100); }
  function getOrderedIds(){ return Object.keys(routes).map(function(k){return parseInt(k,10);}).sort(function(a,b){return a-b;}); }
  function getDisplayIndex(id){ var ids=getOrderedIds(); var idx=ids.indexOf(id); return idx===-1? null : (idx+1); }

  // ルート（S→points→G）をクリーン化：重複点と斜めを排除
  function buildPath(r){
    if(!r) return [];
    var path = [];
    if(r.start) path.push({x:r.start[0], y:r.start[1]});
    for(var i=0;i<r.points.length;i++) path.push({x:r.points[i][0], y:r.points[i][1]});
    if(r.goal)  path.push({x:r.goal[0], y:r.goal[1]});
    var clean=[];
    for(var j=0;j<path.length;j++){
      if(!clean.length){ clean.push(path[j]); continue; }
      var a=clean[clean.length-1], b=path[j];
      if(a.x===b.x && a.y===b.y) continue;          // 同一点はスキップ
      if(a.x!==b.x && a.y!==b.y) continue;          // 斜め（ガード）
      clean.push(b);
    }
    return clean;
  }
  // ルート距離（参考）：クリーンパスの総マンハッタン距離[m]
  function pathDistanceInMeters(clean){
    if(clean.length<2) return 0;
    var px=0;
    for(var i=0;i<clean.length-1;i++){
      var A=clean[i], B=clean[i+1];
      px += Math.abs(B.x-A.x) + Math.abs(B.y-A.y);
    }
    return px / PX_PER_M;
  }
  // KPI用：S→Gのマンハッタン[m]
  function manhattanSGMeters(r){
    if(!r || !r.start || !r.goal) return 0;
    var dx = Math.abs(r.goal[0]-r.start[0]);
    var dy = Math.abs(r.goal[1]-r.start[1]);
    return (dx+dy) / PX_PER_M;
  }

  // KPI（S↔G距離ベースのまま）
  function computeCycleTimeSeconds(r){
    if(!r || !r.start || !r.goal) return null;
    var v = vehicles[r.agv] || {speed:0.5, load:2, turn:2};
    var dist = manhattanSGMeters(r);
    var travel = (2*dist) / Math.max(0.01, v.speed);
    var turnTime = 4 * Math.max(0, v.turn);   // 端点180°×2箇所
    var dwell = 2 * Math.max(0, v.load);      // SとG
    return travel + turnTime + dwell;
  }
  function renderKPI(){
    var ids=getOrderedIds(); routesSummaryEl.innerHTML='';
    if(!ids.length){ routesSummaryEl.textContent='ルート無し'; return; }
    ids.forEach(function(id){
      var r=routes[id]; var dispIdx=getDisplayIndex(id);
      var m=manhattanSGMeters(r);
      var cyc = computeCycleTimeSeconds(r);
      var perH = (cyc? 3600/cyc : 0);
      var line=document.createElement('div'); line.className='summary-line';
      line.innerHTML='<span>ルート'+dispIdx+'</span><span>距離: '+m.toFixed(1)+' m｜KPI: '+(perH?perH.toFixed(2):'−')+' 回/時</span>';
      routesSummaryEl.appendChild(line);
    });
  }

  function ready(){
    canvas = document.getElementById('map') || document.getElementById('mapCanvas');
    if(!canvas){ showBanner('Canvasが見つかりません（id="map" または "mapCanvas"）'); return; }
    ctx = canvas.getContext('2d');
    toastEl = document.getElementById('toast');

    routesListEl = document.getElementById('routesList');
    addRouteBtn = document.getElementById('addRoute');
    removeRouteBtn = document.getElementById('removeRoute');
    undoBtn = document.getElementById('undo');
    clearBtn = document.getElementById('clear');
    simulateBtn = document.getElementById('simulateToggle');
    vehiclesEl = document.getElementById('vehicles');
    exportBtn = document.getElementById('exportBtn');
    importBtn = document.getElementById('importBtn');
    importFile = document.getElementById('importFile');
    routesSummaryEl = document.getElementById('routesSummary');
    exportHtmlBtn = document.getElementById('exportHtmlBtn');

    addRouteBtn.addEventListener('click', addRoute);
    removeRouteBtn.addEventListener('click', removeLastRoute);
    undoBtn.addEventListener('click', undoPoint);
    clearBtn.addEventListener('click', clearActiveRoute);
    simulateBtn.addEventListener('click', onSimToggle);
    exportBtn.addEventListener('click', onExport);
    importBtn.addEventListener('click', function(){ importFile.click(); });
    importFile.addEventListener('change', onImport);
    if(exportHtmlBtn) exportHtmlBtn.addEventListener('click', onExportHtml);

    window.addEventListener('resize', function(){ resize(); drawAll(); });
    canvas.addEventListener('click', onCanvasClick, {passive:true});
    canvas.addEventListener('dblclick', onCanvasDblClick, {passive:false});
    window.addEventListener('keydown', onKey);

    resize();
    addRoute();
    setActiveRoute(activeRouteId);
    renderVehiclesUI();
    drawAll();
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', ready); else ready();

  function resize(){
    var sidebar = document.querySelector('.sidebar');
    var sw = sidebar ? sidebar.offsetWidth : 360;
    var w = Math.max(260, window.innerWidth - sw);
    canvas.width = w; canvas.height = window.innerHeight;
  }
  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#e6e6e6'; ctx.lineWidth = 1;
    for(var x=0; x<=canvas.width; x+=GRID){ ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,canvas.height); ctx.stroke(); }
    for(var y=0; y<=canvas.height; y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y+.5); ctx.lineTo(canvas.width,y+.5); ctx.stroke(); }
  }
  function drawRoutes(){
    var ids = getOrderedIds();
    ids.forEach(function(id){
      var r = routes[id];
      var dispIdx = getDisplayIndex(id);
      // ルート線
      var path = buildPath(r);
      if(path.length>=2){
        ctx.lineWidth = 2; ctx.strokeStyle = r.color;
        for(var i=0;i<path.length-1;i++){
          var A=path[i], B=path[i+1];
          ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
        }
      }
      // 途中ポイント
      for(var j=0;j<r.points.length;j++){
        var p=r.points[j]; ctx.fillStyle=r.color; ctx.beginPath(); ctx.arc(p[0],p[1],4,0,Math.PI*2); ctx.fill();
      }
      // S/Gラベル
      ctx.fillStyle = '#000'; ctx.font='bold 16px system-ui, sans-serif';
      if(r.start) ctx.fillText('S'+dispIdx, r.start[0]-10, r.start[1]-8);
      if(r.goal)  ctx.fillText('G'+dispIdx, r.goal[0]-10,  r.goal[1]-8);
    });
  }
  function drawAGVs(){
    if(!simRunning) return;
    Object.keys(sims).forEach(function(idStr){
      var id = +idStr; var r = routes[id]; var s = sims[idStr];
      if(!r || !s) return;
      var L = 18, W = 10; // 本体サイズ(px)
      var rad = (s.heading||0) * Math.PI/180;
      ctx.save();
      ctx.translate(s.pos.x, s.pos.y);
      ctx.rotate(rad);
      ctx.fillStyle = r.color; ctx.fillRect(-L/2, -W/2, L, W);
      ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(L/2, 0); ctx.lineTo(L/2-4, -3); ctx.lineTo(L/2-4, 3); ctx.closePath(); ctx.fill();
      ctx.restore();
    });
  }
  function drawAll(){ drawGrid(); drawRoutes(); drawAGVs(); renderKPI(); }

  function addRoute(){
    var id = nextId++;
    var color = ROUTE_COLORS[(id-1)%ROUTE_COLORS.length];
    routes[id] = { id:id, agv:'A', color:color, building:false, points:[], start:null, goal:null };
    activeRouteId = id;
    renderRoutesUI(); drawAll();
  }
  function removeLastRoute(){
    var ids = getOrderedIds(); if(!ids.length) return;
    var lastId = ids[ids.length-1];
    delete routes[lastId];
    if(activeRouteId === lastId){ ids = getOrderedIds(); activeRouteId = ids.length ? ids[ids.length-1] : null; }
    if(simRunning && sims[lastId]){ delete sims[lastId]; checkSimEnd(); }
    renderRoutesUI(); drawAll();
  }
  function setActiveRoute(id){
    if(id==null){ var ids=getOrderedIds(); activeRouteId = ids.length ? ids[0] : null; }
    else { activeRouteId=id; }
    drawAll();
  }
  function setRouteAGV(id, agv){ if(routes[id]) routes[id].agv = agv; drawAll(); }
  function toggleRouteBuilding(id){
    if(!routes[id]) return;
    var wasOn = !!routes[id].building;
    Object.keys(routes).forEach(function(k){ routes[k].building = false; });
    routes[id].building = !wasOn; activeRouteId = id;
    renderRoutesUI(); drawAll();
  }

  function renderRoutesUI(){
    routesListEl.innerHTML = '';
    var ids = getOrderedIds();
    ids.forEach(function(id){
      var r = routes[id];
      var dispIdx = getDisplayIndex(id);
      var item = document.createElement('div'); item.className = 'route-item';

      var name = document.createElement('div'); name.className='route-name'; name.textContent = 'ルート'+dispIdx+' ';
      var chip = document.createElement('span'); chip.style.display='inline-block'; chip.style.width='10px'; chip.style.height='10px'; chip.style.borderRadius='999px'; chip.style.background=r.color; chip.style.marginLeft='6px'; name.appendChild(chip);

      var sel = document.createElement('select');
      'ABCDEFGHIJ'.split('').forEach(function(ch){ var opt=document.createElement('option'); opt.value=ch; opt.textContent=ch; if(ch===r.agv) opt.selected=true; sel.appendChild(opt); });
      sel.addEventListener('change', function(e){ e.stopPropagation(); setRouteAGV(id, this.value); });

      var btn = document.createElement('button'); btn.className='btn route-toggle';
      btn.textContent = r.building? '経路生成ON':'経路生成OFF';
      btn.style.background = r.building? '#fff':'透明';
      btn.style.color = r.building? '#006666':'#fff';
      btn.addEventListener('click', function(e){ e.stopPropagation(); toggleRouteBuilding(id); });

      var sgBtn = document.createElement('button'); sgBtn.className='btn ghost'; sgBtn.textContent='S/G削除';
      sgBtn.addEventListener('click', function(e){ e.stopPropagation(); if(routes[id]){ routes[id].start=null; routes[id].goal=null; drawAll(); } });

      item.addEventListener('click', function(){ setActiveRoute(id); });

      item.appendChild(name); item.appendChild(sel); item.appendChild(btn); item.appendChild(sgBtn);
      routesListEl.appendChild(item);
    });
  }
  function renderVehiclesUI(){
    var v = vehicles, html='';
    html += '<div></div><div class="head">速度[m/s]</div><div class="head">積み下ろし[s]</div><div class="head">旋回[s]</div>';
    'ABCDEFGHIJ'.split('').forEach(function(ch){
      html += '<div><strong>'+ch+'</strong></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="speed" type="number" step="0.1" value="'+v[ch].speed+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="load"  type="number" step="0.1" value="'+v[ch].load+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="turn"  type="number" step="0.1" value="'+v[ch].turn+'"></div>';
    });
    vehiclesEl.innerHTML = html;
    vehiclesEl.querySelectorAll('input').forEach(function(inp){ inp.addEventListener('change', function(){ var k=this.getAttribute('data-vkey'); var f=this.getAttribute('data-field'); var val=parseFloat(this.value); if(!isFinite(val)) return; vehicles[k][f]=val; }); });
  }

  function snapToGrid(clientX, clientY){ var r=canvas.getBoundingClientRect(); var x=Math.round((clientX-r.left)/GRID)*GRID; var y=Math.round((clientY-r.top)/GRID)*GRID; return [x,y]; }
  function onCanvasClick(e){ var r=routes[activeRouteId]; if(!r){ toast('ルートを選択'); return; } if(!r.building){ toast('編集するルートで「経路生成ON」を押してください'); return; } var xy=snapToGrid(e.clientX,e.clientY); if(r.points.length>0){ var last=r.points[r.points.length-1]; if(last[0]===xy[0] && last[1]===xy[1]){ return; } if(last[0]!==xy[0] && last[1]!==xy[1]){ toast('斜めは不可'); return; } } r.points.push(xy); drawAll(); }
  function onCanvasDblClick(e){ var r=routes[activeRouteId]; if(!r) return; e.preventDefault(); var xy=snapToGrid(e.clientX,e.clientY); if(!r.start){ r.start=xy; } else if(r.start && !r.goal){ r.goal=xy; } drawAll(); }
  function onKey(e){ if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ undoPoint(); } }
  function undoPoint(){ var r=routes[activeRouteId]; if(!r) return; r.points.pop(); drawAll(); }
  function clearActiveRoute(){ var r=routes[activeRouteId]; if(!r) return; r.points.length=0; r.start=null; r.goal=null; drawAll(); }

  function onExport(){ var data={ routes: routes, vehicles: vehicles, meta:{ pxPerM:PX_PER_M, ts:Date.now() } }; var blob=new Blob([JSON.stringify(data,null,2)], {type:'application/json'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='agv_routes.json'; a.click(); URL.revokeObjectURL(a.href); }
  function onImport(evt){ var file=evt.target.files && evt.target.files[0]; if(!file) return; var reader=new FileReader(); reader.onload=function(){ try{ var obj=JSON.parse(reader.result); if(obj.vehicles) vehicles=obj.vehicles; if(obj.routes){ routes={}; Object.keys(obj.routes).forEach(function(k){ routes[+k]=obj.routes[k]; }); } nextId=(Math.max(0, ...Object.keys(routes).map(function(k){return +k;})) || 0)+1; renderVehiclesUI(); renderRoutesUI(); setActiveRoute(null); drawAll(); toast('JSONを読み込みました'); }catch(err){ toast('読み込みエラー: '+err.message); } }; reader.readAsText(file); }
  function onExportHtml(){ try{ var html='<!DOCTYPE html>'+document.documentElement.outerHTML; var blob=new Blob([html], {type:'text/html'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='agv_simulator.html'; a.click(); URL.revokeObjectURL(a.href); toast('HTMLを書き出しました'); }catch(e){ toast('HTML書き出しでエラー: '+e.message); } }

  // 向き/回転ユーティリティ
  function headingOf(A,B){ if(B.x>A.x) return 0; if(B.x<A.x) return 180; if(B.y>A.y) return 90; if(B.y<A.y) return -90; return 0; }
  function angleDelta(a,b){ var d=((b-a+540)%360)-180; return Math.round(d); }
  function lerpAngle(a,b,t){ var d = angleDelta(a,b); return a + d * t; }

  function onSimToggle(){
    if(simRunning){
      simRunning=false; sims={}; simulateBtn.textContent='シミュレーション開始（ルート線上を往復）'; drawAll(); return;
    }
    // アクティブルートのみ作動
    sims = {};
    var id = activeRouteId;
    var r = routes[id];
    if(!r || !r.start || !r.goal){ toast('アクティブルートにS/Gを設定してください'); return; }
    var clean = buildPath(r);
    if(clean.length < 2){ toast('SとGを含めて2点以上のルートを作成してください'); return; }

    var agv=r.agv; var speed=vehicles[agv]?vehicles[agv].speed:0.5;
    var heading0=headingOf(clean[0], clean[1]);
    sims[id] = {
      path: clean,
      segIndex: 0,              // 現在A=path[segIndex] → B=path[segIndex+1]へ
      forward: true,            // 終端で反転
      pixPerSec: speed*PX_PER_M,
      lastTs: performance.now(),
      pos: {x: clean[0].x, y: clean[0].y},
      heading: heading0,
      phase: 'move',            // move | dwell | turn
      dwellEnd: null,
      turnEnd: null,
      targetHeading: null,
      turnStartHeading: null,
      turnStartTime: null,
      turnDuration: null
    };
    simRunning = true;
    simulateBtn.textContent='シミュレーション停止';
    requestAnimationFrame(stepSimAll);
  }

  function stepSimAll(ts){
    if(!simRunning) return;

    var id = activeRouteId;
    var r = routes[id];
    var s = sims[id];
    if(!r || !s){ simRunning=false; simulateBtn.textContent='シミュレーション開始（ルート線上を往復）'; return; }

    var agv=r.agv;
    var turnS=(vehicles[agv] && +vehicles[agv].turn)||0;
    var loadS=(vehicles[agv] && +vehicles[agv].load)||0;

    var now = ts;
    var dt = (now - s.lastTs)/1000;
    s.lastTs = now;

    // Dwell（端点での積み下ろし）
    if(s.phase==='dwell'){
      if(now < s.dwellEnd){ drawAll(); return requestAnimationFrame(stepSimAll); }
      // dwell完了 → 180°反転
      s.phase='turn';
      s.targetHeading = ((s.heading + 180) % 360 + 360) % 360;
      s.turnStartHeading = s.heading;
      s.turnStartTime = now;
      s.turnDuration = (2*turnS)*1000;
      s.turnEnd = now + (2*turnS)*1000;
      drawAll(); return requestAnimationFrame(stepSimAll);
    }

    // Turn（曲がり/反転の向き合わせ）
    if(s.phase==='turn'){
      if(now < s.turnEnd){
        var total=s.turnDuration || (turnS*1000);
        var ratio=Math.max(0, Math.min(1, (now - s.turnStartTime)/total));
        s.heading=lerpAngle(s.turnStartHeading, s.targetHeading, ratio);
        drawAll(); return requestAnimationFrame(stepSimAll);
      }
      // 回転完了
      s.heading = s.targetHeading;
      s.turnEnd=null; s.targetHeading=null;
      s.turnDuration=null; s.turnStartHeading=null; s.turnStartTime=null;

      // 反転後 or 角での向き合わせ後 → 走行再開
      s.phase='move';
    }

    // Move（線分に沿って移動）
    var path = s.path;
    var aIdx = s.segIndex;
    var bIdx = s.forward ? aIdx+1 : aIdx-1;

    // 終端処理
    if(bIdx < 0 || bIdx >= path.length){
      // 折り返し：積み下ろし → 反転へ
      s.forward = !s.forward;
      if(loadS>0){ s.phase='dwell'; s.dwellEnd = now + loadS*1000; drawAll(); return requestAnimationFrame(stepSimAll); }
      // 反転だけ必要
      var newA = s.segIndex;
      var newB = s.forward ? newA+1 : newA-1;
      if(newB>=0 && newB<path.length){
        var newHeading=headingOf(path[newA], path[newB]);
        var delta=Math.abs(angleDelta(s.heading, newHeading));
        var tms=((delta===180)? (2*turnS) : turnS)*1000;
        if(delta!==0 && turnS>0){
          s.phase='turn';
          s.targetHeading=newHeading;
          s.turnStartHeading=s.heading;
          s.turnStartTime=now;
          s.turnDuration=tms;
          s.turnEnd=now + tms;
          drawAll(); return requestAnimationFrame(stepSimAll);
        } else { s.heading=newHeading; }
      }
    }

    // ここまで来て bIdx が妥当でなければ継続
    if(bIdx < 0 || bIdx >= path.length){ drawAll(); return requestAnimationFrame(stepSimAll); }

    var A = path[aIdx], B = path[bIdx];

    // 線分方向に向き合わせ（90°なら turnS 秒）
    var desiredHeading=headingOf(A,B);
    var d = Math.abs(angleDelta(s.heading, desiredHeading));
    if(d!==0 && turnS>0){
      var tms2=((d===180)? (2*turnS):turnS)*1000;
      s.phase='turn';
      s.targetHeading=desiredHeading;
      s.turnStartHeading=s.heading;
      s.turnStartTime=now;
      s.turnDuration=tms2;
      s.turnEnd=now + tms2;
      drawAll(); return requestAnimationFrame(stepSimAll);
    }else{
      s.heading=desiredHeading;
    }

    // 平行移動
    var move = s.pixPerSec * dt;
    if(A.x!==B.x){
      var dirx=Math.sign(B.x-s.pos.x);
      var remain=Math.abs(B.x-s.pos.x);
      if(move>=remain){ s.pos.x=B.x; s.pos.y=B.y; s.segIndex=bIdx; }
      else { s.pos.x += dirx*move; }
    } else {
      var diry=Math.sign(B.y-s.pos.y);
      var remainy=Math.abs(B.y-s.pos.y);
      if(move>=remainy){ s.pos.x=B.x; s.pos.y=B.y; s.segIndex=bIdx; }
      else { s.pos.y += diry*move; }
    }

    // 次の角に到達したら、次線分の方向に合わせる（次フレームでTurnへ入る）
    if(s.pos.x===B.x && s.pos.y===B.y){
      var nextA=s.segIndex, nextB=s.forward ? nextA+1 : nextA-1;
      if(nextB<0 || nextB>=path.length){
        // 端点：この後 dwell → 180°反転へ（次ループ先頭で処理）
      } else {
        var nextHeading=headingOf(path[nextA], path[nextB]);
        var d2=Math.abs(angleDelta(s.heading, nextHeading));
        var tms3=((d2===180)? (2*turnS):turnS)*1000;
        if(d2!==0 && turnS>0){
          s.phase='turn';
          s.targetHeading=nextHeading;
          s.turnStartHeading=s.heading;
          s.turnStartTime=now;
          s.turnDuration=tms3;
          s.turnEnd=now + tms3;
          drawAll(); return requestAnimationFrame(stepSimAll);
        }
      }
    }

    drawAll();
    requestAnimationFrame(stepSimAll);
  }

  function checkSimEnd(){ if(!simRunning) return; var id=activeRouteId; var s=sims[id]; if(!s){ simRunning=false; simulateBtn.textContent='シミュレーション開始（ルート線上を往復）'; } }
})();
</script>
</body>
</html>
