<!DOCTYPE html><html lang="ja"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AGV Simulator (Lite)</title>
<style>
:root{--brand:#066;--panel:#044;--grid:#e6e6e6}
*{box-sizing:border-box;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"ヒラギノ角ゴ ProN","Meiryo",sans-serif}
body{margin:0;display:flex;height:100vh;overflow:hidden}
.aside{width:360px;flex-shrink:0;background:var(--brand);color:#fff;padding:12px;display:flex;flex-direction:column;gap:10px;overflow:auto}
h1{font-size:18px;margin:0 0 6px}
.sec{background:var(--panel);border-radius:10px;padding:10px}
.row{display:flex;gap:8px;align-items:center;margin:6px 0}
.btn{cursor:pointer;border:none;border-radius:8px;padding:8px 10px;font-weight:700}
.btn.p{background:#fff;color:#066}.btn.g{background:transparent;border:1px solid #fff;color:#fff}
.note{font-size:12px;opacity:.9}canvas{flex:1;display:block;background:#fff;min-width:260px}
.list{display:flex;flex-direction:column;gap:8px}
.item{background:#033;border-radius:8px;padding:8px;display:grid;grid-template-columns:1fr auto auto auto;gap:8px;align-items:center}
.name{font-weight:700}.tog{min-width:110px}.pill{padding:2px 8px;border-radius:999px;font-size:12px;color:#fff;margin-left:6px}
.toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:#333;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .2s;pointer-events:none}
.toast.show{opacity:.95}
.grid4{display:grid;grid-template-columns:56px 1fr 1fr 1fr;gap:6px;align-items:center}
.head{font-weight:700;opacity:.9}
</style></head><body>
<aside class="aside">
  <h1>AGVルート（A–E）</h1>

  <div class="sec">
    <div class="row"><b>使い方</b></div>
    <ol class="note" style="margin:6px 0 0 18px">
      <li>「＋」でルート追加→AGV(A–E)選択</li>
      <li>その行の<b>経路ON</b>で編集開始（再押しでOFF）</li>
      <li>交点クリック＝ポイント（水平/垂直のみ）</li>
      <li>交点ダブルクリック＝<b>S→G</b>を1回だけ設定（やり直しはS/G削除）</li>
    </ol>
    <div class="note">グリッドは<b>1m/マス</b>（表示40px）</div>
  </div>

  <div class="sec">
    <div class="row" style="justify-content:space-between"><b>ルート一覧</b><span class="note">番号は小さい順</span></div>
    <div id="routes" class="list"></div>
    <div class="row"><button id="add" class="btn p">＋ ルート</button><button id="del" class="btn g">− 最後を削除</button></div>
  </div>

  <div class="sec">
    <div class="row" style="justify-content:space-between"><b>車体パラメータ A–E</b><span class="note">速度[m/s]・積み下ろし[s]・旋回[s]</span></div>
    <div id="veh" class="grid4"></div>
  </div>

  <div class="sec">
    <div>アクティブ: <span id="act">-</span></div>
    <div>S→G距離: <span id="dist">-</span></div>
  </div>

  <div class="sec">
    <div class="row"><button id="undo" class="btn g">最後のポイント削除</button></div>
    <div class="row"><button id="clear" class="btn g">アクティブルート全消去</button></div>
    <div class="row"><button id="sim" class="btn p">シミュレーション開始</button></div>
    <div class="note">Ctrl+Zでも1つ戻す</div>
  </div>
</aside>

<canvas id="cv"></canvas>
<div id="toast" class="toast"></div>

<script>
(function(){
  // === settings ===
  var PX = 40; // 1m=40px
  var CV = document.getElementById('cv'), CTX = CV.getContext('2d');
  var colors = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad']; // A–E

  // === state ===
  var routes = {}; // {id,agv,color,on,pts:[[x,y],...],s:[x,y]|null,g:[x,y]|null}
  var nextId=1, active=null;
  var veh = {}; 'ABCDE'.split('').forEach(ch=>veh[ch]={speed:0.5,load:2,turn:2});
  var simRun=false, sim={rid:null,path:[],i:0,pos:{x:0,y:0},pps:0,last:0,state:'idle',wait:0,dir:null};

  // === dom ===
  var $ = id=>document.getElementById(id);
  var R=$('routes'), A=$('add'), D=$('del'), U=$('undo'), C=$('clear'), S=$('sim'), V=$('veh'), ACT=$('act'), DST=$('dist'), T=$('toast');

  // === utils ===
  function toast(msg){T.textContent=msg;T.classList.add('show');setTimeout(()=>T.classList.remove('show'),900)}
  function ids(){return Object.keys(routes).map(k=>+k).sort((a,b)=>a-b)}
  function dispIndex(id){let a=ids();return a.indexOf(id)+1}
  function snap(x,y){let r=CV.getBoundingClientRect();return [Math.round((x-r.left)/PX)*PX,Math.round((y-r.top)/PX)*PX]}
  function distanceMeters(r){
    if(!r.s||!r.g)return null;
    let p=[{x:r.s[0],y:r.s[1]},...r.pts.map(p=>({x:p[0],y:p[1]})),{x:r.g[0],y:r.g[1]}], c=[p[0]];
    for(let i=1;i<p.length;i++){let a=c[c.length-1],b=p[i]; if(a.x!==b.x&&a.y!==b.y)continue; c.push(b)}
    if(c.length<2)return null;
    let pix=0; for(let i=0;i<c.length-1;i++) pix+=Math.abs(c[i+1].x-c[i].x)+Math.abs(c[i+1].y-c[i].y);
    return pix/PX
  }
  function status(){ 
    if(!active){ACT.textContent='-';DST.textContent='-';return}
    let r=routes[active]; ACT.textContent='ルート'+dispIndex(active)+' / AGV '+r.agv+(r.on?' / 編集ON':' / 編集OFF');
    let d=distanceMeters(r); DST.textContent=d==null?'-':d.toFixed(2)+' m'
  }

  // === layout & draw ===
  function resize(){ let w=Math.max(260,window.innerWidth-360); CV.width=w; CV.height=window.innerHeight; }
  function grid(){
    CTX.clearRect(0,0,CV.width,CV.height);
    CTX.strokeStyle='#e6e6e6'; CTX.lineWidth=1;
    for(let x=0;x<=CV.width;x+=PX){CTX.beginPath();CTX.moveTo(x+.5,0);CTX.lineTo(x+.5,CV.height);CTX.stroke()}
    for(let y=0;y<=CV.height;y+=PX){CTX.beginPath();CTX.moveTo(0,y+.5);CTX.lineTo(CV.width,y+.5);CTX.stroke()}
  }
  function draw(){
    grid();
    for(let id of ids()){
      let r=routes[id], idx=dispIndex(id);
      // lines
      if(r.pts.length>=2){
        CTX.lineWidth=2; CTX.strokeStyle=r.color;
        for(let i=0;i<r.pts.length-1;i++){
          let a=r.pts[i], b=r.pts[i+1];
          if(a[0]!==b[0] && a[1]!==b[1]) continue;
          CTX.beginPath(); CTX.moveTo(a[0],a[1]); CTX.lineTo(b[0],b[1]); CTX.stroke();
        }
      }
      // points
      CTX.fillStyle=r.color; CTX.strokeStyle='#ffffffaa'; CTX.lineWidth=1;
      for(let p of r.pts){ CTX.beginPath(); CTX.arc(p[0],p[1],4,0,Math.PI*2); CTX.fill(); CTX.beginPath(); CTX.arc(p[0],p[1],4.8,0,Math.PI*2); CTX.stroke(); }
      // S/G labels
      if(r.s){ CTX.fillStyle='#000'; CTX.font='bold 14px system-ui'; CTX.textAlign='center'; CTX.textBaseline='bottom'; CTX.fillText('S'+idx, r.s[0], r.s[1]-6); }
      if(r.g){ CTX.fillStyle='#000'; CTX.font='bold 14px system-ui'; CTX.textAlign='center'; CTX.textBaseline='bottom'; CTX.fillText('G'+idx, r.g[0], r.g[1]-6); }
    }
    // agv icon
    if(simRun){
      let r=routes[sim.rid], size=PX*0.9;
      CTX.fillStyle=r.color; CTX.fillRect(sim.pos.x-size/2,sim.pos.y-size/2,size,size);
      CTX.fillStyle='#fff'; CTX.font='bold '+Math.floor(size*0.5)+'px system-ui'; CTX.textAlign='center'; CTX.textBaseline='middle';
      CTX.fillText(r.agv, sim.pos.x, sim.pos.y+1);
    }
    status();
  }

  // === route UI ===
  function renderRoutes(){
    R.innerHTML='';
    for(let id of ids()){
      let r=routes[id], idx=dispIndex(id);
      let it=document.createElement('div'); it.className='item';
      let name=document.createElement('div'); name.className='name'; name.textContent='ルート'+idx+' ';
      let pill=document.createElement('span'); pill.className='pill'; pill.style.background=r.color; pill.textContent=r.agv; name.appendChild(pill);

      let sel=document.createElement('select');
      'ABCDE'.split('').forEach(ch=>{let o=document.createElement('option'); o.value=ch;o.textContent=ch;if(ch===r.agv)o.selected=true; sel.appendChild(o)});
      sel.addEventListener('change',e=>{r.agv=sel.value; renderRoutes()});

      let tog=document.createElement('button'); tog.className='btn tog'; tog.textContent=r.on?'経路ON':'経路OFF';
      tog.style.background=r.on?'#fff':'transparent'; tog.style.color=r.on?'#066':'#fff';
      tog.addEventListener('click',e=>{ let was=r.on; Object.values(routes).forEach(x=>x.on=false); r.on=!was; active=id; renderRoutes(); draw(); });

      let sg=document.createElement('button'); sg.className='btn g'; sg.textContent='S/G削除';
      sg.addEventListener('click',e=>{r.s=null;r.g=null;draw()});

      it.addEventListener('click',()=>{active=id; draw()});
      it.appendChild(name); it.appendChild(sel); it.appendChild(tog); it.appendChild(sg);
      R.appendChild(it);
    }
  }

  function renderVeh(){
    let h='<div></div><div class="head">速度</div><div class="head">積下</div><div class="head">旋回</div>';
    'ABCDE'.split('').forEach(ch=>{
      let v=veh[ch];
      h+=`<div><b>${ch}</b></div>
          <div><input data-k="${ch}" data-f="speed" type="number" step="0.1" value="${v.speed}" style="width:90%"></div>
          <div><input data-k="${ch}" data-f="load"  type="number" step="0.1" value="${v.load}"  style="width:90%"></div>
          <div><input data-k="${ch}" data-f="turn"  type="number" step="0.1" value="${v.turn}"  style="width:90%"></div>`;
    });
    V.innerHTML=h;
    V.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('change',()=>{ let k=inp.dataset.k,f=inp.dataset.f,val=parseFloat(inp.value); if(isFinite(val)) veh[k][f]=val; });
    });
  }

  // === events ===
  function addRoute(){
    let id=nextId++, color=colors[(id-1)%colors.length];
    routes[id]={id,agv:'A',color,on:false,pts:[],s:null,g:null}; active=id; renderRoutes(); draw();
  }
  function delRoute(){
    let a=ids(); if(!a.length) return; let last=a[a.length-1]; delete routes[last];
    if(active===last){a=ids(); active=a.length?a[a.length-1]:null} renderRoutes(); draw();
  }
  function onClick(e){
    let r=routes[active]; if(!r||!r.on) return;
    let p=snap(e.clientX,e.clientY);
    if(r.pts.length){ let L=r.pts[r.pts.length-1]; if(L[0]!==p[0]&&L[1]!==p[1]){toast('斜めは不可');return} }
    r.pts.push(p); draw();
  }
  function onDbl(e){
    let r=routes[active]; if(!r) return; e.preventDefault();
    let p=snap(e.clientX,e.clientY);
    if(!r.s){ r.s=p; toast('S設定'); }
    else if(!r.g){ r.g=p; toast('G設定'); }
    else{ toast('S/G済。S/G削除でやり直し'); }
    draw();
  }
  function undo(){ let r=routes[active]; if(!r) return; r.pts.pop(); draw(); }
  function clear(){ let r=routes[active]; if(!r) return; r.pts.length=0; r.s=null; r.g=null; draw(); }

  // === simulation ===
  function buildPath(r){
    if(!r.s||!r.g) return null;
    let raw=[{x:r.s[0],
