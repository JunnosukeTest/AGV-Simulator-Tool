<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - Job連結 / KPI / 画像レイヤ(貼り付け) 最終版</title>
<style>
  :root{
    --brand:#006666; --panel:#004d4d; --panelThin:#003c3c;
    --grid:#e6e6e6;
    --scrollTrack:#e0e5e5; --scrollThumb:#ffffff;
    --danger:#c62828; --ok:#00c853;
  }
  *{ box-sizing:border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  html,body{ height:100%; }
  body{ margin:0; display:flex; height:100vh; overflow:hidden; background:#fff; }

  /* ==== サイドバー ==== */
  .sidebar{
    width:520px; flex-shrink:0; color:#fff; background:var(--brand);
    padding:12px 14px; display:flex; flex-direction:column; gap:12px;
    overflow-y:auto; overflow-x:hidden;
  }
  h1{ font-size:18px; margin:6px 0 8px; font-weight:800; }
  .section{ background:var(--panel); border-radius:10px; padding:10px; }
  .row{ display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap; }
  .btn{ cursor:pointer; border:none; border-radius:8px; padding:6px 8px; font-weight:800; font-size:13px; }
  .btn.primary{ background:#fff; color:var(--brand); }
  .btn.ghost{ background:transparent; border:1px solid #fff; color:#fff; }
  .btn.slim{ padding:4px 8px; font-size:12px; border-radius:8px; }
  .note{ font-size:12px; opacity:.92; }
  .small{ font-size:12px; }

  /* ==== キャンバス ==== */
  .canvas-wrap{ position:relative; flex:1; background:#fff; min-width:260px; }
  canvas#map{ position:absolute; inset:0; width:100%; height:100%; display:block; }

  /* オーバーレイUI */
  .canvas-ui{ position:absolute; display:flex; align-items:center; gap:8px; }
  .ui-top-right{ top:8px; right:8px; background:rgba(0,0,0,.55); color:#fff; padding:6px 8px; border-radius:10px; z-index:6; }
  .ui-bottom-left{ left:8px; bottom:28px; background:rgba(0,0,0,.55); color:#fff; padding:4px 8px; border-radius:8px; font-size:12px; pointer-events:none; z-index:6; }
  .speed-btn{ cursor:pointer; border:none; width:28px; height:28px; border-radius:8px; background:#fff; color:#333; font-weight:900; display:grid; place-items:center; }
  .speed-label{ min-width:44px; text-align:center; font-weight:800; }

  /* ルート一覧 */
  .routes-list{ display:flex; flex-direction:column; gap:8px; }
  .route-item{
    background:var(--panelThin); border-radius:10px; padding:8px;
    display:grid;
    grid-template-columns: 1.1fr 64px 92px 92px 92px 110px;
    gap:8px; align-items:center;
  }
  .route-name{ font-weight:800; white-space:nowrap; }
  .route-toggle{ min-width:100px; }
  .mini-input{
    width:100%; padding:4px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.25);
    background:rgba(0,0,0,.12); color:#fff; font-weight:700; font-size:12px;
  }
  .mini-label{ font-size:11px; opacity:.9; margin-bottom:2px; }
  .mini-cell{ display:flex; flex-direction:column; gap:2px; }
  .mini-btn{ padding:5px 8px; font-size:12px; border-radius:8px; font-weight:800; }
  .mini-btn.ghost{ background:transparent; border:1px solid #fff; color:#fff; }

  /* Job一覧 */
  .jobs-list{ display:flex; flex-direction:column; gap:8px; }
  .job-item{
    background:var(--panelThin); border-radius:10px; padding:8px;
    display:grid;
    grid-template-columns: 1fr 1fr 90px 90px;
    gap:8px; align-items:center;
  }
  .job-title{ font-weight:900; }
  .job-routes{ font-size:12px; opacity:.95; }
  .job-select{
    width:100%; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.25);
    background:rgba(0,0,0,.12); color:#fff; font-weight:800; font-size:12px;
  }

  /* 車体 */
  .vehicle-grid{
    display:grid;
    grid-template-columns: 56px 86px 86px 86px;
    gap:6px; align-items:center; justify-items:start;
  }
  .vehicle-grid .head{ font-weight:800; opacity:.9; }
  .vehicle-grid input{ width:76px; padding:3px 5px; font-size:12px; border-radius:8px; border:1px solid rgba(255,255,255,.25); background:rgba(0,0,0,.12); color:#fff; font-weight:800; }

  /* ステータス */
  .status{ background:#003d3d; padding:10px; border-radius:10px; font-size:13px; line-height:1.5; }
  .summary-line{ display:flex; justify-content:space-between; gap:8px; }
  .kpi-block{ margin-top:8px; display:flex; flex-direction:column; gap:6px; }
  .kpi-card{
    background:rgba(0,0,0,.12); border:1px solid rgba(255,255,255,.12);
    border-radius:10px; padding:8px;
  }
  .kpi-head{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .kpi-head strong{ font-weight:900; }
  .kpi-sub{ font-size:12px; opacity:.92; }
  .kpi-metrics{ margin-top:6px; display:flex; flex-direction:column; gap:4px; }
  .bar-wrap{
    margin-top:6px; background:rgba(255,255,255,.12);
    border-radius:999px; height:10px; overflow:hidden;
    border:1px solid rgba(255,255,255,.12);
  }
  .bar-fill{ height:100%; width:0%; background:#fff; }
  .ratio-row{ display:flex; gap:6px; flex-wrap:wrap; font-size:12px; opacity:.95; }
  .pill{
    padding:2px 8px; border-radius:999px;
    background:rgba(255,255,255,.12);
    border:1px solid rgba(255,255,255,.12);
    font-weight:800;
  }

  /* 画像レイヤ */
  .img-controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .img-list{ display:flex; flex-direction:column; gap:6px; margin-top:8px; }
  .img-item{
    background:var(--panelThin); border-radius:10px; padding:6px 8px;
    display:grid; grid-template-columns: 1fr 110px 74px; gap:8px; align-items:center;
  }
  .slider-row{ margin-top:8px; display:flex; align-items:center; gap:8px; }
  .slider-row input[type="range"]{ flex:1; }

  /* ==== キャンバス用 スクロールバー風スライダー ==== */
  .pan-slider-x,.pan-slider-y{ position:absolute; z-index:7; background:transparent; pointer-events:auto; }
  .pan-slider-x{ left:8px; right:28px; bottom:6px; height:14px; }
  .pan-slider-y{ top:8px; bottom:28px; right:8px; width:14px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]{
    -webkit-appearance:none; appearance:none; width:100%; height:14px; margin:0; background:transparent; outline:none;
  }
  .pan-slider-x input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:14px; height:14px; margin-top:-4px;
    border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15);
    box-shadow:0 1px 1px rgba(0,0,0,.05); cursor:pointer;
  }
  .pan-slider-x input[type="range"]::-moz-range-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]::-moz-range-thumb{
    width:14px; height:14px; border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); cursor:pointer;
  }
  .pan-slider-y input[type="range"]{
    -webkit-appearance:none; appearance:none;
    position:absolute; top:50%; left:50%;
    transform:translate(-50%,-50%) rotate(-90deg);
    transform-origin:center center;
    width:calc(100% - 6px); height:14px; margin:0;
    background:transparent; outline:none;
  }
  .pan-slider-y input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-y input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:14px; height:14px; margin-top:-4px;
    border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15);
    box-shadow:0 1px 1px rgba(0,0,0,.05); cursor:pointer;
  }
  .pan-slider-y input[type="range"]::-moz-range-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-y input[type="range"]::-moz-range-thumb{
    width:14px; height:14px; border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); cursor:pointer;
  }

  .toast{ position:fixed; left:50%; top:18px; transform:translateX(-50%); background:#333; color:#fff; padding:8px 12px; border-radius:10px; font-size:13px; opacity:0; transition:opacity .2s ease; pointer-events:none; z-index:9; }
  .toast.show{ opacity:.95; }
  .banner{ position:fixed; left:0; right:0; top:0; padding:8px 12px; background:var(--danger); color:#fff; font-weight:900; display:none; z-index:10; }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>AGVシミュレーター（Job連結 / KPI 最終版）</h1>

    <div class="section">
      <div class="row"><strong>操作手順</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>ルートを <b>＋</b> で追加し、車体（A〜J）を選択</li>
        <li><b>経路生成ON</b> のルートだけ編集可（再押しでOFF）</li>
        <li>交点クリックで <b>P1→P2→…</b> の順にポイント追加（水平/垂直のみ）</li>
        <li>ダブルクリックで <b>S→G</b> を設定（S未設定ならS、次にG）</li>
        <li><b>Shift+ダブルクリック</b>：待機点追加（秒数入力、複数可）</li>
        <li>Jobは Route を順番指定して連結（同一車体が前提。違うとエラー）</li>
        <li>画像は <b>スクショ→Ctrl+V</b> で貼り付け（運用想定）</li>
      </ol>
    </div>

    <!-- 画像レイヤ（貼り付けメイン） -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>画像レイヤ（貼り付けOK）</strong>
        <span class="note">グリッドは常に前面</span>
      </div>

      <div class="img-controls">
        <button id="pasteHintBtn" class="btn primary">Ctrl+V で貼り付け</button>
        <button id="clearImagesBtn" class="btn ghost">全画像クリア</button>
      </div>

      <div class="slider-row">
        <label class="small" for="imgOpacity" style="min-width:64px;">不透明度</label>
        <input id="imgOpacity" type="range" min="0" max="100" value="100" />
        <span id="imgOpacityLabel" class="small" style="min-width:40px; text-align:right;">100%</span>
      </div>
      <div class="note">操作：移動/リサイズは「選択ON」の画像のみ。四隅ドラッグ（Shiftで縦横比解除）／削除：Delete</div>
      <div id="imgList" class="img-list"></div>
    </div>

    <!-- ルート -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ルート一覧</strong>
        <span class="note">（表示番号は小さい順の連番）</span>
      </div>
      <div id="routesList" class="routes-list"></div>
      <div class="row">
        <button id="addRoute" class="btn primary">＋ ルート追加</button>
        <button id="removeRoute" class="btn ghost">− 最後のルート削除</button>
      </div>
      <div class="row">
        <button id="exportPngBtn" class="btn ghost slim" title="PNG書き出し">PNG</button>
        <button id="exportBtn" class="btn ghost">JSON書き出し</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn ghost">JSON読み込み</button>
      </div>
      <div class="note">※待機点は「Shift+ダブルクリック」で追加。ルート毎に保持されます。</div>
    </div>

    <!-- Job -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>Job一覧（Route連結）</strong>
        <span class="note">Job1=R1→R2→…（繰返し）</span>
      </div>
      <div id="jobsList" class="jobs-list"></div>
      <div class="row">
        <button id="addJobBtn" class="btn primary">＋ Job追加</button>
        <button id="removeJobBtn" class="btn ghost">− 最後のJob削除</button>
      </div>
      <div class="note">Job内Routeの車体(A〜J)が一致しない場合はエラー表示（重ね走行に対応）。</div>
    </div>

    <!-- 車体 -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>車体一覧（A〜J）</strong>
        <span class="note">速度[m/s]・旋回[s/90°]</span>
      </div>
      <div id="vehicles" class="vehicle-grid"></div>
      <div class="note">※荷積み/荷下ろし時間はルート側に入力（工程差を反映）</div>
    </div>

    <!-- KPI -->
    <div class="section status">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ステータス（Route / Job）</strong>
        <span class="note">Job搬送量(/h)=3600/Job合計時間×稼働率</span>
      </div>

      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="chargePct">充電率ダウンタイム（0–30%）</label>
        <input id="chargePct" type="number" min="0" max="30" step="1" value="0" style="width:70px; padding:4px 6px; border-radius:8px; border:none; font-weight:900;"/>
        <span class="note">稼働率=(1-充電率)</span>
      </div>

      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="safetyPct">安全率（0–50%）</label>
        <input id="safetyPct" type="number" min="0" max="50" step="1" value="0" style="width:70px; padding:4px 6px; border-radius:8px; border:none; font-weight:900;"/>
        <span class="note">稼働率×(1-安全率)</span>
      </div>

      <div class="note" id="formulaNote" style="margin-top:4px;">
        計算式：稼働率 = (1 − 充電率/100) × (1 − 安全率/100) ／ 実効搬送量(/h) = (3600 ÷ Job合計時間[s]) × 稼働率
      </div>

      <div class="kpi-block" id="statusBlock"></div>
    </div>

    <div class="section">
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除（アクティブルート）</button>
      </div>
      <div class="row">
        <button id="clear" class="btn ghost">アクティブルート全消去</button>
      </div>
      <div class="row">
        <button id="simulateToggle" class="btn primary" style="min-width:320px;">シミュレーション開始（Job繰返し・全車体同時）</button>
      </div>
      <div class="note">Ctrl+Z でも1つ戻せます</div>
    </div>
  </aside>

  <!-- キャンバス -->
  <div class="canvas-wrap">
    <canvas id="map"></canvas>

    <!-- パン用スライダー（右・下） -->
    <div class="pan-slider-y"><input id="panY" type="range" min="0" max="100" value="0" orient="vertical"></div>
    <div class="pan-slider-x"><input id="panX" type="range" min="0" max="100" value="0"></div>

    <div class="canvas-ui ui-top-right" id="speedBox">
      <button id="speedDec" class="speed-btn" title="速度を下げる">◀</button>
      <span class="speed-label" id="speedLabel">1×</span>
      <button id="speedInc" class="speed-btn" title="速度を上げる">▶</button>
    </div>
    <div class="canvas-ui ui-bottom-left"><span id="zoomLabel">100%</span></div>
  </div>

  <div id="toast" class="toast"></div>
  <div id="banner" class="banner"></div>

<script defer>
(function(){
  /* ========================
     定数・状態
  =========================*/
  var PX_PER_M = 40, GRID = PX_PER_M, EPS = 0.5, SNAP_TOL = GRID * 0.35;
  var ROUTE_COLORS = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad','#16a085','#f39c12','#c0392b','#2980b9','#7f8c8d'];
  var WORLD = { width: 8000, height: 6000 };

  // 画像
  var images = []; var nextImgId = 1; var selectedImgId = null; var IMG_HANDLE = 10;
  var imgDrag = { active:false, mode:null, start:{x:0,y:0}, base:{x:0,y:0,w:0,h:0}, keepAR:true };

  // ズーム
  var view = { scale:1.0, min:0.1, max:2.0, offsetX:0, offsetY:0, dragging:false, dragStart:{x:0,y:0}, startOffset:{x:0,y:0} };

  // 速度倍率
  var SPEED_STEPS = [0.5, 1, 2, 4], speedIndex = 1;
  function currentSpeed(){ return SPEED_STEPS[speedIndex]; }

  // ルート
  var routes = {}; var activeRouteId = null; var nextRouteId = 1;

  // Job
  var jobs = {}; var nextJobId = 1;

  // 車体（速度[m/s], 旋回[s/90deg]）
  var vehicles = {};
  'ABCDEFGHIJ'.split('').forEach(function(ch){ vehicles[ch] = { speed:1.0, turn:2.0 }; });

  // シミュレーション
  var simRunning = false;
  // simByAgv['A'] = { agv:'A', jobId, routeIdx, path, segIndex, pos, heading, phase, ...}
  var simByAgv = {};

  /* ========================
     DOM
  =========================*/
  var canvas, ctx, toastEl, bannerEl;
  var zoomLabelEl, speedLabelEl, speedDecBtn, speedIncBtn;
  var panXEl, panYEl;

  var routesListEl, addRouteBtn, removeRouteBtn, undoBtn, clearBtn, simulateBtn;
  var jobsListEl, addJobBtn, removeJobBtn;
  var vehiclesEl, exportBtn, importBtn, importFile, exportPngBtn;
  var statusBlockEl, chargePctEl, safetyPctEl;

  var pasteHintBtn, clearImagesBtn, imgOpacityEl, imgOpacityLabelEl, imgListEl;

  /* ========================
     Utils
  =========================*/
  function toast(msg){
    if(!toastEl) return;
    toastEl.textContent=msg;
    toastEl.classList.add('show');
    setTimeout(function(){ toastEl.classList.remove('show'); }, 1300);
  }
  function banner(msg){
    if(!bannerEl) return;
    if(!msg){ bannerEl.style.display='none'; bannerEl.textContent=''; return; }
    bannerEl.textContent=msg;
    bannerEl.style.display='block';
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function approx(a,b,eps){ return Math.abs(a-b) <= (eps||EPS); }
  function anyBuilding(){ return Object.keys(routes).some(function(k){ return !!routes[k].building; }); }

  function clientToCanvasXY(clientX, clientY){ var r=canvas.getBoundingClientRect(); return { x: clientX - r.left, y: clientY - r.top }; }
  function screenToWorld(sx, sy){ return { x: (sx - view.offsetX)/view.scale, y: (sy - view.offsetY)/view.scale }; }
  function worldToScreen(wx, wy){ return { x: wx*view.scale + view.offsetX, y: wy*view.scale + view.offsetY }; }

  function clampOffsets(){
    var minX = Math.min(0, canvas.width - WORLD.width * view.scale), maxX = 0;
    var minY = Math.min(0, canvas.height - WORLD.height * view.scale), maxY = 0;
    view.offsetX = clamp(view.offsetX, minX, maxX);
    view.offsetY = clamp(view.offsetY, minY, maxY);
  }

  function updatePanSlidersFromView(){
    var vx = -view.offsetX / view.scale, vy = -view.offsetY / view.scale;
    var spanX = Math.max(1, WORLD.width - canvas.width / view.scale);
    var spanY = Math.max(1, WORLD.height - canvas.height / view.scale);
    panXEl.value = clamp(Math.round((vx / spanX) * 100), 0, 100);
    panYEl.value = clamp(Math.round((vy / spanY) * 100), 0, 100);
  }
  function updateViewFromPanSliders(){
    var spanX = Math.max(0, WORLD.width - canvas.width / view.scale);
    var spanY = Math.max(0, WORLD.height - canvas.height / view.scale);
    var vx = (spanX * (+panXEl.value) / 100);
    var vy = (spanY * (+panYEl.value) / 100);
    view.offsetX = -vx * view.scale;
    view.offsetY = -vy * view.scale;
    clampOffsets(); drawAll();
  }

  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, function(m){ return ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]); }); }

  function getOrderedRouteIds(){ return Object.keys(routes).map(function(k){ return +k; }).sort(function(a,b){ return a-b; }); }
  function getRouteDisplayIndex(id){
    var ids=getOrderedRouteIds(); var idx=ids.indexOf(id);
    return idx===-1? null : (idx+1);
  }

  function getOrderedJobIds(){ return Object.keys(jobs).map(function(k){ return +k; }).sort(function(a,b){ return a-b; }); }
  function getJobDisplayIndex(id){
    var ids=getOrderedJobIds(); var idx=ids.indexOf(id);
    return idx===-1? null : (idx+1);
  }

  /* ========================
     ジオメトリ（マンハッタン）
  =========================*/
  function polylineFromPoints(r){
    if(!r || !r.points || r.points.length<2) return [];
    var clean=[];
    for(var i=0;i<r.points.length;i++){
      var p={x:r.points[i][0], y:r.points[i][1]};
      if(!clean.length){ clean.push(p); continue; }
      var a=clean[clean.length-1];
      if(approx(a.x,p.x) && approx(a.y,p.y)) continue;
      if(!approx(a.x,p.x) && !approx(a.y,p.y)) continue; // 斜めは禁止
      if(clean.length>=2){
        var b=clean[clean.length-2];
        if(approx(b.x,a.x) && approx(a.x,p.x)){ clean[clean.length-1]=p; continue; }
        if(approx(b.y,a.y) && approx(a.y,p.y)){ clean[clean.length-1]=p; continue; }
      }
      clean.push(p);
    }
    return clean;
  }

  function segLenPx(A,B){ return Math.abs(B.x-A.x) + Math.abs(B.y-A.y); }
  function totalLenPx(path){ var S=0; for(var i=0;i<path.length-1;i++) S+=segLenPx(path[i], path[i+1]); return S; }

  function projectToPolyline(xy, path, tolPx){
    if(!path || path.length<2) return null;
    var best=null, bestDist=Infinity, tol=(tolPx||SNAP_TOL);
    for (var i=0;i<path.length-1;i++){
      var A=path[i], B=path[i+1];
      if(approx(A.x,B.x)){
        var dx=Math.abs(xy[0]-A.x);
        if(dx<=tol){
          var y=clamp(xy[1], Math.min(A.y,B.y), Math.max(A.y,B.y));
          var d=dx+Math.abs(xy[1]-y);
          if(d<bestDist){ bestDist=d; best={x:A.x,y:y,i:i}; }
        }
      } else if(approx(A.y,B.y)){
        var dy=Math.abs(xy[1]-A.y);
        if(dy<=tol){
          var x=clamp(xy[0], Math.min(A.x,B.x), Math.max(A.x,B.x));
          var d=dy+Math.abs(xy[0]-x);
          if(d<bestDist){ bestDist=d; best={x:x,y:A.y,i:i}; }
        }
      }
    }
    return best;
  }

  function progressAlong(path, point){
    var proj=projectToPolyline([point.x, point.y], path, SNAP_TOL);
    if(!proj) return null;
    var s=0;
    for(var k=0;k<proj.i;k++) s += segLenPx(path[k], path[k+1]);
    s += segLenPx(path[proj.i], {x:proj.x, y:proj.y});
    return { s:s, pt:{x:proj.x, y:proj.y}, i:proj.i };
  }

  function pointAtProgress(path, s){
    s=clamp(s,0,totalLenPx(path));
    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      if(acc + L >= s - EPS){
        var t=(s-acc)/L; var A=path[i], B=path[i+1];
        return approx(A.x,B.x) ? { x:A.x, y:A.y + (B.y-A.y)*t } : { x:A.x + (B.x-A.x)*t, y:A.y };
      }
      acc+=L;
    }
    return { x:path[path.length-1].x, y:path[path.length-1].y };
  }

  function clipPathByProgress(path, s0, s1){
    if(!path || path.length<2) return [];
    var a=Math.min(s0,s1), b=Math.max(s0,s1);
    if(b-a<EPS) return [];
    var out=[];
    var P0=pointAtProgress(path,a), P1=pointAtProgress(path,b);
    out.push(P0);

    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      var accNext=acc+L;
      if(accNext>a+EPS && accNext<b-EPS){
        out.push({x:path[i+1].x, y:path[i+1].y});
      }
      acc=accNext;
    }
    out.push(P1);

    var clean=[];
    for(var m=0;m<out.length;m++){
      if(!clean.length){ clean.push(out[m]); continue; }
      var aP=clean[clean.length-1], bP=out[m];
      if(approx(aP.x,bP.x)&&approx(aP.y,bP.y)) continue;
      clean.push(bP);
    }
    return clean;
  }

  // ルートのS->Gサブパス（片道）
  function sgSubpathAndMeters(r){
    if(!r || !r.start || !r.goal) return {path:[], meters:0, sProg:null, gProg:null};
    var base=polylineFromPoints(r);
    if(!base.length) return {path:[], meters:0, sProg:null, gProg:null};
    var prS=progressAlong(base,{x:r.start[0], y:r.start[1]});
    var prG=progressAlong(base,{x:r.goal[0], y:r.goal[1]});
    if(!prS||!prG) return {path:[], meters:0, sProg:null, gProg:null};
    var sub=clipPathByProgress(base, prS.s, prG.s);
    var dist_m=Math.abs(prG.s-prS.s)/PX_PER_M;
    // 方向（S->G）を保持するため、clipは常に小→大なので、Sが後ろなら反転
    if(prS.s > prG.s) sub.reverse();
    return { path:sub, meters:dist_m, sProg:prS, gProg:prG };
  }

  /* ========================
     角度・旋回
  =========================*/
  function headingOf(A,B){
    if(B.x>A.x) return 0;
    if(B.x<A.x) return 180;
    if(B.y>A.y) return 90;
    if(B.y<A.y) return 270; // -90 を 270 に統一
    return 0;
  }
  function normHeading(h){ h=((h%360)+360)%360; return h; }
  function angleDelta(a,b){
    a=normHeading(a); b=normHeading(b);
    var d=((b-a+540)%360)-180;
    return Math.round(d);
  }
  function lerpAngle(a,b,t){
    var d=angleDelta(a,b);
    return normHeading(a + d*t);
  }

  // delta を 90°単位のセグメントに分解（90/180/270）
  function buildTurnQueue(deltaDeg, turnS){
    var q=[];
    var d=((deltaDeg%360)+360)%360;
    if(d===0) return q;
    // 右回り/左回りのどちらか（angleDeltaの符号を使う）
    // deltaDeg が -90 などもあり得るので正規化より、元の符号を尊重して分割
    var sign = (deltaDeg<0)? -1 : 1;
    var abs = Math.abs(deltaDeg);
    var steps = Math.round(abs/90);
    for(var i=0;i<steps;i++){
      q.push({ delta: sign*90, duration: turnS*1000 });
    }
    return q;
  }

  /* ========================
     画像（貼り付け）
  =========================*/
  function getSelectedImage(){
    return selectedImgId ? (images.find(function(it){ return it.id===selectedImgId; })||null) : null;
  }

  function addImageLayerFromBitmap(name, bmp){
    var w=bmp.width, h=bmp.height;
    var targetW = Math.min( (canvas.width/ view.scale) * 0.6, w );
    var scale = targetW / w;
    var targetH = h * scale;
    images.push({ id: nextImgId++, name: name||'pasted', bitmap: bmp, x:40, y:40, w:targetW, h:targetH, opacity:1.0 });
    renderImageList(); drawAll();
  }

  async function handlePasteImageFromClipboard(e){
    var items = (e.clipboardData && e.clipboardData.items) ? e.clipboardData.items : [];
    for(var i=0;i<items.length;i++){
      var it = items[i];
      if(it.type && it.type.indexOf('image')===0){
        var file = it.getAsFile();
        if(!file) continue;
        try{
          var bmp = await createImageBitmap(file);
          addImageLayerFromBitmap('clipboard_'+Date.now(), bmp);
          toast('画像を貼り付けました');
          e.preventDefault();
          return;
        }catch(err){
          toast('貼り付け失敗: '+err.message);
        }
      }
    }
  }

  function renderImageList(){
    imgListEl.innerHTML = '';
    images.forEach(function(it){
      var div=document.createElement('div'); div.className='img-item';

      var name=document.createElement('div');
      name.innerHTML='<strong>#'+it.id+'</strong> <span class="small">'+escapeHtml(it.name)+'</span>';

      var toggle=document.createElement('button');
      toggle.className='btn mini-btn';
      var isOn=(selectedImgId===it.id);
      if(isOn){
        toggle.textContent='選択ON';
        toggle.style.background='#fff'; toggle.style.color='#006666'; toggle.style.border='none';
      }else{
        toggle.textContent='選択OFF';
        toggle.style.background='transparent'; toggle.style.color='#fff'; toggle.style.border='1px solid #fff';
      }
      toggle.addEventListener('click', function(ev){
        ev.stopPropagation();
        selectedImgId = (selectedImgId===it.id) ? null : it.id;
        var s=getSelectedImage();
        if(s){
          imgOpacityEl.value = Math.round(s.opacity*100);
          imgOpacityLabelEl.textContent = Math.round(s.opacity*100)+'%';
        }
        renderImageList(); drawAll();
      });

      var delBtn=document.createElement('button');
      delBtn.className='btn ghost mini-btn';
      delBtn.textContent='削除';
      delBtn.addEventListener('click', function(ev){
        ev.stopPropagation();
        images = images.filter(function(x){ return x.id!==it.id; });
        if(selectedImgId===it.id) selectedImgId=null;
        renderImageList(); drawAll();
      });

      div.appendChild(name); div.appendChild(toggle); div.appendChild(delBtn);
      imgListEl.appendChild(div);
    });
  }

  function hitImageHandle(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY), w=screenToWorld(s.x, s.y);
    var pts=[{x:it.x,y:it.y,c:'nw'},{x:it.x+it.w,y:it.y,c:'ne'},{x:it.x,y:it.y+it.h,c:'sw'},{x:it.x+it.w,y:it.y+it.h,c:'se'}];
    for(var i=0;i<pts.length;i++){
      var p=pts[i];
      var dx=Math.abs(w.x-p.x)*view.scale, dy=Math.abs(w.y-p.y)*view.scale;
      if(Math.hypot(dx,dy)<=IMG_HANDLE+2) return p.c;
    }
    return null;
  }
  function hitImageBody(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY), w=screenToWorld(s.x, s.y);
    return (w.x>=it.x && w.x<=it.x+it.w && w.y>=it.y && w.y<=it.y+it.h);
  }
  function pickImage(clientX, clientY){
    for(var i=images.length-1;i>=0;i--){
      var it=images[i];
      var h=hitImageHandle(it, clientX, clientY);
      if(h) return {it:it, mode:h};
      if(hitImageBody(it, clientX, clientY)) return {it:it, mode:'move'};
    }
    return null;
  }

  /* ========================
     ルート / Job データ構造
  =========================*/
  function createRoute(){
    var id=nextRouteId++;
    var color=ROUTE_COLORS[(id-1)%ROUTE_COLORS.length];
    routes[id]={
      id:id,
      agv:'A',
      color:color,
      building:false,
      points:[],
      start:null,
      goal:null,
      waitPoints:[],          // [{x,y,sec}]
      turnCount:0,            // ルート内旋回数（工程差）
      loadS:0,                // 荷積み時間[s]（ルート開始側）
      unloadS:0               // 荷下ろし時間[s]（ルート終端側）
    };
    activeRouteId=id;
  }

  function createJob(){
    var id=nextJobId++;
    // 初期は存在するルートを順に1つ入れる（あれば）
    var rids=getOrderedRouteIds();
    jobs[id]={
      id:id,
      routes: rids.length ? [rids[0]] : []
    };
  }

  function validateJobs(){
    // Job内で車体が一致しているか
    var errors=[];
    getOrderedJobIds().forEach(function(jid){
      var j=jobs[jid];
      var agv=null;
      for(var i=0;i<j.routes.length;i++){
        var rid=j.routes[i];
        var r=routes[rid];
        if(!r) continue;
        if(!agv) agv=r.agv;
        if(r.agv!==agv){
          errors.push('Job'+getJobDisplayIndex(jid)+'：Route内の車体が一致していません（'+agv+' と '+r.agv+'）');
          break;
        }
      }
    });
    if(errors.length){
      banner(errors[0] + ' / 修正してください（シミュレーション不可）');
      return false;
    }
    banner(null);
    return true;
  }

  /* ========================
     KPI 計算（Route / Job）
  =========================*/
  function getAvailability(){
    var charge = Math.min(30, Math.max(0, parseFloat(chargePctEl.value)||0));
    var safety = Math.min(50, Math.max(0, parseFloat(safetyPctEl.value)||0));
    var avail = (1 - charge/100) * (1 - safety/100);
    return { charge:charge, safety:safety, avail:avail };
  }

  function calcRouteTimes(r){
    // 片道（S->G）
    var sg=sgSubpathAndMeters(r);
    var dist_m=sg.meters;
    var wp = (r.waitPoints||[]);
    var wait_s = wp.reduce(function(acc,w){ return acc + Math.max(0, +w.sec||0); }, 0);

    var v = vehicles[r.agv] || { speed:1.0, turn:2.0 };
    var speed = Math.max(0.01, +v.speed||1.0);
    var travel_s = (dist_m>0)? (dist_m / speed) : 0;

    var turnPer90 = Math.max(0, +v.turn||0);
    var turn_s = Math.max(0, (+r.turnCount||0)) * turnPer90;

    var load_s = Math.max(0, +r.loadS||0);
    var unload_s = Math.max(0, +r.unloadS||0);

    var total_s = travel_s + turn_s + wait_s + load_s + unload_s;

    return {
      dist_m:dist_m,
      travel_s:travel_s,
      turn_s:turn_s,
      wait_s:wait_s,
      load_s:load_s,
      unload_s:unload_s,
      total_s:total_s,
      sgPath: sg.path
    };
  }

  function getRouteHeadingsForTransition(r){
    // ルートの最初と最後の進行方向（S->Gサブパス）
    var sg=sgSubpathAndMeters(r);
    var p=sg.path;
    if(!p || p.length<2) return { startH:0, endH:0, ok:false };
    var startH=headingOf(p[0], p[1]);
    var endH=headingOf(p[p.length-2], p[p.length-1]);
    return { startH:startH, endH:endH, ok:true };
  }

  function calcJobTotal(job){
    // Job合計（理論）：各Route(片道) + Route間の「向き合わせ旋回（90/180/270）」も加算
    var totals = { dist_m:0, travel_s:0, turn_s:0, wait_s:0, load_s:0, unload_s:0, total_s:0 };
    if(!job || !job.routes || !job.routes.length) return totals;

    // Job車体（1つ目のルート）
    var firstRoute = routes[job.routes[0]];
    var agv = firstRoute ? firstRoute.agv : null;
    var v = agv ? (vehicles[agv]||{speed:1.0, turn:2.0}) : {speed:1.0, turn:2.0};
    var turnPer90 = Math.max(0, +v.turn||0);

    var prevEndH=null;
    for(var i=0;i<job.routes.length;i++){
      var rid=job.routes[i];
      var r=routes[rid];
      if(!r) continue;

      var rt=calcRouteTimes(r);
      totals.dist_m += rt.dist_m;
      totals.travel_s += rt.travel_s;
      totals.turn_s += rt.turn_s;     // ルート内旋回
      totals.wait_s += rt.wait_s;
      totals.load_s += rt.load_s;
      totals.unload_s += rt.unload_s;

      // Route間の旋回（前の終端向き -> 次の開始向き）
      var hs=getRouteHeadingsForTransition(r);
      if(hs.ok){
        if(prevEndH!==null){
          var d=angleDelta(prevEndH, hs.startH);
          totals.turn_s += (Math.abs(d)/90) * turnPer90;
        }
        prevEndH = hs.endH;
      }
    }

    totals.total_s = totals.travel_s + totals.turn_s + totals.wait_s + totals.load_s + totals.unload_s;
    return totals;
  }

  function ratioPills(t){
    // 内訳比率（合計に対する%）
    var tot=Math.max(1e-9, t.total_s);
    function pct(x){ return Math.round((x/tot)*100); }
    return [
      {k:'走行', v:pct(t.travel_s)},
      {k:'旋回', v:pct(t.turn_s)},
      {k:'待機', v:pct(t.wait_s)},
      {k:'荷積', v:pct(t.load_s)},
      {k:'荷下', v:pct(t.unload_s)}
    ];
  }

  /* ========================
     描画
  =========================*/
  function applyTransform(){ ctx.setTransform(view.scale,0,0,view.scale,view.offsetX,view.offsetY); }
  function resetTransform(){ ctx.setTransform(1,0,0,1,0,0); }

  function resize(){
    var sidebar=document.querySelector('.sidebar');
    var sw=sidebar?sidebar.offsetWidth:520;
    var w=Math.max(260, window.innerWidth - sw);
    var h=window.innerHeight;
    canvas.width=w; canvas.height=h;
    clampOffsets(); updatePanSlidersFromView(); drawAll();
  }

  function drawImages(){
    images.forEach(function(it){
      if(!it.bitmap) return;
      ctx.save();
      ctx.globalAlpha=clamp(it.opacity,0,1);
      ctx.drawImage(it.bitmap, it.x, it.y, it.w, it.h);
      ctx.restore();
    });

    // 選択枠＆ハンドル
    if(selectedImgId){
      var it=getSelectedImage();
      if(it){
        ctx.save();
        ctx.lineWidth=1/view.scale;
        ctx.strokeStyle='#00bcd4';
        ctx.setLineDash([6/view.scale, 4/view.scale]);
        ctx.strokeRect(it.x,it.y,it.w,it.h);
        ctx.setLineDash([]);
        var handles=[{x:it.x,y:it.y},{x:it.x+it.w,y:it.y},{x:it.x,y:it.y+it.h},{x:it.x+it.w,y:it.y+it.h}];
        ctx.fillStyle='#00bcd4';
        handles.forEach(function(h){
          ctx.beginPath();
          ctx.arc(h.x,h.y,IMG_HANDLE/view.scale,0,Math.PI*2);
          ctx.fill();
        });
        ctx.restore();
      }
    }
  }

  function drawGrid(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    var minW=(-view.offsetX)/view.scale, minH=(-view.offsetY)/view.scale;
    var maxW=(canvas.width - view.offsetX)/view.scale, maxH=(canvas.height - view.offsetY)/view.scale;

    applyTransform();
    ctx.fillStyle='#fff';
    ctx.fillRect(0,0,WORLD.width,WORLD.height);

    // 画像（背面）
    drawImages();

    // グリッド（前面）
    ctx.strokeStyle=varGet('--grid','#e6e6e6');
    ctx.lineWidth=1/view.scale;

    var startX=Math.max(0, Math.floor(minW/GRID)*GRID);
    for(var x=startX; x<=Math.min(maxW, WORLD.width); x+=GRID){
      ctx.beginPath(); ctx.moveTo(x, Math.max(0,minH)); ctx.lineTo(x, Math.min(maxH, WORLD.height)); ctx.stroke();
    }
    var startY=Math.max(0, Math.floor(minH/GRID)*GRID);
    for(var y=startY; y<=Math.min(maxH, WORLD.height); y+=GRID){
      ctx.beginPath(); ctx.moveTo(Math.max(0,minW), y); ctx.lineTo(Math.min(maxW, WORLD.width), y); ctx.stroke();
    }
    resetTransform();
  }

  function varGet(name, fallback){
    try{
      var v=getComputedStyle(document.documentElement).getPropertyValue(name);
      return (v && v.trim()) ? v.trim() : fallback;
    }catch(e){ return fallback; }
  }

  function drawRoutes(){
    applyTransform();

    getOrderedRouteIds().forEach(function(id){
      var r=routes[id];
      var dispIdx=getRouteDisplayIndex(id);
      var base=polylineFromPoints(r);

      // 通常ルート線
      if(base.length>=2){
        ctx.lineWidth=2/view.scale;
        ctx.strokeStyle=r.color;
        ctx.globalAlpha=0.85;
        ctx.beginPath();
        ctx.moveTo(base[0].x, base[0].y);
        for(var i=1;i<base.length;i++) ctx.lineTo(base[i].x, base[i].y);
        ctx.stroke();
        ctx.globalAlpha=1;
      }

      // ポイント
      for(var j=0;j<r.points.length;j++){
        var p=r.points[j];
        ctx.fillStyle=r.color;
        ctx.beginPath();
        ctx.arc(p[0],p[1],4/view.scale,0,Math.PI*2);
        ctx.fill();
      }

      // 待機点
      (r.waitPoints||[]).forEach(function(wp, idx){
        ctx.save();
        ctx.fillStyle='#111';
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, 5/view.scale, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle='#000';
        ctx.font=(13/view.scale)+'px system-ui, sans-serif';
        ctx.textBaseline='top';
        ctx.fillText('W'+dispIdx+'-'+(idx+1), wp.x+6/view.scale, wp.y-18/view.scale);
        ctx.restore();
      });

      // S/G
      ctx.fillStyle='#000';
      ctx.font=(16/view.scale)+'px system-ui, sans-serif';
      ctx.textBaseline='top';
      if(r.start) ctx.fillText('S'+dispIdx, r.start[0]-10/view.scale, r.start[1]-18/view.scale);
      if(r.goal)  ctx.fillText('G'+dispIdx, r.goal[0]-10/view.scale,  r.goal[1]-18/view.scale);
    });

    resetTransform();
  }

  // 走行中（現在車体が属するルート）を「先導発光」させる
  function drawActiveGlow(){
    if(!simRunning) return;

    applyTransform();
    Object.keys(simByAgv).forEach(function(agv){
      var s=simByAgv[agv];
      if(!s || !s.currentRouteId) return;
      var r=routes[s.currentRouteId];
      if(!r) return;
      var sg=sgSubpathAndMeters(r);
      if(!sg.path || sg.path.length<2) return;

      // 先頭位置から少し先までを発光（誘導）
      var path=sg.path;
      // 現在のprogress(ピクセル距離)を推定
      // segIndex と pos から sAlong を概算
      var along=0;
      for(var i=0;i<s.segIndex;i++){
        along += segLenPx(path[i], path[i+1]);
      }
      // セグメント内の位置
      var A=path[s.segIndex], B=path[s.segIndex+1];
      if(A && B){
        along += segLenPx(A, {x:s.pos.x, y:s.pos.y});
      }
      var glowLen = 8*GRID; // 先導長さ（8マス）
      var startS = clamp(along, 0, totalLenPx(path));
      var endS   = clamp(along + glowLen, 0, totalLenPx(path));

      // クリップしたサブパスを太く描画
      var clip = clipPathByProgress(path, startS, endS);
      if(!clip || clip.length<2) return;

      ctx.save();
      ctx.lineCap='round';

      // 柔らかい光（太い薄線）
      ctx.globalAlpha=0.28;
      ctx.lineWidth=18/view.scale;
      ctx.strokeStyle=r.color;
      ctx.beginPath();
      ctx.moveTo(clip[0].x, clip[0].y);
      for(var k=1;k<clip.length;k++) ctx.lineTo(clip[k].x, clip[k].y);
      ctx.stroke();

      // 芯線
      ctx.globalAlpha=0.95;
      ctx.lineWidth=4/view.scale;
      ctx.beginPath();
      ctx.moveTo(clip[0].x, clip[0].y);
      for(var k2=1;k2<clip.length;k2++) ctx.lineTo(clip[k2].x, clip[k2].y);
      ctx.stroke();

      ctx.restore();
    });
    resetTransform();
  }

  function drawAGVs(){
    if(!simRunning) return;
    applyTransform();
    Object.keys(simByAgv).forEach(function(agv){
      var s=simByAgv[agv];
      if(!s || !s.pos) return;
      var r = s.currentRouteId ? routes[s.currentRouteId] : null;
      var color = r ? r.color : '#000';

      var L=22, W=14;
      var rad=(normHeading(s.heading||0))*Math.PI/180;

      ctx.save();
      ctx.translate(s.pos.x, s.pos.y);
      ctx.rotate(rad);
      ctx.fillStyle=color;
      ctx.fillRect(-L/2, -W/2, L, W);
      ctx.fillStyle='#000';
      ctx.beginPath();
      ctx.moveTo(L/2,0);
      ctx.lineTo(L/2-4,-3);
      ctx.lineTo(L/2-4,3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // ラベル
      ctx.save();
      ctx.fillStyle='#000';
      ctx.font=(12/view.scale)+'px system-ui, sans-serif';
      ctx.textBaseline='top';
      ctx.fillText(agv, s.pos.x+8/view.scale, s.pos.y+6/view.scale);
      ctx.restore();
    });
    resetTransform();
  }

  function drawAll(){
    clampOffsets();
    drawGrid();
    drawRoutes();
    drawActiveGlow();
    drawAGVs();

    updatePanSlidersFromView();
    if(zoomLabelEl) zoomLabelEl.textContent = Math.round(view.scale*100) + '%';
    if(speedLabelEl) speedLabelEl.textContent = currentSpeed().toString() + '×';

    renderStatus();
  }

  /* ========================
     ルート UI
  =========================*/
  function setActiveRoute(id){
    if(id==null){
      var ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[0]:null;
    }else{
      activeRouteId=id;
    }
    drawAll(); updateCursor();
  }

  function setRouteAGV(id,agv){
    if(routes[id]) routes[id].agv=agv;
    validateJobs();
    renderJobsUI();
    drawAll();
  }

  function toggleRouteBuilding(id){
    if(!routes[id]) return;
    var wasOn=!!routes[id].building;
    Object.keys(routes).forEach(function(k){ routes[k].building=false; });
    routes[id].building = !wasOn;
    activeRouteId=id;
    renderRoutesUI(); drawAll(); updateCursor();
  }

  function removeLastRoute(){
    var ids=getOrderedRouteIds();
    if(!ids.length) return;
    var lastId=ids[ids.length-1];
    delete routes[lastId];

    // Jobからも除去
    getOrderedJobIds().forEach(function(jid){
      jobs[jid].routes = (jobs[jid].routes||[]).filter(function(rid){ return rid!==lastId; });
    });

    // active 調整
    if(activeRouteId===lastId){
      ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[ids.length-1]:null;
    }

    renderRoutesUI();
    renderJobsUI();
    validateJobs();
    drawAll();
  }

  function renderRoutesUI(){
    routesListEl.innerHTML='';
    var ids=getOrderedRouteIds();
    ids.forEach(function(id){
      var r=routes[id];
      var dispIdx=getRouteDisplayIndex(id);

      var item=document.createElement('div');
      item.className='route-item';

      // 名前
      var name=document.createElement('div');
      name.className='route-name';
      name.textContent='Route'+dispIdx+' ';
      var chip=document.createElement('span');
      chip.style.cssText='display:inline-block;width:10px;height:10px;border-radius:999px;background:'+r.color+';margin-left:6px;';
      name.appendChild(chip);

      // AGV
      var sel=document.createElement('select');
      sel.className='job-select';
      'ABCDEFGHIJ'.split('').forEach(function(ch){
        var opt=document.createElement('option');
        opt.value=ch; opt.textContent=ch;
        if(ch===r.agv) opt.selected=true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', function(ev){ ev.stopPropagation(); setRouteAGV(id, this.value); });

      // 経路生成
      var btn=document.createElement('button');
      btn.className='btn mini-btn';
      if(r.building){
        btn.textContent='経路生成ON';
        btn.style.background='#fff'; btn.style.color='#006666'; btn.style.border='none';
      }else{
        btn.textContent='経路生成OFF';
        btn.style.background='transparent'; btn.style.color='#fff'; btn.style.border='1px solid #fff';
      }
      btn.addEventListener('click', function(ev){ ev.stopPropagation(); toggleRouteBuilding(id); });

      // 旋回数
      var turnCell=document.createElement('div'); turnCell.className='mini-cell';
      turnCell.innerHTML='<div class="mini-label">旋回数</div>';
      var turnInp=document.createElement('input');
      turnInp.className='mini-input';
      turnInp.type='number'; turnInp.step='1'; turnInp.min='0';
      turnInp.value=String(r.turnCount||0);
      turnInp.addEventListener('change', function(ev){
        ev.stopPropagation();
        r.turnCount = Math.max(0, parseInt(this.value,10)||0);
        drawAll();
      });
      turnCell.appendChild(turnInp);

      // 荷積み
      var loadCell=document.createElement('div'); loadCell.className='mini-cell';
      loadCell.innerHTML='<div class="mini-label">荷積[s]</div>';
      var loadInp=document.createElement('input');
      loadInp.className='mini-input';
      loadInp.type='number'; loadInp.step='0.1'; loadInp.min='0';
      loadInp.value=String(r.loadS||0);
      loadInp.addEventListener('change', function(ev){
        ev.stopPropagation();
        r.loadS = Math.max(0, parseFloat(this.value)||0);
        drawAll();
      });
      loadCell.appendChild(loadInp);

      // 荷下ろし
      var unloadCell=document.createElement('div'); unloadCell.className='mini-cell';
      unloadCell.innerHTML='<div class="mini-label">荷下[s]</div>';
      var unloadInp=document.createElement('input');
      unloadInp.className='mini-input';
      unloadInp.type='number'; unloadInp.step='0.1'; unloadInp.min='0';
      unloadInp.value=String(r.unloadS||0);
      unloadInp.addEventListener('change', function(ev){
        ev.stopPropagation();
        r.unloadS = Math.max(0, parseFloat(this.value)||0);
        drawAll();
      });
      unloadCell.appendChild(unloadInp);

      // S/G & 待機削除
      var sgBtn=document.createElement('button');
      sgBtn.className='btn mini-btn ghost';
      sgBtn.textContent='S/G・待機削除';
      sgBtn.addEventListener('click', function(ev){
        ev.stopPropagation();
        r.start=null; r.goal=null; r.waitPoints=[];
        drawAll();
      });

      item.addEventListener('click', function(){ setActiveRoute(id); });

      item.appendChild(name);
      item.appendChild(sel);
      item.appendChild(btn);
      item.appendChild(turnCell);
      item.appendChild(loadCell);
      item.appendChild(unloadCell);
      item.appendChild(sgBtn);

      routesListEl.appendChild(item);
    });
  }

  /* ========================
     Job UI
  =========================*/
  function addRouteToJob(jobId, routeId){
    if(!jobs[jobId]) return;
    jobs[jobId].routes = jobs[jobId].routes || [];
    if(jobs[jobId].routes.indexOf(routeId)===-1) jobs[jobId].routes.push(routeId);
  }
  function removeRouteFromJob(jobId, routeId){
    if(!jobs[jobId]) return;
    jobs[jobId].routes = (jobs[jobId].routes||[]).filter(function(rid){ return rid!==routeId; });
  }

  function renderJobsUI(){
    jobsListEl.innerHTML='';
    var jids=getOrderedJobIds();
    jids.forEach(function(jid){
      var j=jobs[jid];
      var dispIdx=getJobDisplayIndex(jid);

      var item=document.createElement('div');
      item.className='job-item';

      var left=document.createElement('div');
      left.innerHTML='<div class="job-title">Job'+dispIdx+'</div>'
        +'<div class="job-routes">'+formatJobRoutes(j)+'</div>';

      // JobのRoute編集（簡易：1つ目/2つ目/3つ目…をプルダウンで指定）
      // ここは「順番設定できる」を最短で実現：最大6枠
      var editor=document.createElement('div');
      editor.style.display='flex';
      editor.style.flexDirection='column';
      editor.style.gap='6px';

      var maxSlots=6;
      var ids=getOrderedRouteIds();
      for(var i=0;i<maxSlots;i++){
        var sel=document.createElement('select');
        sel.className='job-select';
        // 空
        var opt0=document.createElement('option');
        opt0.value=''; opt0.textContent='(なし)';
        sel.appendChild(opt0);

        ids.forEach(function(rid){
          var r=routes[rid];
          var opt=document.createElement('option');
          opt.value=String(rid);
          opt.textContent='R'+getRouteDisplayIndex(rid)+'('+ (r? r.agv:'-') +')';
          sel.appendChild(opt);
        });

        var cur = (j.routes && j.routes[i]) ? String(j.routes[i]) : '';
        sel.value = cur;

        (function(slotIndex, selectEl){
          selectEl.addEventListener('change', function(ev){
            ev.stopPropagation();
            var val=this.value;
            // slot更新：重複は許す（同じルートを繋ぐケースに対応）
            // ただし空ならそのスロット以降も詰める
            var newArr=(j.routes||[]).slice(0);
            if(val===''){
              // slot以降を削除（詰める）
              newArr = newArr.slice(0, slotIndex);
            }else{
              newArr[slotIndex]=parseInt(val,10);
              // 前の空を潰す（undefinedが出たら詰める）
              newArr = newArr.filter(function(x){ return typeof x==='number' && isFinite(x); });
            }
            j.routes=newArr;
            validateJobs();
            renderJobsUI();
            drawAll();
          });
        })(i, sel);

        editor.appendChild(sel);
      }

      // 先頭/末尾操作
      var upBtn=document.createElement('button');
      upBtn.className='btn mini-btn ghost';
      upBtn.textContent='先頭へ';
      upBtn.addEventListener('click', function(ev){
        ev.stopPropagation();
        // Jobを先頭へ（表示順をID順なので、実装上は何もしない）
        toast('（メモ）Jobの並びはID順固定です。必要なら並び替え機能を追加できます。');
      });

      var delBtn=document.createElement('button');
      delBtn.className='btn mini-btn ghost';
      delBtn.textContent='削除';
      delBtn.addEventListener('click', function(ev){
        ev.stopPropagation();
        delete jobs[jid];
        renderJobsUI();
        validateJobs();
        drawAll();
      });

      item.appendChild(left);
      item.appendChild(editor);
      item.appendChild(upBtn);
      item.appendChild(delBtn);
      jobsListEl.appendChild(item);
    });
  }

  function formatJobRoutes(job){
    var arr=(job.routes||[]);
    if(!arr.length) return 'Route未設定';
    return arr.map(function(rid){
      var r=routes[rid];
      if(!r) return 'R?';
      return 'R'+getRouteDisplayIndex(rid)+'('+r.agv+')';
    }).join(' → ');
  }

  /* ========================
     車体 UI
  =========================*/
  function renderVehiclesUI(){
    var html='';
    html+='<div class="head">車体</div><div class="head">速度[m/s]</div><div class="head">旋回[s/90°]</div><div class="head"></div>';
    'ABCDEFGHIJ'.split('').forEach(function(ch){
      html += '<div><strong>'+ch+'</strong></div>'
        + '<div><input data-vkey="'+ch+'" data-field="speed" type="number" step="0.1" value="'+vehicles[ch].speed+'"></div>'
        + '<div><input data-vkey="'+ch+'" data-field="turn" type="number" step="0.1" value="'+vehicles[ch].turn+'"></div>'
        + '<div></div>';
    });
    vehiclesEl.innerHTML=html;
    vehiclesEl.querySelectorAll('input').forEach(function(inp){
      inp.addEventListener('change', function(){
        var k=this.getAttribute('data-vkey');
        var f=this.getAttribute('data-field');
        var val=parseFloat(this.value);
        if(!isFinite(val) || val<0) val=0;
        vehicles[k][f]=val;
        validateJobs();
        drawAll();
      });
    });
  }

  /* ========================
     ステータス（最終版）
     - Job合計時間（理論値）
     - 実効 Job搬送量 (/h)
     - 内訳比率
     - 稼働率バー表示
  =========================*/
  function renderStatus(){
    statusBlockEl.innerHTML='';

    var av=getAvailability();

    // 稼働率カード
    var utilCard=document.createElement('div');
    utilCard.className='kpi-card';
    utilCard.innerHTML=
      '<div class="kpi-head"><strong>稼働率</strong><span class="kpi-sub">'
      + (av.avail*100).toFixed(1) + '%'
      + '（充電 '+av.charge.toFixed(0)+'% / 安全 '+av.safety.toFixed(0)+'%）'
      + '</span></div>';
    var bar=document.createElement('div'); bar.className='bar-wrap';
    var fill=document.createElement('div'); fill.className='bar-fill';
    fill.style.width = clamp(av.avail*100,0,100).toFixed(1)+'%';
    bar.appendChild(fill);
    utilCard.appendChild(bar);
    statusBlockEl.appendChild(utilCard);

    // Route KPI
    var routeIds=getOrderedRouteIds();
    if(routeIds.length){
      routeIds.forEach(function(rid){
        var r=routes[rid];
        var dispIdx=getRouteDisplayIndex(rid);
        var rt=calcRouteTimes(r);

        var card=document.createElement('div');
        card.className='kpi-card';
        var wsum=(r.waitPoints||[]).reduce(function(a,w){ return a + Math.max(0,+w.sec||0); },0);

        card.innerHTML =
          '<div class="kpi-head">'
          + '<strong>Route'+dispIdx+'（'+(r.agv||'-')+'）</strong>'
          + '<span class="kpi-sub">距離 '+rt.dist_m.toFixed(1)+'m / 待機 '+wsum.toFixed(1)+'s / 荷積 '+rt.load_s.toFixed(1)+'s / 荷下 '+rt.unload_s.toFixed(1)+'s</span>'
          + '</div>'
          + '<div class="kpi-metrics">'
          + '<div class="summary-line"><span>走行</span><span>'+rt.travel_s.toFixed(1)+'s</span></div>'
          + '<div class="summary-line"><span>旋回（ルート内：旋回数×旋回[s/90°]）</span><span>'+rt.turn_s.toFixed(1)+'s</span></div>'
          + '<div class="summary-line"><span>合計（片道S→G）</span><span><b>'+rt.total_s.toFixed(1)+'s</b></span></div>'
          + '</div>';

        statusBlockEl.appendChild(card);
      });
    }

    // Job KPI（最終：理論時間＋実効搬送量/h＋内訳比率）
    var jobIds=getOrderedJobIds();
    if(jobIds.length){
      jobIds.forEach(function(jid){
        var j=jobs[jid];
        var dispIdx=getJobDisplayIndex(jid);

        // 未設定スキップ
        if(!j.routes || !j.routes.length){
          var empty=document.createElement('div');
          empty.className='kpi-card';
          empty.innerHTML='<div class="kpi-head"><strong>Job'+dispIdx+'</strong><span class="kpi-sub">Route未設定</span></div>';
          statusBlockEl.appendChild(empty);
          return;
        }

        // 車体
        var firstR=routes[j.routes[0]];
        var agv=firstR ? firstR.agv : '-';

        var sum=calcJobTotal(j);

        // Job合計時間（理論）＝sum.total_s
        var jobTime = sum.total_s;

        // 実効搬送量(/h)
        var jobThroughputEff = (jobTime>0) ? (3600/jobTime)*av.avail : 0;

        // 内訳比率
        var pills = ratioPills(sum);

        var card=document.createElement('div');
        card.className='kpi-card';

        var head=document.createElement('div');
        head.className='kpi-head';
        head.innerHTML='<strong>Job'+dispIdx+'（'+agv+'）</strong>'
          + '<span class="kpi-sub">'+formatJobRoutes(j)+'</span>';
        card.appendChild(head);

        var metrics=document.createElement('div');
        metrics.className='kpi-metrics';
        metrics.innerHTML =
          '<div class="summary-line"><span>合計距離</span><span>'+sum.dist_m.toFixed(1)+'m</span></div>'
          +'<div class="summary-line"><span>Job合計時間（理論値）</span><span><b>'+jobTime.toFixed(1)+'s</b></span></div>'
          +'<div class="summary-line"><span>実効 Job搬送量</span><span><b>'+jobThroughputEff.toFixed(2)+'/h</b></span></div>'
          +'<div class="note" style="margin-top:4px;">※実効搬送量 = (3600 ÷ Job合計時間) × 稼働率</div>';
        card.appendChild(metrics);

        var ratio=document.createElement('div');
        ratio.className='ratio-row';
        pills.forEach(function(p){
          var sp=document.createElement('span');
          sp.className='pill';
          sp.textContent = p.k+' '+p.v+'%';
          ratio.appendChild(sp);
        });
        card.appendChild(ratio);

        statusBlockEl.appendChild(card);
      });
    }else{
      var none=document.createElement('div');
      none.className='kpi-card';
      none.innerHTML='<div class="kpi-head"><strong>Job</strong><span class="kpi-sub">Job無し</span></div>';
      statusBlockEl.appendChild(none);
    }
  }

  /* ========================
     入力（ルート編集 / 待機点 / パン / ズーム）
  =========================*/
  function updateCursor(){
    canvas.style.cursor = anyBuilding()? 'crosshair' : 'grab';
  }

  function onCanvasClick(e){
    var r=routes[activeRouteId];
    if(r && r.building){
      var s=clientToCanvasXY(e.clientX,e.clientY), w=screenToWorld(s.x,s.y);
      var xy=[Math.round(w.x/GRID)*GRID, Math.round(w.y/GRID)*GRID];

      if(r.points.length>0){
        var a={x:r.points[r.points.length-1][0], y:r.points[r.points.length-1][1]};
        if(approx(a.x,xy[0])&&approx(a.y,xy[1])) return;
        if(!approx(a.x,xy[0]) && !approx(a.y,xy[1])){ toast('直前の点と水平/垂直にしてください'); return; }
      }
      r.points.push(xy);
      drawAll();
    }
  }

  function onCanvasDblClick(e){
    var r=routes[activeRouteId];
    if(!r || !r.building) return;
    e.preventDefault();

    var s=clientToCanvasXY(e.clientX,e.clientY), w=screenToWorld(s.x,s.y);
    var xy=[Math.round(w.x/GRID)*GRID, Math.round(w.y/GRID)*GRID];

    var base=polylineFromPoints(r);
    if(base.length<2){ toast('先にポイントを2点以上追加してください'); return; }

    var snapped=projectToPolyline(xy, base, SNAP_TOL);
    if(!snapped){ toast('S/G/待機点はルート線上に設定してください'); return; }
    var sxy=[snapped.x, snapped.y];

    // Shift + ダブルクリック => 待機点
    if(e.shiftKey){
      var sec=prompt('待機時間[s] を入力してください（例：3）', '3');
      if(sec===null) return;
      var v=parseFloat(sec);
      if(!isFinite(v) || v<0) v=0;
      r.waitPoints = r.waitPoints || [];
      r.waitPoints.push({ x:sxy[0], y:sxy[1], sec:v });
      toast('待機点を追加しました');
      drawAll();
      return;
    }

    // 通常ダブルクリック => S / G
    // バグ対策：既存のS/Gに近い場合でも必ずスナップした座標を採用
    if(!r.start){
      r.start=sxy;
      toast('S を設定');
      drawAll();
      return;
    }
    if(!r.goal){
      r.goal=sxy;
      toast('G を設定');
      drawAll();
      return;
    }
    toast('S/G は既に設定済み（削除して再設定できます）');
  }

  function onMouseDown(e){
    if(anyBuilding()) return;

    // 画像ドラッグ優先
    var itSel=getSelectedImage();
    if(itSel){
      var pick=pickImage(e.clientX, e.clientY);
      if(pick && pick.it.id===itSel.id){
        imgDrag.active=true;
        imgDrag.mode=pick.mode;
        imgDrag.start=clientToCanvasXY(e.clientX,e.clientY);
        imgDrag.keepAR=!e.shiftKey;
        imgDrag.base={ x:itSel.x, y:itSel.y, w:itSel.w, h:itSel.h };
        e.preventDefault();
        return;
      }
    }

    // パン
    view.dragging=true;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.dragStart=s;
    view.startOffset={ x:view.offsetX, y:view.offsetY };
    canvas.style.cursor='grabbing';
    e.preventDefault();
  }

  function onMouseMove(e){
    // 画像
    if(imgDrag.active && selectedImgId){
      var it=getSelectedImage();
      if(!it) return;
      var cur=clientToCanvasXY(e.clientX,e.clientY);
      var dx=(cur.x-imgDrag.start.x)/view.scale;
      var dy=(cur.y-imgDrag.start.y)/view.scale;

      if(imgDrag.mode==='move'){
        it.x=imgDrag.base.x+dx;
        it.y=imgDrag.base.y+dy;
      }else{
        var bx=imgDrag.base.x, by=imgDrag.base.y, bw=imgDrag.base.w, bh=imgDrag.base.h;
        var ar=bw/Math.max(1e-6,bh);
        var nx=bx, ny=by, nw=bw, nh=bh;

        if(imgDrag.mode==='nw'){ nx=bx+dx; ny=by+dy; nw=bw-dx; nh=bh-dy; }
        else if(imgDrag.mode==='ne'){ ny=by+dy; nw=bw+dx; nh=bh-dy; }
        else if(imgDrag.mode==='sw'){ nx=bx+dx; nw=bw-dx; nh=bh+dy; }
        else if(imgDrag.mode==='se'){ nw=bw+dx; nh=bh+dy; }

        nw=Math.max(10,nw); nh=Math.max(10,nh);
        if(imgDrag.keepAR){
          if(Math.abs(nw-bw) > Math.abs(nh-bh)) nh=nw/ar;
          else nw=nh*ar;
          if(imgDrag.mode==='nw'){ nx=bx+(bw-nw); ny=by+(bh-nh); }
          if(imgDrag.mode==='ne'){ ny=by+(bh-nh); }
          if(imgDrag.mode==='sw'){ nx=bx+(bw-nw); }
        }
        it.x=nx; it.y=ny; it.w=nw; it.h=nh;
      }
      drawAll();
      return;
    }

    // パン
    if(!view.dragging) return;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.offsetX=view.startOffset.x + (s.x - view.dragStart.x);
    view.offsetY=view.startOffset.y + (s.y - view.dragStart.y);
    clampOffsets();
    drawAll();
  }

  function onMouseUp(){
    if(imgDrag.active){
      imgDrag.active=false; imgDrag.mode=null;
      return;
    }
    if(!view.dragging) return;
    view.dragging=false;
    updateCursor();
  }

  function zoomAt(newScale, clientX, clientY){
    newScale=clamp(newScale, view.min, view.max);
    var s=clientToCanvasXY(clientX,clientY);
    var w=screenToWorld(s.x,s.y);
    view.scale=newScale;
    var scr=worldToScreen(w.x,w.y);
    view.offsetX += (s.x - scr.x);
    view.offsetY += (s.y - scr.y);
    clampOffsets();
    drawAll();
  }

  function onWheel(e){
    if(anyBuilding()) return;
    e.preventDefault();
    var factor=(e.deltaY<0)?1.1:0.9;
    zoomAt(view.scale*factor, e.clientX, e.clientY);
  }

  function onKeyDown(e){
    if(e.key==='Delete' || e.key==='Backspace'){
      var it=getSelectedImage();
      if(it){
        images=images.filter(function(x){ return x.id!==it.id; });
        selectedImgId=null;
        renderImageList();
        drawAll();
        e.preventDefault();
      }
    }else if(e.key==='Escape'){
      if(selectedImgId){
        selectedImgId=null;
        renderImageList();
        drawAll();
      }
    }
  }

  /* ========================
     保存/読込/PNG
  =========================*/
  function onExport(){
    // 画像はメタのみ（bitmapは含めない）
    var imgMeta=images.map(function(it){
      return { id:it.id, name:it.name, x:it.x, y:it.y, w:it.w, h:it.h, opacity:it.opacity };
    });

    var data={
      routes: routes,
      jobs: jobs,
      vehicles: vehicles,
      images: imgMeta,
      meta:{ pxPerM:PX_PER_M, world:WORLD, ts:Date.now() }
    };
    var blob=new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    var a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='agv_simulator_final.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function onImport(evt){
    var file=evt.target.files && evt.target.files[0];
    if(!file) return;
    var reader=new FileReader();
    reader.onload=function(){
      try{
        var obj=JSON.parse(reader.result);

        if(obj.meta && obj.meta.world) WORLD=obj.meta.world;

        // vehicles
        if(obj.vehicles) vehicles=obj.vehicles;

        // routes
        routes={};
        if(obj.routes){
          Object.keys(obj.routes).forEach(function(k){ routes[+k]=obj.routes[k]; });
        }
        nextRouteId=(Math.max(0, ...Object.keys(routes).map(function(k){ return +k; })) || 0)+1;

        // jobs
        jobs={};
        if(obj.jobs){
          Object.keys(obj.jobs).forEach(function(k){ jobs[+k]=obj.jobs[k]; });
        }
        nextJobId=(Math.max(0, ...Object.keys(jobs).map(function(k){ return +k; })) || 0)+1;

        // images meta only
        images=[];
        if(Array.isArray(obj.images) && obj.images.length){
          toast('JSON内の画像はメタのみ復元（画像データは含まれません）');
          obj.images.forEach(function(m){
            images.push({
              id:m.id||(nextImgId++),
              name:m.name||'image',
              bitmap:null,
              x:m.x||40, y:m.y||40, w:m.w||200, h:m.h||200,
              opacity:(typeof m.opacity==='number'?m.opacity:1)
            });
            nextImgId=Math.max(nextImgId, (m.id||0)+1);
          });
        }

        // active
        var ids=getOrderedRouteIds();
        activeRouteId=ids.length?ids[0]:null;

        renderVehiclesUI();
        renderRoutesUI();
        renderJobsUI();
        renderImageList();
        validateJobs();

        clampOffsets(); drawAll(); updateCursor();
      }catch(err){
        toast('読み込みエラー: '+err.message);
      }
    };
    reader.readAsText(file);
  }

  function onExportPNG(){
    drawAll();
    canvas.toBlob(function(blob){
      var a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='agv_simulator_final.png';
      a.click();
      setTimeout(function(){ URL.revokeObjectURL(a.href); },0);
    }, 'image/png');
  }

  /* ========================
     シミュレーション（Job繰返し・車体ごと）
     - Routeは片道S->G
     - JobのRoute列を順に実行
     - 最後→最初に戻り無限リピート
     - Route間は heading差分で 90/180/270 の旋回を挿入（連続動作）
  =========================*/
  function buildSimForAgv(agv, jobId){
    var job=jobs[jobId];
    if(!job || !job.routes || !job.routes.length) return null;

    // 全Route同一AGV検証は validateJobs() で済んでいる前提
    var firstRouteId=job.routes[0];
    var r0=routes[firstRouteId];
    if(!r0 || r0.agv!==agv) return null;

    var sg=sgSubpathAndMeters(r0);
    if(!sg.path || sg.path.length<2) return null;

    var heading0=headingOf(sg.path[0], sg.path[1]);

    return {
      agv:agv,
      jobId:jobId,
      routeIdx:0,                 // job.routes index
      currentRouteId:firstRouteId,
      path:sg.path,
      segIndex:0,
      pos:{ x:sg.path[0].x, y:sg.path[0].y },
      heading:heading0,

      phase:'move',               // move / dwellLoad / dwellUnload / wait / turn / routeSwitch
      vtime_ms:0,
      lastRealTs:performance.now(),

      // dwell & wait
      dwellEndV:null,
      waitQueue:[],               // 待機点のキュー（このRoute内）
      nextWaitIdx:0,              // waitPoints参照

      // turn
      turnQueue:[],
      turnStartHeading:null,
      targetHeading:null,
      turnStartV:null,
      turnEndV:null,
      turnDuration:null,

      // speed
      pixPerSec: (Math.max(0.01, (vehicles[agv] ? +vehicles[agv].speed : 1.0))) * PX_PER_M
    };
  }

  function makeWaitQueueForRoute(r){
    // waitPoints を path上の進行順に並べ替える（S->Gの進行順）
    var sg=sgSubpathAndMeters(r);
    var path=sg.path;
    if(!path || path.length<2) return [];
    var base=path;

    function progOfXY(x,y){
      // 進行用のpath上でprogressを取る
      var pr=progressAlong(base, {x:x,y:y});
      return pr ? pr.s : null;
    }
    var arr=(r.waitPoints||[]).map(function(w){
      var s=progOfXY(w.x,w.y);
      return { x:w.x, y:w.y, sec:Math.max(0,+w.sec||0), s:(s==null?1e18:s) };
    }).filter(function(w){ return isFinite(w.s); }).sort(function(a,b){ return a.s-b.s; });

    return arr;
  }

  function startTurn(sim, deltaDeg){
    var turnS = (vehicles[sim.agv] ? +vehicles[sim.agv].turn : 0) || 0;
    if(turnS<=0 || deltaDeg===0){
      sim.heading = normHeading(sim.heading + deltaDeg);
      return false;
    }
    sim.turnQueue = buildTurnQueue(deltaDeg, turnS);
    if(!sim.turnQueue.length) return false;
    // 1セグメント開始
    var seg=sim.turnQueue.shift();
    sim.turnStartHeading = sim.heading;
    sim.targetHeading = normHeading(sim.heading + seg.delta);
    sim.turnStartV = sim.vtime_ms;
    sim.turnDuration = seg.duration;
    sim.turnEndV = sim.vtime_ms + seg.duration;
    sim.phase = 'turn';
    return true;
  }

  function continueTurn(sim){
    if(sim.phase!=='turn') return;
    if(sim.vtime_ms < sim.turnEndV){
      var ratio=clamp((sim.vtime_ms - sim.turnStartV)/sim.turnDuration, 0, 1);
      sim.heading = lerpAngle(sim.turnStartHeading, sim.targetHeading, ratio);
      return;
    }
    // セグメント完了
    sim.heading = sim.targetHeading;
    // 次のセグメントがあれば開始
    if(sim.turnQueue && sim.turnQueue.length){
      var seg=sim.turnQueue.shift();
      sim.turnStartHeading = sim.heading;
      sim.targetHeading = normHeading(sim.heading + seg.delta);
      sim.turnStartV = sim.vtime_ms;
      sim.turnDuration = seg.duration;
      sim.turnEndV = sim.vtime_ms + seg.duration;
      sim.phase='turn';
      return;
    }
    // 旋回完了
    sim.turnStartHeading=null; sim.targetHeading=null; sim.turnStartV=null; sim.turnDuration=null; sim.turnEndV=null;
    sim.phase='move';
  }

  function goNextRouteInJobRepeat(sim){
    var job=jobs[sim.jobId];
    if(!job || !job.routes || !job.routes.length) return false;

    // 次routeへ（最後→最初）
    sim.routeIdx = (sim.routeIdx + 1) % job.routes.length;
    var nextRid = job.routes[sim.routeIdx];
    var nextRoute = routes[nextRid];
    if(!nextRoute) return false;

    // 次ルートのpath
    var sg=sgSubpathAndMeters(nextRoute);
    if(!sg.path || sg.path.length<2) return false;

    // ★ここが「Jobを繋げて1つの動作にする」要点：向き合わせ旋回を挿入
    // 現在のheading -> 次ルートの開始heading
    var nextHeading = headingOf(sg.path[0], sg.path[1]);
    var d = angleDelta(sim.heading, nextHeading);
    if(d!==0){
      // 旋回を発生させる（90/180/270 の見た目）
      // 旋回完了後にルートを切り替えるため、一旦 pending を保持
      sim.pendingRouteSwitch = { rid: nextRid, path: sg.path, nextHeading: nextHeading };
      sim.phase = 'routeSwitch';
      // routeSwitch中にturnを始める
      startTurn(sim, d);
      return true;
    }

    // 旋回不要なら即切替
    sim.currentRouteId = nextRid;
    sim.path = sg.path;
    sim.segIndex = 0;
    sim.pos = { x: sg.path[0].x, y: sg.path[0].y };
    sim.heading = nextHeading;

    // 待機キュー更新
    sim.waitQueue = makeWaitQueueForRoute(nextRoute);
    sim.nextWaitIdx = 0;

    // ルート開始で荷積み
    var loadS = Math.max(0, +nextRoute.loadS||0);
    if(loadS>0){
      sim.phase='dwellLoad';
      sim.dwellEndV = sim.vtime_ms + loadS*1000;
    }else{
      sim.phase='move';
    }
    return true;
  }

  function finishRouteSwitchIfNeeded(sim){
    // routeSwitch中で旋回が終わったら切替
    if(sim.phase==='routeSwitch'){
      // continueTurn で phase が move になったタイミングで切替
      if(sim.turnStartHeading===null && sim.pendingRouteSwitch){
        var p=sim.pendingRouteSwitch;
        sim.pendingRouteSwitch=null;

        sim.currentRouteId = p.rid;
        sim.path = p.path;
        sim.segIndex = 0;
        sim.pos = { x: p.path[0].x, y: p.path[0].y };
        sim.heading = p.nextHeading;

        var r=routes[p.rid];
        sim.waitQueue = makeWaitQueueForRoute(r);
        sim.nextWaitIdx = 0;

        var loadS = Math.max(0, +r.loadS||0);
        if(loadS>0){
          sim.phase='dwellLoad';
          sim.dwellEndV = sim.vtime_ms + loadS*1000;
        }else{
          sim.phase='move';
        }
      }
    }
  }

  function maybeStartWaitAtCurrentPos(sim){
    // 次の待機点が近いなら待機に入る（segIndex/posからprogress推定）
    var r=routes[sim.currentRouteId];
    if(!r) return false;
    if(!sim.waitQueue || !sim.waitQueue.length) return false;
    if(sim.nextWaitIdx >= sim.waitQueue.length) return false;

    var wp=sim.waitQueue[sim.nextWaitIdx];
    // 到達判定（グリッド単位で近ければOK）
    if(Math.abs(sim.pos.x - wp.x) <= EPS && Math.abs(sim.pos.y - wp.y) <= EPS){
      if(wp.sec>0){
        sim.phase='wait';
        sim.dwellEndV = sim.vtime_ms + wp.sec*1000;
      }
      sim.nextWaitIdx++;
      return true;
    }
    return false;
  }

  function onSimToggle(){
    if(simRunning){
      simRunning=false;
      simByAgv={};
      simulateBtn.textContent='シミュレーション開始（Job繰返し・全車体同時）';
      drawAll();
      return;
    }

    // エラーがあれば起動しない
    if(!validateJobs()){
      toast('Jobの車体不一致を修正してください');
      return;
    }

    // 車体ごとに「担当Job」を決める（同一AGVのJobが複数ある場合は上から最初を採用）
    // ※必要なら後で「車体→Job割当」UIを追加できます
    var agvToJob={};
    getOrderedJobIds().forEach(function(jid){
      var j=jobs[jid];
      if(!j.routes || !j.routes.length) return;
      var r=routes[j.routes[0]];
      if(!r) return;
      var agv=r.agv;
      if(!agvToJob[agv]) agvToJob[agv]=jid;
    });

    simByAgv={};
    var any=false;

    Object.keys(agvToJob).forEach(function(agv){
      var s=buildSimForAgv(agv, agvToJob[agv]);
      if(!s) return;

      // 初期ルート荷積み
      var r0=routes[s.currentRouteId];
      s.waitQueue = makeWaitQueueForRoute(r0);
      s.nextWaitIdx = 0;

      var loadS = Math.max(0, +r0.loadS||0);
      if(loadS>0){
        s.phase='dwellLoad';
        s.dwellEndV = s.vtime_ms + loadS*1000;
      }
      simByAgv[agv]=s;
      any=true;
    });

    if(!any){
      toast('有効なJobがありません（JobにRouteを設定し、S/Gを設定してください）');
      return;
    }

    simRunning=true;
    simulateBtn.textContent='シミュレーション停止';
    requestAnimationFrame(stepSimAll);
  }

  function stepSimAll(tsReal){
    if(!simRunning) return;

    Object.keys(simByAgv).forEach(function(agv){
      var sim=simByAgv[agv];
      if(!sim) return;

      var dtReal=(tsReal - sim.lastRealTs)/1000;
      sim.lastRealTs=tsReal;

      var dtScaled=dtReal*currentSpeed();
      sim.vtime_ms += dtScaled*1000;

      // routeSwitch/turn 継続
      if(sim.phase==='turn'){
        continueTurn(sim);
        // routeSwitchなら完了後に切替
        finishRouteSwitchIfNeeded(sim);
        return;
      }

      // dwell / wait
      if(sim.phase==='dwellLoad' || sim.phase==='dwellUnload' || sim.phase==='wait'){
        if(sim.vtime_ms >= sim.dwellEndV){
          sim.dwellEndV=null;
          sim.phase='move';
        }else{
          return;
        }
      }

      // routeSwitch（旋回開始前の状態はないが、保険）
      if(sim.phase==='routeSwitch'){
        // turn開始しているはず
        return;
      }

      // move
      var r=routes[sim.currentRouteId];
      if(!r) return;
      var sg=sgSubpathAndMeters(r);
      var path=sim.path;

      // 安全：pathが無効なら再生成
      if(!path || path.length<2){
        if(sg.path && sg.path.length>=2){
          sim.path=sg.path;
          path=sim.path;
          sim.segIndex=0;
          sim.pos={x:path[0].x,y:path[0].y};
          sim.heading=headingOf(path[0],path[1]);
        }else{
          return;
        }
      }

      // 待機点に到達していれば待機開始
      if(maybeStartWaitAtCurrentPos(sim)){
        return;
      }

      // 移動処理
      var pixPerSec = sim.pixPerSec;
      var move = pixPerSec * dtScaled;

      var aIdx=sim.segIndex;
      var bIdx=aIdx+1;

      if(bIdx>=path.length){
        // ルート終端：荷下ろし
        var unloadS=Math.max(0, +r.unloadS||0);
        if(unloadS>0){
          sim.phase='dwellUnload';
          sim.dwellEndV = sim.vtime_ms + unloadS*1000;
          // 荷下ろし後に次ルートへ
          // dwell完了した次フレームで move に戻るので、その時点で次ルートへ切替え
          sim.afterUnloadGoNext = true;
          return;
        }else{
          // 直ちに次ルートへ
          goNextRouteInJobRepeat(sim);
          return;
        }
      }

      // 荷下ろし後の遷移フラグ
      if(sim.afterUnloadGoNext){
        sim.afterUnloadGoNext=false;
        goNextRouteInJobRepeat(sim);
        return;
      }

      var A=path[aIdx], B=path[bIdx];
      var desiredHeading=headingOf(A,B);
      var d=angleDelta(sim.heading, desiredHeading);
      if(d!==0){
        // セグメント進行方向への旋回
        if(startTurn(sim, d)) return;
        sim.heading=desiredHeading;
      }

      // 直交移動
      if(!approx(A.x,B.x)){
        var dirx=Math.sign(B.x - sim.pos.x);
        var remain=Math.abs(B.x - sim.pos.x);
        if(move>=remain){
          sim.pos.x=B.x; sim.pos.y=B.y;
          sim.segIndex=bIdx;
        }else{
          sim.pos.x += dirx*move;
        }
      }else{
        var diry=Math.sign(B.y - sim.pos.y);
        var remainy=Math.abs(B.y - sim.pos.y);
        if(move>=remainy){
          sim.pos.x=B.x; sim.pos.y=B.y;
          sim.segIndex=bIdx;
        }else{
          sim.pos.y += diry*move;
        }
      }

      // 到達時に待機点判定
      maybeStartWaitAtCurrentPos(sim);

      // 末端に到達していたら次のtickで処理される
      if(sim.segIndex >= path.length-1){
        // 次フレームでbIdx>=lenとなり処理される
      }
    });

    drawAll();
    requestAnimationFrame(stepSimAll);
  }

  /* ========================
     ready
  =========================*/
  function ready(){
    canvas=document.getElementById('map');
    ctx=canvas.getContext('2d');
    toastEl=document.getElementById('toast');
    bannerEl=document.getElementById('banner');

    panXEl=document.getElementById('panX');
    panYEl=document.getElementById('panY');

    zoomLabelEl=document.getElementById('zoomLabel');
    speedLabelEl=document.getElementById('speedLabel');
    speedDecBtn=document.getElementById('speedDec');
    speedIncBtn=document.getElementById('speedInc');

    routesListEl=document.getElementById('routesList');
    addRouteBtn=document.getElementById('addRoute');
    removeRouteBtn=document.getElementById('removeRoute');

    jobsListEl=document.getElementById('jobsList');
    addJobBtn=document.getElementById('addJobBtn');
    removeJobBtn=document.getElementById('removeJobBtn');

    undoBtn=document.getElementById('undo');
    clearBtn=document.getElementById('clear');
    simulateBtn=document.getElementById('simulateToggle');

    vehiclesEl=document.getElementById('vehicles');

    exportBtn=document.getElementById('exportBtn');
    importBtn=document.getElementById('importBtn');
    importFile=document.getElementById('importFile');
    exportPngBtn=document.getElementById('exportPngBtn');

    statusBlockEl=document.getElementById('statusBlock');
    chargePctEl=document.getElementById('chargePct');
    safetyPctEl=document.getElementById('safetyPct');

    pasteHintBtn=document.getElementById('pasteHintBtn');
    clearImagesBtn=document.getElementById('clearImagesBtn');
    imgOpacityEl=document.getElementById('imgOpacity');
    imgOpacityLabelEl=document.getElementById('imgOpacityLabel');
    imgListEl=document.getElementById('imgList');

    // 初期データ
    createRoute();
    createJob();
    validateJobs();

    // UI描画
    renderVehiclesUI();
    renderRoutesUI();
    renderJobsUI();
    renderImageList();

    // イベント
    addRouteBtn.addEventListener('click', function(){
      createRoute();
      renderRoutesUI();
      renderJobsUI();
      validateJobs();
      drawAll();
      updateCursor();
    });
    removeRouteBtn.addEventListener('click', removeLastRoute);

    addJobBtn.addEventListener('click', function(){
      createJob();
      renderJobsUI();
      validateJobs();
      drawAll();
    });
    removeJobBtn.addEventListener('click', function(){
      var ids=getOrderedJobIds();
      if(!ids.length) return;
      delete jobs[ids[ids.length-1]];
      renderJobsUI();
      validateJobs();
      drawAll();
    });

    undoBtn.addEventListener('click', function(){
      var r=routes[activeRouteId];
      if(!r) return;
      r.points.pop();
      drawAll();
    });

    clearBtn.addEventListener('click', function(){
      var r=routes[activeRouteId];
      if(!r) return;
      r.points.length=0; r.start=null; r.goal=null; r.waitPoints=[];
      drawAll();
    });

    simulateBtn.addEventListener('click', onSimToggle);

    exportBtn.addEventListener('click', onExport);
    importBtn.addEventListener('click', function(){ importFile.click(); });
    importFile.addEventListener('change', onImport);
    exportPngBtn.addEventListener('click', onExportPNG);

    chargePctEl.addEventListener('change', drawAll);
    safetyPctEl.addEventListener('change', drawAll);

    pasteHintBtn.addEventListener('click', function(){
      toast('スクリーンショットを撮って Ctrl+V で貼り付けできます');
    });

    clearImagesBtn.addEventListener('click', function(){
      images=[]; selectedImgId=null; renderImageList(); drawAll();
    });

    imgOpacityEl.addEventListener('input', function(){
      var it=getSelectedImage();
      imgOpacityLabelEl.textContent=this.value+'%';
      if(!it) return;
      it.opacity=clamp((+this.value)/100, 0, 1);
      drawAll();
    });

    speedDecBtn.addEventListener('click', function(){
      speedIndex=Math.max(0, speedIndex-1);
      drawAll();
    });
    speedIncBtn.addEventListener('click', function(){
      speedIndex=Math.min(SPEED_STEPS.length-1, speedIndex+1);
      drawAll();
    });

    window.addEventListener('resize', resize);

    canvas.addEventListener('click', onCanvasClick, {passive:true});
    canvas.addEventListener('dblclick', onCanvasDblClick, {passive:false});
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel, {passive:false});

    window.addEventListener('keydown', function(e){
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){
        var r=routes[activeRouteId];
        if(!r) return;
        r.points.pop();
        drawAll();
      }else{
        onKeyDown(e);
      }
    });

    // 画像貼り付け
    window.addEventListener('paste', function(e){
      handlePasteImageFromClipboard(e);
    });

    panXEl.addEventListener('input', updateViewFromPanSliders);
    panYEl.addEventListener('input', updateViewFromPanSliders);

    resize();
    setActiveRoute(activeRouteId);
    updateCursor();
    drawAll();
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', ready);
  }else{
    ready();
  }
})();
</script>
</body>
</html>
