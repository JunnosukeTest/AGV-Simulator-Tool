<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - Job(複数Route) / 片道Route KPI + Job KPI / 画像(Paste)レイヤ</title>
<style>
  :root{
    --brand:#006666; --panel:#004d4d; --grid:#e6e6e6; --panelThin:#003c3c;
    --scrollTrack:#e0e5e5; --scrollThumb:#ffffff;
  }
  *{ box-sizing:border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  html,body{ height:100%; }
  body{ margin:0; display:flex; height:100vh; overflow:hidden; background:#fff; }

  /* ==== サイドバー ==== */
  .sidebar{
    width:520px; flex-shrink:0; color:#fff; background:var(--brand);
    padding:12px 14px; display:flex; flex-direction:column; gap:12px;
    overflow-y:auto; overflow-x:hidden;
  }
  h1{ font-size:18px; margin:6px 0 8px; font-weight:700; }
  .section{ background:var(--panel); border-radius:10px; padding:10px; }
  .row{ display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap; }
  .btn{ cursor:pointer; border:none; border-radius:8px; padding:6px 8px; font-weight:700; font-size:13px; }
  .btn.primary{ background:#fff; color:var(--brand); }
  .btn.ghost{ background:transparent; border:1px solid #fff; color:#fff; }
  .btn.slim{ padding:4px 8px; font-size:12px; border-radius:8px; }
  .status{ background:#003d3d; padding:8px; border-radius:8px; font-size:13px; line-height:1.4; }
  .note{ font-size:12px; opacity:.9; }
  .small{ font-size:12px; }

  /* ==== キャンバス ==== */
  .canvas-wrap{ position:relative; flex:1; background:#fff; min-width:260px; }
  canvas#map{ position:absolute; inset:0; width:100%; height:100%; display:block; }

  /* オーバーレイUI（右上：倍速 / 左下：ズーム倍率表示） */
  .canvas-ui{ position:absolute; display:flex; align-items:center; gap:8px; }
  .ui-top-right{ top:8px; right:8px; background:rgba(0,0,0,.55); color:#fff; padding:6px 8px; border-radius:10px; z-index:6; }
  .ui-bottom-left{ left:8px; bottom:28px; background:rgba(0,0,0,.55); color:#fff; padding:4px 8px; border-radius:8px; font-size:12px; pointer-events:none; z-index:6; }
  .speed-btn{ cursor:pointer; border:none; width:28px; height:28px; border-radius:8px; background:#fff; color:#333; font-weight:800; display:grid; place-items:center; }
  .speed-label{ min-width:44px; text-align:center; font-weight:700; }

  .routes-list, .jobs-list{ display:flex; flex-direction:column; gap:8px; }

  .route-item{
    background:#003c3c; border-radius:8px; padding:8px;
    display:grid;
    grid-template-columns: 1fr auto auto auto;
    gap:8px; align-items:center;
  }
  .route-name{ font-weight:700; }
  .route-toggle{ min-width:120px; }

  .job-item{
    background:#003c3c; border-radius:8px; padding:8px;
    display:flex; flex-direction:column; gap:6px;
  }
  .job-head{ display:flex; align-items:center; gap:8px; justify-content:space-between; }
  .job-title{ font-weight:800; }
  .job-controls{ display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
  .job-routes{ display:flex; flex-direction:column; gap:6px; }
  .job-route-row{
    background:#023a3a; border-radius:8px; padding:6px 8px;
    display:grid; grid-template-columns: 1fr auto auto auto; gap:6px; align-items:center;
  }

  .toast{ position:fixed; left:50%; top:18px; transform:translateX(-50%); background:#333; color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transition:opacity .2s ease; pointer-events:none; z-index:9; }
  .toast.show{ opacity:.95; }
  .sim-btn{ min-width:260px; }

  /* 車体（180°旋回追加で列増やす） */
  .vehicle-grid{
    display:grid;
    grid-template-columns: 56px 68px 74px 74px 76px 76px 88px;
    gap:6px; align-items:center; justify-items:start;
  }
  .vehicle-grid .head{ font-weight:700; opacity:.9; }
  .vehicle-grid input{ width:64px; padding:2px 3px; font-size:12px; }

  .summary-line{ display:flex; justify-content:space-between; gap:8px; }
  .summary-block{ background:#012f2f; border-radius:8px; padding:8px; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

  /* 稼働率バー */
  .avail-bar{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.25);
    overflow:hidden;
    margin-top:6px;
  }
  .avail-bar > div{
    height:100%;
    background:#ffffff;
    width:0%;
    transition: width .15s ease;
  }

  /* 画像レイヤUI */
  .img-controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .img-list{ display:flex; flex-direction:column; gap:6px; margin-top:8px; }
  .img-item{ background:#003c3c; border-radius:8px; padding:6px 8px; display:grid; grid-template-columns: 1fr auto auto; gap:8px; align-items:center; }
  .img-item strong{ font-weight:700; }
  .slider-row{ margin-top:8px; display:flex; align-items:center; gap:8px; }
  .slider-row input[type="range"]{ flex:1; }

  /* ==== パン（矢印アイコン：上下/左右）==== */
  .pan-pad{
    position:absolute; z-index:7;
    display:flex; gap:6px;
    background:rgba(0,0,0,.55);
    padding:6px; border-radius:12px;
  }
  .pan-pad-y{ right:8px; top:52px; flex-direction:column; }
  .pan-pad-x{ left:8px; bottom:6px; }
  .pan-btn{
    cursor:pointer; border:none;
    width:28px; height:28px;
    border-radius:8px; background:#fff; color:#333;
    font-weight:800; display:grid; place-items:center;
    user-select:none;
  }
  .pan-btn:active{ transform: translateY(1px); }

  /* 小さめ入力（ルート用） */
  .rmini{ width:66px; padding:2px 3px; font-size:12px; }
  .rmini2{ width:54px; padding:2px 3px; font-size:12px; }

  /* 内訳比率バー（Job用） */
  .mixbar{
    height:10px; border-radius:999px; overflow:hidden;
    background:rgba(255,255,255,.18);
    display:flex;
    margin-top:4px;
  }
  .mixseg{ height:100%; }
</style>
</head>

<body>
  <aside class="sidebar">
    <h1>AGV Simulator（Route=片道 / Job=連結）</h1>

    <div class="section">
      <div class="row"><strong>操作手順（Route/Job）</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>Routeを<b>＋</b>で追加 → ルートの<b>経路生成ON</b>だけ編集可</li>
        <li>交点クリックで <b>P1→P2→…</b>（水平/垂直）</li>
        <li>交点ダブルクリックで <b>S または G</b> 設定（線上なら途中でも端でもOK）</li>
        <li><b>Shift+ダブルクリック</b>で待機点追加（秒数入力可）</li>
        <li>Jobで Route を順番に並べると、連結して1つの動作としてシミュレーション</li>
        <li>画像は <b>Ctrl+V</b> で貼り付け（スクショ運用OK）</li>
      </ol>
    </div>

    <!-- 画像レイヤ -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>画像レイヤ（Paste推奨）</strong>
        <span class="note">グリッドは常に前面</span>
      </div>

      <div class="img-controls">
        <input id="imageFile" type="file" accept="image/*" />
        <button id="addImageBtn" class="btn primary">＋ 画像追加</button>
        <span class="note">Ctrl+V で貼り付け</span>
      </div>

      <div class="slider-row">
        <label class="small" for="imgOpacity" style="min-width:64px;">不透明度</label>
        <input id="imgOpacity" type="range" min="0" max="100" value="100" />
        <span id="imgOpacityLabel" class="small" style="min-width:40px; text-align:right;">100%</span>
      </div>

      <div class="note">
        操作：移動/リサイズは「選択ON」の画像のみ。四隅ドラッグ（Shiftで縦横比解除）／削除：Delete
      </div>
      <div id="imgList" class="img-list"></div>
    </div>

    <!-- Routes -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ルート一覧（片道）</strong>
        <span class="note">Route番号は小さい順の連番</span>
      </div>
      <div id="routesList" class="routes-list"></div>
      <div class="row">
        <button id="addRoute" class="btn primary">＋ ルート追加</button>
        <button id="removeRoute" class="btn ghost">− 最後のルート削除</button>
      </div>
      <div class="row">
        <button id="exportPngBtn" class="btn ghost slim" title="PNG書き出し">PNG</button>
        <button id="exportBtn" class="btn ghost">JSON書き出し</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn ghost">JSON読み込み</button>
      </div>
      <div class="note">
        Routeパラメータ：旋回数（90°換算）、荷積み回数、荷下ろし回数、待機点（複数）
      </div>
    </div>

    <!-- Jobs -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ジョブ一覧（連結して1動作）</strong>
        <span class="note">Job = [Route1 → Route2 → …]</span>
      </div>
      <div id="jobsList" class="jobs-list"></div>
      <div class="row">
        <button id="addJob" class="btn primary">＋ Job追加</button>
        <button id="removeJob" class="btn ghost">− 最後のJob削除</button>
      </div>
      <div class="note">
        ※Jobは車体（AGV）を持ちます。RouteのS/G点は「同一点でつなぐ」前提でもOK。
      </div>
    </div>

    <!-- Vehicles -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>車体一覧（A〜J）</strong>
        <span class="note">速度[m/s]・旋回90[s]・旋回180[s]・荷積[s]・荷下ろし[s]</span>
      </div>
      <div id="vehicles" class="vehicle-grid"></div>
    </div>

    <!-- Status -->
    <div class="section status">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ステータス（Route=片道 / Job=合計）</strong>
        <span class="note">1マス=1m</span>
      </div>

      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="chargePct">充電率ダウンタイム（0–30%）</label>
        <input id="chargePct" type="number" min="0" max="30" step="1" value="0" style="width:64px;"/>
        <span class="note">稼働率式：<span class="mono">(1-充電率)</span></span>
      </div>
      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="safetyPct">安全率（0–50%）</label>
        <input id="safetyPct" type="number" min="0" max="50" step="1" value="0" style="width:64px;"/>
        <span class="note">稼働率式：<span class="mono">×(1-安全率)</span></span>
      </div>

      <!-- ✅ 残す：稼働率バー -->
      <div class="summary-block">
        <div class="note">稼働率（Availability）</div>
        <div id="availLabel" style="font-weight:800;"></div>
        <div class="avail-bar" aria-label="稼働率バー"><div id="availBarFill"></div></div>
        <div class="note">計算式：<span class="mono">avail=(1-chargePct/100)*(1-safetyPct/100)</span></div>
      </div>

      <div class="summary-block" style="margin-top:8px;">
        <div class="note">Route（片道）</div>
        <div id="routesSummary" style="display:flex; flex-direction:column; gap:4px;"></div>
      </div>

      <div class="summary-block" style="margin-top:8px;">
        <div class="note">Job（各Job内Route連結）</div>
        <div id="jobsSummary" style="display:flex; flex-direction:column; gap:8px;"></div>
      </div>

      <!-- ❌ 合計ブロックは削除（誤解防止・冗長排除） -->
    </div>

    <div class="section">
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除（アクティブルート）</button>
      </div>
      <div class="row">
        <button id="clear" class="btn ghost">アクティブルート全消去</button>
      </div>
      <div class="row">
        <button id="simulateToggle" class="btn primary sim-btn">シミュレーション開始（Jobを連結して実行）</button>
      </div>
      <div class="note">Ctrl+Z でも1つ戻せます / Shift+ダブルクリック=待機点追加</div>
    </div>
  </aside>

  <!-- キャンバス -->
  <div class="canvas-wrap">
    <canvas id="map"></canvas>

    <!-- パン（矢印） -->
    <div class="pan-pad pan-pad-y" aria-label="上下スクロール">
      <button class="pan-btn" id="panUp" title="上へ">▲</button>
      <button class="pan-btn" id="panDown" title="下へ">▼</button>
    </div>
    <div class="pan-pad pan-pad-x" aria-label="左右スクロール">
      <button class="pan-btn" id="panLeft" title="左へ">◀</button>
      <button class="pan-btn" id="panRight" title="右へ">▶</button>
    </div>

    <div class="canvas-ui ui-top-right" id="speedBox">
      <button id="speedDec" class="speed-btn" title="速度を下げる">◀</button>
      <span class="speed-label" id="speedLabel">1×</span>
      <button id="speedInc" class="speed-btn" title="速度を上げる">▶</button>
    </div>
    <div class="canvas-ui ui-bottom-left"><span id="zoomLabel">100%</span></div>
  </div>

  <div id="toast" class="toast"></div>

<script defer>
(function(){
  /* ========================
     定数・状態
  =========================*/
  var PX_PER_M = 40, GRID = PX_PER_M;
  var EPS = 0.5;

  var SNAP_TOL = GRID * 0.6;
  var CLICK_SNAP_TOL = GRID * 0.45;
  var ROUTE_COLORS = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad','#16a085','#f39c12','#c0392b','#2980b9','#7f8c8d'];
  var WORLD = { width: 8000, height: 6000 };

  // 画像
  var images = [];
  var nextImgId = 1;
  var selectedImgId = null;
  var IMG_HANDLE = 10;
  var imgDrag = { active:false, mode:null, start:{x:0,y:0}, base:{x:0,y:0,w:0,h:0}, keepAR:true };

  // 速度表示（シム倍速）
  var SPEED_STEPS = [0.5, 1, 2, 4], speedIndex = 1;
  function currentSpeed(){ return SPEED_STEPS[speedIndex]; }

  // view
  var view = { scale:1.0, min:0.1, max:2.0, offsetX:0, offsetY:0, dragging:false, dragStart:{x:0,y:0}, startOffset:{x:0,y:0} };

  var canvas, ctx, toastEl, zoomLabelEl, speedLabelEl, speedDecBtn, speedIncBtn;
  var panUpBtn, panDownBtn, panLeftBtn, panRightBtn;

  // Routes
  var routes = {};
  var activeRouteId = null;
  var nextRouteId = 1;

  // Jobs
  var jobs = {};
  var activeJobId = null;
  var nextJobId = 1;

  // 車体（✅ 90/180 旋回時間を分ける）
  var vehicles = {};
  'ABCDEFGHIJ'.split('').forEach(function(ch){
    vehicles[ch] = { speed:1.0, turn90:2.0, turn180:4.0, loadTime:5, unloadTime:5 };
  });

  // simulation
  var simRunning = false;
  var jobSims = {};

  // DOM
  var routesListEl, addRouteBtn, removeRouteBtn;
  var jobsListEl, addJobBtn, removeJobBtn;
  var undoBtn, clearBtn, simulateBtn;
  var vehiclesEl, exportBtn, importBtn, importFile, exportPngBtn;
  var routesSummaryEl, jobsSummaryEl, availLabelEl, availBarFillEl;
  var chargePctEl, safetyPctEl;

  // image DOM
  var imageFileEl, addImageBtn, imgOpacityEl, imgOpacityLabelEl, imgListEl;

  /* Utils */
  function toast(msg){
    if(!toastEl) return;
    toastEl.textContent=msg;
    toastEl.classList.add('show');
    setTimeout(function(){ toastEl.classList.remove('show'); }, 1300);
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function approx(a,b,eps){ return Math.abs(a-b) <= (eps||EPS); }
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

  function clientToCanvasXY(clientX, clientY){
    var r=canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }
  function screenToWorld(sx, sy){ return { x: (sx - view.offsetX)/view.scale, y: (sy - view.offsetY)/view.scale }; }
  function worldToScreen(wx, wy){ return { x: wx*view.scale + view.offsetX, y: wy*view.scale + view.offsetY }; }

  function clampOffsets(){
    var minX = Math.min(0, canvas.width - WORLD.width * view.scale), maxX = 0;
    var minY = Math.min(0, canvas.height - WORLD.height * view.scale), maxY = 0;
    view.offsetX = clamp(view.offsetX, minX, maxX);
    view.offsetY = clamp(view.offsetY, minY, maxY);
  }

  function applyTransform(){ ctx.setTransform(view.scale,0,0,view.scale,view.offsetX,view.offsetY); }
  function resetTransform(){ ctx.setTransform(1,0,0,1,0,0); }

  function anyBuilding(){
    return Object.keys(routes).some(function(k){ return !!routes[k].building; });
  }

  function turnTimeForDeltaDeg(deltaDeg, veh){
    // angleDelta は -180..180 を想定して扱う
    var d = Math.abs(deltaDeg);
    if(d < 1e-6) return 0;
    if(d === 180) return Math.max(0, veh.turn180 || (veh.turn90||0)*2);
    return Math.max(0, veh.turn90 || 0); // 90
  }

  /* ========================
     画像レイヤ
  =========================*/
  async function fileToBitmapImageOnly(file){
    if(!file) return null;
    try{
      var url = URL.createObjectURL(file);
      var img = new Image();
      img.decoding='async';
      await new Promise(function(res,rej){
        img.onload=function(){ res(true); };
        img.onerror=function(){ rej(new Error('画像読み込み失敗')); };
        img.src=url;
      });
      var bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return { bitmap:bmp, width:bmp.width, height:bmp.height };
    }catch(e){
      toast('画像読み込み失敗: '+e.message);
      return null;
    }
  }

  function addImageLayer(name, bm, w, h){
    var targetW = Math.min( (canvas.width/ view.scale) * 0.6, w );
    var scale = targetW / w;
    var targetH = h * scale;
    images.push({ id: nextImgId++, name: name||'image', bitmap: bm, x:40, y:40, w:targetW, h:targetH, opacity:1.0 });
    renderImageList();
    drawAll();
  }

  function getSelectedImage(){
    return selectedImgId ? (images.find(function(it){ return it.id===selectedImgId; })||null) : null;
  }

  function renderImageList(){
    imgListEl.innerHTML = '';
    images.forEach(function(it){
      var div = document.createElement('div');
      div.className='img-item';

      var name = document.createElement('div');
      name.innerHTML = '<strong>#'+it.id+'</strong> <span class="small">'+escapeHtml(it.name)+'</span>';

      var toggle = document.createElement('button');
      toggle.className='btn route-toggle';
      var isOn = (selectedImgId === it.id);
      if(isOn){
        toggle.textContent='選択ON';
        toggle.style.background='#fff';
        toggle.style.color='#006666';
        toggle.style.border='none';
      }else{
        toggle.textContent='選択OFF';
        toggle.style.background='transparent';
        toggle.style.color='#fff';
        toggle.style.border='1px solid #fff';
      }
      toggle.addEventListener('click', function(e){
        e.stopPropagation();
        selectedImgId = (selectedImgId===it.id) ? null : it.id;
        if(selectedImgId===it.id){
          imgOpacityEl.value = Math.round(it.opacity*100);
          imgOpacityLabelEl.textContent=(Math.round(it.opacity*100))+'%';
        }
        renderImageList();
        drawAll();
      });

      var delBtn = document.createElement('button');
      delBtn.className='btn ghost';
      delBtn.textContent='削除';
      delBtn.addEventListener('click', function(e){
        e.stopPropagation();
        images = images.filter(function(x){ return x.id!==it.id; });
        if(selectedImgId===it.id) selectedImgId=null;
        renderImageList(); drawAll();
      });

      div.appendChild(name);
      div.appendChild(toggle);
      div.appendChild(delBtn);
      imgListEl.appendChild(div);
    });
  }

  function drawImages(){
    images.forEach(function(it){
      if(!it.bitmap) return;
      ctx.save();
      ctx.globalAlpha = clamp(it.opacity,0,1);
      ctx.drawImage(it.bitmap, it.x, it.y, it.w, it.h);
      ctx.restore();
    });

    if(selectedImgId){
      var it=getSelectedImage();
      if(it){
        ctx.save();
        ctx.lineWidth=1/view.scale;
        ctx.strokeStyle='#00bcd4';
        ctx.setLineDash([6/view.scale, 4/view.scale]);
        ctx.strokeRect(it.x,it.y,it.w,it.h);
        ctx.setLineDash([]);

        var handles=[
          {x:it.x,y:it.y},{x:it.x+it.w,y:it.y},
          {x:it.x,y:it.y+it.h},{x:it.x+it.w,y:it.y+it.h}
        ];
        ctx.fillStyle='#00bcd4';
        handles.forEach(function(h){
          ctx.beginPath();
          ctx.arc(h.x,h.y,IMG_HANDLE/view.scale,0,Math.PI*2);
          ctx.fill();
        });
        ctx.restore();
      }
    }
  }

  /* ========================
     Route幾何ユーティリティ
  =========================*/
  function getOrderedRouteIds(){
    return Object.keys(routes).map(function(k){ return +k; }).sort(function(a,b){ return a-b; });
  }
  function getDisplayRouteIndex(id){
    var ids=getOrderedRouteIds();
    var idx=ids.indexOf(id);
    return idx===-1? null : (idx+1);
  }

  function polylineFromPoints(r){
    if(!r || !r.points || r.points.length<2) return [];
    var clean=[];
    for(var i=0;i<r.points.length;i++){
      var p={x:r.points[i][0], y:r.points[i][1]};
      if(!clean.length){ clean.push(p); continue; }
      var a=clean[clean.length-1];

      if(approx(a.x,p.x) && approx(a.y,p.y)) continue;
      if(!approx(a.x,p.x) && !approx(a.y,p.y)) continue;

      if(clean.length>=2){
        var b=clean[clean.length-2];
        if(approx(b.x,a.x) && approx(a.x,p.x)){ clean[clean.length-1]=p; continue; }
        if(approx(b.y,a.y) && approx(a.y,p.y)){ clean[clean.length-1]=p; continue; }
      }
      clean.push(p);
    }
    return clean;
  }

  function segLenPx(A,B){
    return Math.abs(B.x-A.x) + Math.abs(B.y-A.y);
  }
  function totalLenPx(path){
    var S=0;
    for(var i=0;i<path.length-1;i++) S+=segLenPx(path[i], path[i+1]);
    return S;
  }

  function projectToPolyline(xy, path, tolPx){
    if(!path || path.length<2) return null;
    var tol=(tolPx||SNAP_TOL);
    var best=null, bestDist=Infinity;

    for(var i=0;i<path.length-1;i++){
      var A=path[i], B=path[i+1];

      if(approx(A.x,B.x)){
        var dx=Math.abs(xy[0]-A.x);
        if(dx<=tol){
          var y=clamp(xy[1], Math.min(A.y,B.y), Math.max(A.y,B.y));
          var d=dx + Math.abs(xy[1]-y);
          if(d<bestDist){
            bestDist=d;
            best={x:A.x,y:y,i:i};
          }
        }
      }
      else if(approx(A.y,B.y)){
        var dy=Math.abs(xy[1]-A.y);
        if(dy<=tol){
          var x=clamp(xy[0], Math.min(A.x,B.x), Math.max(A.x,B.x));
          var d=dy + Math.abs(xy[0]-x);
          if(d<bestDist){
            bestDist=d;
            best={x:x,y:A.y,i:i};
          }
        }
      }
    }

    if(!best){
      for(var k=0;k<path.length;k++){
        var P=path[k];
        var dist=Math.hypot((xy[0]-P.x),(xy[1]-P.y));
        if(dist<=tol && dist<bestDist){
          bestDist=dist;
          best={x:P.x,y:P.y,i:Math.max(0,k-1)};
        }
      }
    }
    return best;
  }

  function progressAlong(path, point){
    var proj=projectToPolyline([point.x, point.y], path, SNAP_TOL);
    if(!proj) return null;
    var s=0;
    for(var k=0;k<proj.i;k++) s += segLenPx(path[k], path[k+1]);
    s += segLenPx(path[proj.i], {x:proj.x, y:proj.y});
    return { s:s, pt:{x:proj.x, y:proj.y} };
  }

  function pointAtProgress(path, s){
    s=clamp(s,0,totalLenPx(path));
    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      if(acc + L >= s - EPS){
        var t=(s-acc)/L;
        var A=path[i], B=path[i+1];
        return approx(A.x,B.x)
          ? { x:A.x, y:A.y + (B.y-A.y)*t }
          : { x:A.x + (B.x-A.x)*t, y:A.y };
      }
      acc+=L;
    }
    return { x:path[path.length-1].x, y:path[path.length-1].y };
  }

  function clipPathByProgress(path, s0, s1){
    if(!path || path.length<2) return [];
    var a=Math.min(s0,s1), b=Math.max(s0,s1);
    if(b-a<EPS) return [];
    var out=[], P0=pointAtProgress(path,a), P1=pointAtProgress(path,b);
    out.push(P0);

    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      var accNext=acc+L;
      if(accNext>a+EPS && accNext<b-EPS){
        out.push({x:path[i+1].x, y:path[i+1].y});
      }
      acc=accNext;
    }
    out.push(P1);

    var clean=[];
    for(var m=0;m<out.length;m++){
      if(!clean.length){ clean.push(out[m]); continue; }
      var aP=clean[clean.length-1], bP=out[m];
      if(approx(aP.x,bP.x) && approx(aP.y,bP.y)) continue;
      clean.push(bP);
    }
    return clean;
  }

  function sgSubpathAndMeters(r){
    if(!r || !r.start || !r.goal) return {path:[], meters:0, sStart:null, sGoal:null, base:[]};
    var base=polylineFromPoints(r);
    if(!base.length) return {path:[], meters:0, sStart:null, sGoal:null, base:base};

    var prS=progressAlong(base,{x:r.start[0], y:r.start[1]});
    var prG=progressAlong(base,{x:r.goal[0], y:r.goal[1]});
    if(!prS||!prG) return {path:[], meters:0, sStart:null, sGoal:null, base:base};

    var sub=clipPathByProgress(base, prS.s, prG.s);
    var dist_m=Math.abs(prG.s-prS.s)/PX_PER_M;
    return { path:sub, meters:dist_m, sStart:prS.s, sGoal:prG.s, base:base };
  }

  /* ========================
     旋回
  =========================*/
  function headingOf(A,B){
    if(B.x>A.x) return 0;
    if(B.x<A.x) return 180;
    if(B.y>A.y) return 90;
    if(B.y<A.y) return 270;
    return 0;
  }
  function normHeading(h){ h=((h%360)+360)%360; return h; }
  function angleDelta(a,b){
    var d=((b-a+540)%360)-180;
    return Math.round(d);
  }
  function lerpAngle(a,b,t){
    var d=angleDelta(a,b);
    return a + d*t;
  }

  /* ========================
     描画
  =========================*/
  function drawGrid(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    var minW=(-view.offsetX)/view.scale, minH=(-view.offsetY)/view.scale;
    var maxW=(canvas.width - view.offsetX)/view.scale, maxH=(canvas.height - view.offsetY)/view.scale;

    applyTransform();
    ctx.fillStyle='#fff';
    ctx.fillRect(0,0,WORLD.width,WORLD.height);

    drawImages();

    ctx.strokeStyle='#e6e6e6';
    ctx.lineWidth=1/view.scale;

    var startX=Math.max(0, Math.floor(minW/GRID)*GRID);
    for(var x=startX; x<=Math.min(maxW, WORLD.width); x+=GRID){
      ctx.beginPath();
      ctx.moveTo(x, Math.max(0,minH));
      ctx.lineTo(x, Math.min(maxH, WORLD.height));
      ctx.stroke();
    }

    var startY=Math.max(0, Math.floor(minH/GRID)*GRID);
    for(var y=startY; y<=Math.min(maxH, WORLD.height); y+=GRID){
      ctx.beginPath();
      ctx.moveTo(Math.max(0,minW), y);
      ctx.lineTo(Math.min(maxW, WORLD.width), y);
      ctx.stroke();
    }
    resetTransform();
  }

  function drawRoutes(){
    applyTransform();

    var ordered=getOrderedRouteIds();
    ordered.forEach(function(id){
      var r=routes[id];
      var dispIdx=getDisplayRouteIndex(id);
      var base=polylineFromPoints(r);

      if(base.length>=2){
        ctx.lineWidth=2/view.scale;
        ctx.strokeStyle=r.color;
        ctx.globalAlpha=0.85;
        ctx.beginPath();
        ctx.moveTo(base[0].x, base[0].y);
        for(var i=1;i<base.length;i++) ctx.lineTo(base[i].x, base[i].y);
        ctx.stroke();
        ctx.globalAlpha=1;
      }

      for(var j=0;j<r.points.length;j++){
        var p=r.points[j];
        ctx.fillStyle=r.color;
        ctx.beginPath();
        ctx.arc(p[0],p[1],4/view.scale,0,Math.PI*2);
        ctx.fill();
      }

      ctx.fillStyle='#000';
      ctx.font=(16/view.scale)+'px system-ui, sans-serif';
      ctx.textBaseline='top';
      if(r.start) ctx.fillText('S'+dispIdx, r.start[0]-10/view.scale, r.start[1]-18/view.scale);
      if(r.goal)  ctx.fillText('G'+dispIdx, r.goal[0]-10/view.scale,  r.goal[1]-18/view.scale);

      if(Array.isArray(r.waits)){
        ctx.font=(13/view.scale)+'px system-ui, sans-serif';
        r.waits.forEach(function(wt,wi){
          ctx.fillStyle='#111';
          ctx.beginPath();
          ctx.arc(wt.xy[0], wt.xy[1], 5/view.scale, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle='#000';
          ctx.fillText('W'+dispIdx+'-'+(wi+1), wt.xy[0]+6/view.scale, wt.xy[1]-10/view.scale);
        });
      }
    });

    resetTransform();
  }

  function drawJobGuidesAndAGVs(){
    if(!simRunning) return;
    applyTransform();

    Object.keys(jobSims).forEach(function(jidStr){
      var sim=jobSims[jidStr];
      if(!sim || !sim.fullPath || sim.fullPath.length<2) return;

      ctx.save();
      ctx.lineCap='round';
      ctx.lineJoin='round';
      ctx.globalAlpha=0.20;
      ctx.lineWidth=14/view.scale;
      ctx.strokeStyle=sim.color;
      ctx.beginPath();
      ctx.moveTo(sim.fullPath[0].x, sim.fullPath[0].y);
      for(var i=1;i<sim.fullPath.length;i++) ctx.lineTo(sim.fullPath[i].x, sim.fullPath[i].y);
      ctx.stroke();

      ctx.globalAlpha=0.65;
      ctx.lineWidth=5/view.scale;
      ctx.strokeStyle=sim.color;
      ctx.beginPath();
      ctx.moveTo(sim.fullPath[0].x, sim.fullPath[0].y);
      for(var j=1;j<sim.fullPath.length;j++) ctx.lineTo(sim.fullPath[j].x, sim.fullPath[j].y);
      ctx.stroke();
      ctx.restore();

      var L=22, W=14;
      var rad=(sim.heading||0)*Math.PI/180;
      ctx.save();
      ctx.translate(sim.pos.x, sim.pos.y);
      ctx.rotate(rad);
      ctx.fillStyle=sim.color;
      ctx.fillRect(-L/2, -W/2, L, W);
      ctx.fillStyle='#000';
      ctx.beginPath();
      ctx.moveTo(L/2,0);
      ctx.lineTo(L/2-4,-3);
      ctx.lineTo(L/2-4,3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });

    resetTransform();
  }

  function drawAll(){
    clampOffsets();
    drawGrid();
    drawRoutes();
    drawJobGuidesAndAGVs();

    if(zoomLabelEl) zoomLabelEl.textContent = Math.round(view.scale*100) + '%';
    if(speedLabelEl) speedLabelEl.textContent = currentSpeed().toString() + '×';

    renderStatus();
  }

  /* ========================
     Route / Job 操作
  =========================*/
  function addRoute(){
    var id=nextRouteId++;
    var color=ROUTE_COLORS[(id-1)%ROUTE_COLORS.length];
    routes[id]={
      id:id,
      color:color,
      building:false,
      points:[],
      start:null,
      goal:null,
      waits:[],
      turnCount:0,
      loadCount:1,
      unloadCount:1
    };
    activeRouteId=id;
    renderRoutesUI();
    drawAll();
    updateCursor();
  }

  function removeLastRoute(){
    var ids=getOrderedRouteIds();
    if(!ids.length) return;
    var lastId=ids[ids.length-1];
    delete routes[lastId];

    Object.keys(jobs).forEach(function(jk){
      jobs[jk].routeIds = (jobs[jk].routeIds||[]).filter(function(rid){ return rid!==lastId; });
    });

    if(activeRouteId===lastId){
      ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[ids.length-1]:null;
    }
    renderRoutesUI();
    renderJobsUI();
    drawAll();
    updateCursor();
  }

  function setActiveRoute(id){
    if(id==null){
      var ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[0]:null;
    }else{
      activeRouteId=id;
    }
    drawAll();
    updateCursor();
  }

  function toggleRouteBuilding(id){
    if(!routes[id]) return;
    var wasOn=!!routes[id].building;
    Object.keys(routes).forEach(function(k){ routes[k].building=false; });
    routes[id].building=!wasOn;
    activeRouteId=id;
    renderRoutesUI();
    drawAll();
    updateCursor();
  }

  function addWaitPointToRoute(routeId, xy, sec){
    var r=routes[routeId];
    if(!r) return;
    if(!Array.isArray(r.waits)) r.waits=[];
    r.waits.push({ xy:[xy[0],xy[1]], sec: Math.max(0, +sec||0) });
  }

  /* Jobs */
  function getOrderedJobIds(){
    return Object.keys(jobs).map(function(k){ return +k; }).sort(function(a,b){ return a-b; });
  }
  function getDisplayJobIndex(id){
    var ids=getOrderedJobIds();
    var idx=ids.indexOf(id);
    return idx===-1?null:(idx+1);
  }
  function addJob(){
    var id=nextJobId++;
    jobs[id]={ id:id, agv:'A', routeIds:[] };
    activeJobId=id;
    renderJobsUI();
    drawAll();
  }
  function removeLastJob(){
    var ids=getOrderedJobIds();
    if(!ids.length) return;
    var last=ids[ids.length-1];
    delete jobs[last];
    if(activeJobId===last){
      ids=getOrderedJobIds();
      activeJobId=ids.length?ids[ids.length-1]:null;
    }
    renderJobsUI();
    drawAll();
  }

  function addRouteToJob(jobId, routeId){
    var j=jobs[jobId]; if(!j) return;
    if(!routes[routeId]) return;
    if(!Array.isArray(j.routeIds)) j.routeIds=[];
    j.routeIds.push(routeId);
    renderJobsUI();
    drawAll();
  }

  function removeRouteFromJob(jobId, index){
    var j=jobs[jobId]; if(!j || !Array.isArray(j.routeIds)) return;
    j.routeIds.splice(index,1);
    renderJobsUI();
    drawAll();
  }

  function moveJobRoute(jobId, index, dir){
    var j=jobs[jobId]; if(!j || !Array.isArray(j.routeIds)) return;
    var ni=index+dir;
    if(ni<0 || ni>=j.routeIds.length) return;
    var tmp=j.routeIds[index];
    j.routeIds[index]=j.routeIds[ni];
    j.routeIds[ni]=tmp;
    renderJobsUI();
    drawAll();
  }

  /* ========================
     UI描画（Routes / Jobs / Vehicles）
  =========================*/
  function renderRoutesUI(){
    routesListEl.innerHTML='';
    var ids=getOrderedRouteIds();

    ids.forEach(function(id){
      var r=routes[id];
      var dispIdx=getDisplayRouteIndex(id);

      var item=document.createElement('div');
      item.className='route-item';
      item.addEventListener('click', function(){ setActiveRoute(id); });

      var name=document.createElement('div');
      name.className='route-name';
      name.textContent='Route'+dispIdx+' ';
      var chip=document.createElement('span');
      chip.style.cssText='display:inline-block;width:10px;height:10px;border-radius:999px;background:'+r.color+';margin-left:6px;';
      name.appendChild(chip);

      var buildBtn=document.createElement('button');
      buildBtn.className='btn route-toggle';
      if(r.building){
        buildBtn.textContent='経路生成ON';
        buildBtn.style.background='#fff';
        buildBtn.style.color='#006666';
        buildBtn.style.border='none';
      }else{
        buildBtn.textContent='経路生成OFF';
        buildBtn.style.background='transparent';
        buildBtn.style.color='#fff';
        buildBtn.style.border='1px solid #fff';
      }
      buildBtn.addEventListener('click', function(e){
        e.stopPropagation();
        toggleRouteBuilding(id);
      });

      var sgBtn=document.createElement('button');
      sgBtn.className='btn ghost';
      sgBtn.textContent='S/G削除';
      sgBtn.addEventListener('click', function(e){
        e.stopPropagation();
        r.start=null; r.goal=null;
        drawAll();
      });

      var right=document.createElement('div');
      right.style.gridColumn='1 / -1';
      right.style.marginTop='4px';
      right.style.display='flex';
      right.style.flexWrap='wrap';
      right.style.gap='8px';
      right.style.alignItems='center';

      var turnLbl=document.createElement('span'); turnLbl.className='note'; turnLbl.textContent='旋回数(90°換算)';
      var turnInp=document.createElement('input'); turnInp.className='rmini2'; turnInp.type='number'; turnInp.min='0'; turnInp.step='1';
      turnInp.value = (r.turnCount||0);
      turnInp.addEventListener('change', function(e){
        e.stopPropagation();
        var v=parseInt(this.value,10); if(!isFinite(v)||v<0) v=0;
        r.turnCount=v; drawAll();
      });

      var loadLbl=document.createElement('span'); loadLbl.className='note'; loadLbl.textContent='荷積み回数';
      var loadInp=document.createElement('input'); loadInp.className='rmini2'; loadInp.type='number'; loadInp.min='0'; loadInp.step='1';
      loadInp.value=(r.loadCount==null?1:r.loadCount);
      loadInp.addEventListener('change', function(e){
        e.stopPropagation();
        var v=parseInt(this.value,10); if(!isFinite(v)||v<0) v=0;
        r.loadCount=v; drawAll();
      });

      var unloadLbl=document.createElement('span'); unloadLbl.className='note'; unloadLbl.textContent='荷下ろし回数';
      var unloadInp=document.createElement('input'); unloadInp.className='rmini2'; unloadInp.type='number'; unloadInp.min='0'; unloadInp.step='1';
      unloadInp.value=(r.unloadCount==null?1:r.unloadCount);
      unloadInp.addEventListener('change', function(e){
        e.stopPropagation();
        var v=parseInt(this.value,10); if(!isFinite(v)||v<0) v=0;
        r.unloadCount=v; drawAll();
      });

      var waitInfo=document.createElement('span');
      waitInfo.className='note';
      var wsum = (Array.isArray(r.waits)? r.waits.reduce(function(a,b){ return a + Math.max(0,+b.sec||0); },0) : 0);
      waitInfo.textContent='待機点: '+(Array.isArray(r.waits)?r.waits.length:0)+' / 合計 '+wsum.toFixed(1)+'s';

      var clearWaitBtn=document.createElement('button');
      clearWaitBtn.className='btn ghost slim';
      clearWaitBtn.textContent='待機削除';
      clearWaitBtn.addEventListener('click', function(e){
        e.stopPropagation();
        r.waits=[]; drawAll();
      });

      right.appendChild(turnLbl); right.appendChild(turnInp);
      right.appendChild(loadLbl); right.appendChild(loadInp);
      right.appendChild(unloadLbl); right.appendChild(unloadInp);
      right.appendChild(waitInfo); right.appendChild(clearWaitBtn);

      item.appendChild(name);
      item.appendChild(buildBtn);
      item.appendChild(sgBtn);

      var addToJobBtn=document.createElement('button');
      addToJobBtn.className='btn ghost';
      addToJobBtn.textContent='Jobへ追加';
      addToJobBtn.addEventListener('click', function(e){
        e.stopPropagation();
        if(!activeJobId){ toast('先にJobを追加してください'); return; }
        addRouteToJob(activeJobId, id);
      });
      item.appendChild(addToJobBtn);
      item.appendChild(right);

      routesListEl.appendChild(item);
    });
  }

  function pct(n){ return Math.round(n*10)/10; }

  function buildMixBarHTML(sum){
    var total = Math.max(1e-9, sum.total_s);
    var ratios = {
      travel: sum.travel_s/total,
      wait: sum.wait_s/total,
      turn: sum.turn_s/total,
      load: sum.load_s/total,
      unload: sum.unload_s/total
    };
    // 色は既存のパレットから固定（見やすさ優先）
    // travel=青 / wait=灰 / turn=紫 / load=橙 / unload=緑
    var segs = [
      {k:'travel', w:ratios.travel, c:'#2e86de', label:'走行'},
      {k:'wait',   w:ratios.wait,   c:'#95a5a6', label:'待機'},
      {k:'turn',   w:ratios.turn,   c:'#8e44ad', label:'旋回'},
      {k:'load',   w:ratios.load,   c:'#f39c12', label:'荷積'},
      {k:'unload', w:ratios.unload, c:'#27ae60', label:'荷下'}
    ];
    var bar = document.createElement('div');
    bar.className='mixbar';
    segs.forEach(function(s){
      var d=document.createElement('div');
      d.className='mixseg';
      d.style.width = (s.w*100).toFixed(2)+'%';
      d.style.background = s.c;
      bar.appendChild(d);
    });

    var text = document.createElement('div');
    text.className='note';
    text.style.display='flex';
    text.style.flexWrap='wrap';
    text.style.gap='10px';
    text.style.marginTop='4px';
    text.innerHTML =
      '<span>走行 '+pct(ratios.travel*100)+'%</span>'+
      '<span>待機 '+pct(ratios.wait*100)+'%</span>'+
      '<span>旋回 '+pct(ratios.turn*100)+'%</span>'+
      '<span>荷積 '+pct(ratios.load*100)+'%</span>'+
      '<span>荷下 '+pct(ratios.unload*100)+'%</span>';

    var wrap=document.createElement('div');
    wrap.appendChild(bar);
    wrap.appendChild(text);
    return wrap;
  }

  function renderJobsUI(){
    jobsListEl.innerHTML='';
    var ids=getOrderedJobIds();

    ids.forEach(function(jid){
      var job=jobs[jid];
      var jDisp=getDisplayJobIndex(jid);

      var wrap=document.createElement('div');
      wrap.className='job-item';
      wrap.addEventListener('click', function(){ activeJobId=jid; renderJobsUI(); });

      var head=document.createElement('div');
      head.className='job-head';

      var title=document.createElement('div');
      title.className='job-title';
      title.innerHTML = 'Job'+jDisp + ' <span class="note">(車体 '+escapeHtml(job.agv||'-')+')</span>';

      var controls=document.createElement('div');
      controls.className='job-controls';

      var sel=document.createElement('select');
      'ABCDEFGHIJ'.split('').forEach(function(ch){
        var opt=document.createElement('option');
        opt.value=ch; opt.textContent='AGV '+ch;
        if(ch===job.agv) opt.selected=true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', function(e){
        e.stopPropagation();
        job.agv=this.value;
        renderJobsUI();
        drawAll();
      });

      var badge=document.createElement('span');
      badge.className='note';
      badge.textContent = (activeJobId===jid)? '選択中' : '';
      if(activeJobId===jid){ badge.style.fontWeight='800'; }

      controls.appendChild(sel);
      controls.appendChild(badge);

      head.appendChild(title);
      head.appendChild(controls);

      var list=document.createElement('div');
      list.className='job-routes';

      var routeIds = Array.isArray(job.routeIds)? job.routeIds.slice() : [];
      if(!routeIds.length){
        var empty=document.createElement('div');
        empty.className='note';
        empty.textContent='（まだRouteがありません。Route側の「Jobへ追加」を押す）';
        list.appendChild(empty);
      }else{
        routeIds.forEach(function(rid, idx){
          var r=routes[rid];
          var row=document.createElement('div');
          row.className='job-route-row';

          var label=document.createElement('div');
          var rDisp = r ? ('Route'+getDisplayRouteIndex(rid)) : ('(削除済 Route '+rid+')');
          label.innerHTML = '<strong>'+escapeHtml(rDisp)+'</strong>';
          if(r){
            var chip=document.createElement('span');
            chip.style.cssText='display:inline-block;width:10px;height:10px;border-radius:999px;background:'+r.color+';margin-left:8px;vertical-align:middle;';
            label.appendChild(chip);
          }

          var up=document.createElement('button');
          up.className='btn ghost slim';
          up.textContent='▲';
          up.title='上へ';
          up.addEventListener('click', function(e){ e.stopPropagation(); moveJobRoute(jid, idx, -1); });

          var down=document.createElement('button');
          down.className='btn ghost slim';
          down.textContent='▼';
          down.title='下へ';
          down.addEventListener('click', function(e){ e.stopPropagation(); moveJobRoute(jid, idx, +1); });

          var del=document.createElement('button');
          del.className='btn ghost slim';
          del.textContent='削除';
          del.addEventListener('click', function(e){ e.stopPropagation(); removeRouteFromJob(jid, idx); });

          row.appendChild(label);
          row.appendChild(up);
          row.appendChild(down);
          row.appendChild(del);

          list.appendChild(row);
        });
      }

      wrap.appendChild(head);
      wrap.appendChild(list);

      jobsListEl.appendChild(wrap);
    });
  }

  function renderVehiclesUI(){
    var v=vehicles;
    var html='';
    html += '<div class="head">車体</div>'
          + '<div class="head">速度</div>'
          + '<div class="head">旋回90</div>'
          + '<div class="head">旋回180</div>'
          + '<div class="head">荷積</div>'
          + '<div class="head">荷下</div>'
          + '<div class="head">備考</div>';

    'ABCDEFGHIJ'.split('').forEach(function(ch){
      html += '<div><strong>'+ch+'</strong></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="speed" type="number" step="0.1" min="0" value="'+v[ch].speed+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="turn90" type="number" step="0.1" min="0" value="'+v[ch].turn90+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="turn180" type="number" step="0.1" min="0" value="'+v[ch].turn180+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="loadTime" type="number" step="0.1" min="0" value="'+v[ch].loadTime+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="unloadTime" type="number" step="0.1" min="0" value="'+v[ch].unloadTime+'"></div>'
           +  '<div class="note">[m/s],[s],[s],[s],[s]</div>';
    });

    vehiclesEl.innerHTML=html;

    vehiclesEl.querySelectorAll('input').forEach(function(inp){
      inp.addEventListener('change', function(){
        var k=this.getAttribute('data-vkey');
        var f=this.getAttribute('data-field');
        var val=parseFloat(this.value);
        if(!isFinite(val)||val<0) val=0;
        vehicles[k][f]=val;
        drawAll();
      });
    });
  }

  /* ========================
     入力（画像のドラッグ/リサイズ、パン/ズーム）
  =========================*/
  function hitImageHandle(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY);
    var w=screenToWorld(s.x, s.y);
    var pts=[
      {x:it.x,y:it.y,c:'nw'},
      {x:it.x+it.w,y:it.y,c:'ne'},
      {x:it.x,y:it.y+it.h,c:'sw'},
      {x:it.x+it.w,y:it.y+it.h,c:'se'}
    ];
    for(var i=0;i<pts.length;i++){
      var p=pts[i];
      var dx=Math.abs(w.x-p.x)*view.scale;
      var dy=Math.abs(w.y-p.y)*view.scale;
      if(Math.hypot(dx,dy)<=IMG_HANDLE+2) return p.c;
    }
    return null;
  }
  function hitImageBody(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY);
    var w=screenToWorld(s.x, s.y);
    return (w.x>=it.x && w.x<=it.x+it.w && w.y>=it.y && w.y<=it.y+it.h);
  }
  function pickImage(clientX, clientY){
    for(var i=images.length-1;i>=0;i--){
      var it=images[i];
      var h=hitImageHandle(it, clientX, clientY);
      if(h) return {it:it, mode:h};
      if(hitImageBody(it, clientX, clientY)) return {it:it, mode:'move'};
    }
    return null;
  }

  function onMouseDown(e){
    if(anyBuilding()) return;

    var itSel=getSelectedImage();
    if(itSel){
      var pick=pickImage(e.clientX, e.clientY);
      if(pick && pick.it.id===itSel.id){
        imgDrag.active=true;
        imgDrag.mode=pick.mode;
        imgDrag.start=clientToCanvasXY(e.clientX,e.clientY);
        imgDrag.keepAR=!e.shiftKey;
        imgDrag.base={ x:itSel.x, y:itSel.y, w:itSel.w, h:itSel.h };
        e.preventDefault();
        return;
      }
    }

    view.dragging=true;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.dragStart=s;
    view.startOffset={ x:view.offsetX, y:view.offsetY };
    canvas.style.cursor='grabbing';
    e.preventDefault();
  }

  function onMouseMove(e){
    if(imgDrag.active && selectedImgId){
      var it=getSelectedImage();
      if(!it) return;

      var cur=clientToCanvasXY(e.clientX,e.clientY);
      var dx=(cur.x-imgDrag.start.x)/view.scale;
      var dy=(cur.y-imgDrag.start.y)/view.scale;

      if(imgDrag.mode==='move'){
        it.x=imgDrag.base.x+dx;
        it.y=imgDrag.base.y+dy;
      }else{
        var bx=imgDrag.base.x, by=imgDrag.base.y, bw=imgDrag.base.w, bh=imgDrag.base.h;
        var ar=bw/Math.max(1e-6,bh);

        var nx=bx, ny=by, nw=bw, nh=bh;
        if(imgDrag.mode==='nw'){ nx=bx+dx; ny=by+dy; nw=bw-dx; nh=bh-dy; }
        else if(imgDrag.mode==='ne'){ ny=by+dy; nw=bw+dx; nh=bh-dy; }
        else if(imgDrag.mode==='sw'){ nx=bx+dx; nw=bw-dx; nh=bh+dy; }
        else if(imgDrag.mode==='se'){ nw=bw+dx; nh=bh+dy; }

        nw=Math.max(10,nw); nh=Math.max(10,nh);
        if(imgDrag.keepAR){
          if(Math.abs(nw-bw) > Math.abs(nh-bh)) nh=nw/ar; else nw=nh*ar;
          if(imgDrag.mode==='nw'){ nx=bx+(bw-nw); ny=by+(bh-nh); }
          if(imgDrag.mode==='ne'){ ny=by+(bh-nh); }
          if(imgDrag.mode==='sw'){ nx=bx+(bw-nw); }
        }
        it.x=nx; it.y=ny; it.w=nw; it.h=nh;
      }
      drawAll();
      return;
    }

    if(!view.dragging) return;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.offsetX=view.startOffset.x + (s.x - view.dragStart.x);
    view.offsetY=view.startOffset.y + (s.y - view.dragStart.y);
    clampOffsets();
    drawAll();
  }

  function onMouseUp(){
    if(imgDrag.active){
      imgDrag.active=false;
      imgDrag.mode=null;
      return;
    }
    if(!view.dragging) return;
    view.dragging=false;
    updateCursor();
  }

  function zoomAt(newScale, clientX, clientY){
    newScale=clamp(newScale, view.min, view.max);
    var s=clientToCanvasXY(clientX,clientY);
    var w=screenToWorld(s.x,s.y);

    view.scale=newScale;
    var scr=worldToScreen(w.x,w.y);
    view.offsetX += (s.x - scr.x);
    view.offsetY += (s.y - scr.y);

    clampOffsets();
    drawAll();
  }
  function onWheel(e){
    if(anyBuilding()) return;
    e.preventDefault();
    var factor=(e.deltaY<0)?1.1:0.9;
    zoomAt(view.scale*factor, e.clientX, e.clientY);
  }

  function updateCursor(){
    canvas.style.cursor = anyBuilding()? 'crosshair' : 'grab';
  }

  /* ========================
     ルート編集（クリック/ダブルクリック）
  =========================*/
  function snappedGridWorldFromEvent(e){
    var s=clientToCanvasXY(e.clientX,e.clientY);
    var w=screenToWorld(s.x,s.y);
    return [Math.round(w.x/GRID)*GRID, Math.round(w.y/GRID)*GRID];
  }

  function onCanvasClick(e){
    var r=routes[activeRouteId];
    if(r && r.building){
      var xy=snappedGridWorldFromEvent(e);

      if(r.points.length>0){
        var a={x:r.points[r.points.length-1][0], y:r.points[r.points.length-1][1]};
        if(approx(a.x,xy[0]) && approx(a.y,xy[1])) return;
        if(!approx(a.x,xy[0]) && !approx(a.y,xy[1])){
          toast('直前の点と水平/垂直にしてください');
          return;
        }
      }
      r.points.push(xy);
      drawAll();
    }
  }

  function onCanvasDblClick(e){
    var r=routes[activeRouteId];
    if(!r) return;
    if(!r.building) return;

    e.preventDefault();

    var isWait = e.shiftKey;

    var xy=snappedGridWorldFromEvent(e);
    var base=polylineFromPoints(r);
    if(base.length<2){
      toast('先にポイントを2点以上追加してください');
      return;
    }

    var snapped=projectToPolyline(xy, base, CLICK_SNAP_TOL);
    if(!snapped){
      toast(isWait? '待機点はルート線上に設定してください':'S/Gはルート線上に設定してください');
      return;
    }
    var sxy=[snapped.x, snapped.y];

    if(isWait){
      var sec = prompt('待機時間[s]を入力', '5');
      if(sec===null) return;
      sec = parseFloat(sec);
      if(!isFinite(sec)||sec<0) sec=0;
      addWaitPointToRoute(activeRouteId, sxy, sec);
      drawAll();
      return;
    }

    if(!r.start){
      r.start=sxy;
      drawAll();
      return;
    }
    if(!r.goal){
      r.goal=sxy;
      drawAll();
      return;
    }
    toast('S/Gは既に設定済みです（S/G削除で再設定）');
  }

  async function pasteImageFromClipboard(e){
    if(!e.clipboardData || !e.clipboardData.items) return;
    var items = Array.from(e.clipboardData.items);
    var imgItem = items.find(function(it){ return it.type && it.type.indexOf('image')===0; });
    if(!imgItem) return;

    var file = imgItem.getAsFile();
    if(!file) return;

    e.preventDefault();
    var res = await fileToBitmapImageOnly(file);
    if(!res) return;
    addImageLayer('paste_'+Date.now()+'.png', res.bitmap, res.width, res.height);
    toast('画像を貼り付けました');
  }

  /* ========================
     パン（矢印ボタン：押しっぱなし）
  =========================*/
  function panByWorld(dxWorld, dyWorld){
    view.offsetX -= dxWorld * view.scale;
    view.offsetY -= dyWorld * view.scale;
    clampOffsets();
    drawAll();
  }
  function bindHold(btn, fn){
    var t=null;
    var tick=function(){ fn(); };
    var start=function(ev){
      ev.preventDefault();
      tick();
      t=setInterval(tick, 16);
    };
    var end=function(){
      if(t){ clearInterval(t); t=null; }
    };

    btn.addEventListener('mousedown', start);
    btn.addEventListener('touchstart', start, {passive:false});
    window.addEventListener('mouseup', end);
    window.addEventListener('touchend', end);
    window.addEventListener('touchcancel', end);
    btn.addEventListener('mouseleave', end);
  }

  /* ========================
     JSON保存/読込/PNG
  =========================*/
  function onExport(){
    var imgMeta=images.map(function(it){
      return { id:it.id, name:it.name, x:it.x, y:it.y, w:it.w, h:it.h, opacity:it.opacity };
    });

    var data={
      routes: routes,
      jobs: jobs,
      vehicles: vehicles,
      images: imgMeta,
      meta:{ pxPerM:PX_PER_M, world:WORLD, ts:Date.now() }
    };

    var blob=new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    var a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='agv_simulator_jobs.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function onImport(evt){
    var file=evt.target.files && evt.target.files[0];
    if(!file) return;

    var reader=new FileReader();
    reader.onload=function(){
      try{
        var obj=JSON.parse(reader.result);

        if(obj.meta && obj.meta.world) WORLD=obj.meta.world;

        // vehicles（旧形式 turn しか無い場合は移行）
        if(obj.vehicles){
          vehicles=obj.vehicles;
          'ABCDEFGHIJ'.split('').forEach(function(ch){
            vehicles[ch]=vehicles[ch]||{speed:1,turn90:2,turn180:4,loadTime:5,unloadTime:5};
            if(vehicles[ch].turn!=null && vehicles[ch].turn90==null){
              vehicles[ch].turn90 = vehicles[ch].turn;
            }
            if(vehicles[ch].turn180==null){
              vehicles[ch].turn180 = (vehicles[ch].turn90||0)*2;
            }
            delete vehicles[ch].turn;
          });
        }

        if(obj.routes){
          routes={};
          Object.keys(obj.routes).forEach(function(k){ routes[+k]=obj.routes[k]; });
        }
        nextRouteId=(Math.max(0, ...Object.keys(routes).map(function(k){ return +k; })) || 0)+1;

        if(obj.jobs){
          jobs={};
          Object.keys(obj.jobs).forEach(function(k){ jobs[+k]=obj.jobs[k]; });
        }
        nextJobId=(Math.max(0, ...Object.keys(jobs).map(function(k){ return +k; })) || 0)+1;

        images=[];
        if(Array.isArray(obj.images)&&obj.images.length){
          toast('JSON内の画像はメタのみ復元（貼り付け/追加で再登録してください）');
          obj.images.forEach(function(m){
            images.push({
              id:m.id||(nextImgId++),
              name:m.name||'image',
              bitmap:null,
              x:m.x||40, y:m.y||40,
              w:m.w||200, h:m.h||200,
              opacity:(typeof m.opacity==='number'?m.opacity:1)
            });
            nextImgId=Math.max(nextImgId, (m.id||0)+1);
          });
        }

        renderVehiclesUI();
        renderRoutesUI();
        renderJobsUI();
        renderImageList();
        setActiveRoute(null);

        clampOffsets();
        drawAll();
        updateCursor();
      }catch(err){
        toast('読み込みエラー: '+err.message);
      }
    };
    reader.readAsText(file);
  }

  function onExportPNG(){
    drawAll();
    canvas.toBlob(function(blob){
      var a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='agv_simulator.png';
      a.click();
      setTimeout(function(){ URL.revokeObjectURL(a.href); },0);
    }, 'image/png');
  }

  /* ========================
     KPI計算
  =========================*/
  function getAvailability(){
    var chargePct=Math.min(30, Math.max(0, parseFloat(chargePctEl.value)||0));
    var safetyPct=Math.min(50, Math.max(0, parseFloat(safetyPctEl.value)||0));
    var avail=(1-(chargePct/100))*(1-(safetyPct/100));
    return { chargePct:chargePct, safetyPct:safetyPct, avail:avail };
  }

  function calcRouteOneWay(route, agvLetter){
    var r=route;
    var agv=agvLetter;
    var veh=vehicles[agv] || {speed:1,turn90:2,turn180:4,loadTime:5,unloadTime:5};

    var sg=sgSubpathAndMeters(r);
    var dist=sg.meters;

    var travel = (dist / Math.max(0.01, veh.speed));
    var waitS = (Array.isArray(r.waits)? r.waits.reduce(function(a,b){ return a + Math.max(0,+b.sec||0); },0) : 0);

    // ルート内の手入力旋回数は「90°換算」なので turn90 を掛ける
    var turnS = Math.max(0,(r.turnCount|0)) * Math.max(0,veh.turn90);

    var loadS = Math.max(0,(r.loadCount==null?1:r.loadCount)) * Math.max(0,veh.loadTime);
    var unloadS = Math.max(0,(r.unloadCount==null?1:r.unloadCount)) * Math.max(0,veh.unloadTime);

    var total = (sg.path.length? (travel + waitS + turnS + loadS + unloadS) : 0);

    return {
      ok: (sg.path.length && dist>0),
      dist_m: dist,
      travel_s: travel,
      wait_s: waitS,
      turn_s: turnS,
      load_s: loadS,
      unload_s: unloadS,
      total_s: total
    };
  }

  function calcJobTotal(job){
    var j=job;
    var agv=j.agv || 'A';
    var veh=vehicles[agv] || {speed:1,turn90:2,turn180:4,loadTime:5,unloadTime:5};

    var routeIds = Array.isArray(j.routeIds)? j.routeIds.slice() : [];
    var sum = { dist_m:0, travel_s:0, wait_s:0, turn_s:0, load_s:0, unload_s:0, total_s:0, ok:true };

    var prevEndHeading = null;

    routeIds.forEach(function(rid){
      var r=routes[rid];
      if(!r){ sum.ok=false; return; }

      var one=calcRouteOneWay(r, agv);
      if(!one.ok){ sum.ok=false; }

      sum.dist_m += one.dist_m;
      sum.travel_s += one.travel_s;
      sum.wait_s += one.wait_s;
      sum.turn_s += one.turn_s;
      sum.load_s += one.load_s;
      sum.unload_s += one.unload_s;

      // ルート間旋回（90/180を車体設定で）
      var sg=sgSubpathAndMeters(r);
      if(sg.path && sg.path.length>=2){
        var startHeading = headingOf(sg.path[0], sg.path[1]);
        var endHeading = headingOf(sg.path[sg.path.length-2], sg.path[sg.path.length-1]);

        if(prevEndHeading!=null){
          var d = angleDelta(prevEndHeading, startHeading); // -180..180
          sum.turn_s += turnTimeForDeltaDeg(d, veh);
        }
        prevEndHeading = endHeading;
      }
    });

    sum.total_s = sum.travel_s + sum.wait_s + sum.turn_s + sum.load_s + sum.unload_s;
    return sum;
  }

  function renderStatus(){
    var av = getAvailability();

    // ✅ 稼働率：数値 + バー
    availLabelEl.textContent =
      'avail=' + (av.avail*100).toFixed(1) + '%'
      + ' （充電率 ' + av.chargePct.toFixed(0) + '% / 安全率 ' + av.safetyPct.toFixed(0) + '%）';

    if(availBarFillEl){
      availBarFillEl.style.width = clamp(av.avail*100,0,100).toFixed(1)+'%';
    }

    // Route（片道）
    routesSummaryEl.innerHTML='';
    var rids=getOrderedRouteIds();
    if(!rids.length){
      routesSummaryEl.textContent='ルート無し';
    }else{
      rids.forEach(function(id){
        var r=routes[id];
        var disp=getDisplayRouteIndex(id);

        var agv='A';
        if(activeJobId && jobs[activeJobId]) agv=jobs[activeJobId].agv||'A';

        var one=calcRouteOneWay(r, agv);
        var line=document.createElement('div');
        line.className='summary-line';

        if(!one.ok){
          line.innerHTML =
            '<span>Route'+disp+'</span>'
            +'<span>距離 - ｜S/G未設定 or 経路不足</span>';
          routesSummaryEl.appendChild(line);
          return;
        }

        line.innerHTML =
          '<span>Route'+disp+'</span>'
          +'<span>'
          +'距離 '+one.dist_m.toFixed(1)+'m'
          +'｜待機 '+one.wait_s.toFixed(1)+'s'
          +'｜走行 '+one.travel_s.toFixed(1)+'s'
          +'｜旋回 '+one.turn_s.toFixed(1)+'s'
          +'｜荷積 '+one.load_s.toFixed(1)+'s'
          +'｜荷下 '+one.unload_s.toFixed(1)+'s'
          +'｜合計 '+one.total_s.toFixed(1)+'s'
          +'</span>';
        routesSummaryEl.appendChild(line);
      });
    }

    // Job（各Job）
    jobsSummaryEl.innerHTML='';
    var jids=getOrderedJobIds();
    if(!jids.length){
      jobsSummaryEl.textContent='Job無し';
      return;
    }

    jids.forEach(function(jid){
      var j=jobs[jid];
      var jDisp=getDisplayJobIndex(jid);
      var sum=calcJobTotal(j);

      var block=document.createElement('div');
      block.style.background='#012f2f';
      block.style.borderRadius='8px';
      block.style.padding='8px';
      block.style.display='flex';
      block.style.flexDirection='column';
      block.style.gap='4px';

      var header=document.createElement('div');
      header.innerHTML =
        '<strong>Job'+jDisp+'</strong> <span class="note">(AGV '+escapeHtml(j.agv||'-')+')</span>'
        + (activeJobId===jid ? ' <span class="note" style="font-weight:800;">[選択中]</span>' : '');
      block.appendChild(header);

      if(!Array.isArray(j.routeIds) || !j.routeIds.length){
        var empty=document.createElement('div');
        empty.className='note';
        empty.textContent='Routeが未設定';
        block.appendChild(empty);
        jobsSummaryEl.appendChild(block);
        return;
      }

      var theo = sum.total_s;
      var theoPerH = theo>0 ? (3600/theo) : 0;
      var effPerH = theoPerH * av.avail;

      var main=document.createElement('div');
      main.className='note';
      main.innerHTML =
        'Job合計時間（理論） <strong>'+theo.toFixed(1)+' s</strong>'
        +'｜理論搬送量 <strong>'+theoPerH.toFixed(2)+' /h</strong>'
        +'｜実効搬送量 <strong>'+effPerH.toFixed(2)+' /h</strong>';
      block.appendChild(main);

      var detail=document.createElement('div');
      detail.className='note';
      detail.innerHTML =
        '合計距離 '+sum.dist_m.toFixed(1)+'m'
        +'｜待機 '+sum.wait_s.toFixed(1)+'s'
        +'｜走行 '+sum.travel_s.toFixed(1)+'s'
        +'｜旋回 '+sum.turn_s.toFixed(1)+'s'
        +'｜荷積 '+sum.load_s.toFixed(1)+'s'
        +'｜荷下 '+sum.unload_s.toFixed(1)+'s';
      block.appendChild(detail);

      // 内訳比率バー
      block.appendChild(buildMixBarHTML(sum));

      jobsSummaryEl.appendChild(block);
    });
  }

  /* ========================
     シミュレーション（Jobを連結して1動作として見せる）
  =========================*/
  function buildJobFullPath(job){
    var routeIds = Array.isArray(job.routeIds)? job.routeIds.slice():[];
    var full=[];
    for(var i=0;i<routeIds.length;i++){
      var rid=routeIds[i];
      var r=routes[rid];
      if(!r) continue;
      var sg=sgSubpathAndMeters(r);
      if(!sg.path || sg.path.length<2) continue;

      if(full.length){
        var prev=full[full.length-1];
        var nextStart=sg.path[0];
        if(!approx(prev.x,nextStart.x) || !approx(prev.y,nextStart.y)){
          var mid={x: nextStart.x, y: prev.y};
          if(!approx(prev.x, mid.x) || !approx(prev.y, mid.y)) full.push({x:mid.x, y:mid.y});
          if(!approx(mid.x, nextStart.x) || !approx(mid.y, nextStart.y)) full.push({x:nextStart.x, y:nextStart.y});
        }
      }

      for(var k=0;k<sg.path.length;k++){
        var p=sg.path[k];
        if(full.length){
          var last=full[full.length-1];
          if(approx(last.x,p.x) && approx(last.y,p.y)) continue;
        }
        full.push({x:p.x, y:p.y});
      }
    }
    if(full.length<2) return null;
    return full;
  }

  function buildJobRouteIndexRanges(job, fullPath){
    var ranges=[];
    var routeIds = Array.isArray(job.routeIds)? job.routeIds.slice():[];
    var tmp=[];
    for(var i=0;i<routeIds.length;i++){
      var rid=routeIds[i];
      var r=routes[rid]; if(!r) continue;
      var sg=sgSubpathAndMeters(r);
      if(!sg.path || sg.path.length<2) continue;

      if(tmp.length){
        var prev=tmp[tmp.length-1];
        var nextStart=sg.path[0];
        if(!approx(prev.x,nextStart.x) || !approx(prev.y,nextStart.y)){
          var mid={x: nextStart.x, y: prev.y};
          if(!approx(prev.x, mid.x) || !approx(prev.y, mid.y)) tmp.push({x:mid.x, y:mid.y});
          if(!approx(mid.x, nextStart.x) || !approx(mid.y, nextStart.y)) tmp.push({x:nextStart.x, y:nextStart.y});
        }
      }
      var startIdx = tmp.length;
      for(var k=0;k<sg.path.length;k++){
        var p=sg.path[k];
        if(tmp.length){
          var last=tmp[tmp.length-1];
          if(approx(last.x,p.x) && approx(last.y,p.y)) continue;
        }
        tmp.push({x:p.x, y:p.y});
      }
      var endIdx = tmp.length-1;
      ranges.push({ routeId: rid, startIdx:startIdx, endIdx:endIdx });
    }

    ranges.forEach(function(rg){
      rg.startIdx = clamp(rg.startIdx, 0, Math.max(0, fullPath.length-1));
      rg.endIdx = clamp(rg.endIdx, 0, Math.max(0, fullPath.length-1));
    });
    return ranges;
  }

  function createJobSimState(jobId){
    var job=jobs[jobId];
    if(!job) return null;
    var fullPath=buildJobFullPath(job);
    if(!fullPath) return null;

    var agv=job.agv||'A';
    var veh=vehicles[agv] || {speed:1,turn90:2,turn180:4,loadTime:5,unloadTime:5};

    var h0 = headingOf(fullPath[0], fullPath[1]);

    return {
      jobId: jobId,
      agv: agv,
      color: ROUTE_COLORS[(getDisplayJobIndex(jobId)-1)%ROUTE_COLORS.length],
      fullPath: fullPath,

      segIndex: 0,
      pos: { x: fullPath[0].x, y: fullPath[0].y },
      heading: h0,

      pixPerSec: Math.max(0.01, veh.speed) * PX_PER_M,

      lastRealTs: performance.now(),
      vtime_ms: 0,

      phase: 'move', // move | dwell | turn
      dwellEndV: null,

      // turn animation
      turnQueue: [],
      turnStartHeading: null,
      targetHeading: null,
      turnStartV: null,
      turnDuration: null,
      turnEndV: null,

      _routeStartDone: {},
      _routeEndDone: {},
      _waitDone: {},

      routeIndexRanges: buildJobRouteIndexRanges(job, fullPath)
    };
  }

  function startTurn(sim, deltaDeg, veh){
    var d = Math.abs(deltaDeg);
    if(d < 1e-6) return false;

    // 90 or 180 だけを想定（angleDeltaが -180..180 なので）
    var durationMs = turnTimeForDeltaDeg(deltaDeg, veh) * 1000;

    sim.turnQueue = [{
      delta: (deltaDeg<0? -d : d),
      duration: durationMs
    }];

    // start immediately
    var seg=sim.turnQueue.shift();
    sim.targetHeading = normHeading(sim.heading + seg.delta);
    sim.turnStartHeading = sim.heading;
    sim.turnStartV = sim.vtime_ms;
    sim.turnDuration = seg.duration;
    sim.turnEndV = sim.vtime_ms + seg.duration;
    sim.phase='turn';
    return true;
  }

  function findCurrentRouteIndexRange(sim){
    var ranges = sim.routeIndexRanges || [];
    var idx = sim.segIndex;
    for(var i=0;i<ranges.length;i++){
      var rg=ranges[i];
      if(idx>=rg.startIdx && idx<=rg.endIdx) return {i:i, rg:rg};
    }
    return null;
  }

  function consumeEventsIfNeeded(sim){
    var job=jobs[sim.jobId];
    if(!job) return;

    var agv=sim.agv;
    var veh=vehicles[agv] || {speed:1,turn90:2,turn180:4,loadTime:5,unloadTime:5};

    var curInfo = findCurrentRouteIndexRange(sim);
    if(!curInfo) return;

    var rid = curInfo.rg.routeId;
    var r = routes[rid];
    if(!r) return;

    var atStart = (sim.segIndex === curInfo.rg.startIdx);
    var atEnd   = (sim.segIndex === curInfo.rg.endIdx);

    if(sim.phase!=='move') return;

    if(atStart){
      var keyS = rid + ':S';
      if(!sim._routeStartDone[keyS]){
        sim._routeStartDone[keyS]=true;
        var loadCount = Math.max(0,(r.loadCount==null?1:r.loadCount)|0);
        if(loadCount>0 && veh.loadTime>0){
          sim.phase='dwell';
          sim.dwellEndV = sim.vtime_ms + (loadCount*veh.loadTime)*1000;
          return;
        }
      }
    }

    if(Array.isArray(r.waits) && r.waits.length){
      for(var wi=0; wi<r.waits.length; wi++){
        var wt=r.waits[wi];
        var wkey = rid+':W'+wi;
        if(sim._waitDone[wkey]) continue;

        var dx=Math.abs(sim.pos.x - wt.xy[0]);
        var dy=Math.abs(sim.pos.y - wt.xy[1]);
        if(dx<=EPS+0.8 && dy<=EPS+0.8){
          sim._waitDone[wkey]=true;
          var sec=Math.max(0,+wt.sec||0);
          if(sec>0){
            sim.phase='dwell';
            sim.dwellEndV = sim.vtime_ms + sec*1000;
            return;
          }
        }
      }
    }

    if(atEnd){
      var keyG = rid + ':G';
      if(!sim._routeEndDone[keyG]){
        sim._routeEndDone[keyG]=true;
        var unloadCount = Math.max(0,(r.unloadCount==null?1:r.unloadCount)|0);
        if(unloadCount>0 && veh.unloadTime>0){
          sim.phase='dwell';
          sim.dwellEndV = sim.vtime_ms + (unloadCount*veh.unloadTime)*1000;
          return;
        }
      }
    }
  }

  function onSimToggle(){
    if(simRunning){
      simRunning=false;
      jobSims={};
      simulateBtn.textContent='シミュレーション開始（Jobを連結して実行）';
      drawAll();
      return;
    }

    jobSims={};
    var any=false;

    var jids=getOrderedJobIds();
    jids.forEach(function(jid){
      var job=jobs[jid];
      if(!job || !Array.isArray(job.routeIds) || !job.routeIds.length) return;
      var sim = createJobSimState(jid);
      if(sim){
        any=true;
        jobSims[jid]=sim;
      }
    });

    if(!any){
      toast('有効なJobがありません（JobにRouteを追加し、RouteにS/Gを設定してください）');
      return;
    }

    simRunning=true;
    simulateBtn.textContent='シミュレーション停止';
    requestAnimationFrame(stepSimAll);
  }

  function stepSimAll(tsReal){
    if(!simRunning) return;

    Object.keys(jobSims).forEach(function(jidStr){
      var sim=jobSims[jidStr];
      var job=jobs[sim.jobId];
      if(!sim || !job) return;

      var agv=job.agv||'A';
      var veh=vehicles[agv] || {speed:1,turn90:2,turn180:4,loadTime:5,unloadTime:5};
      sim.pixPerSec = Math.max(0.01, veh.speed) * PX_PER_M;

      var dtReal=(tsReal - sim.lastRealTs)/1000;
      sim.lastRealTs=tsReal;
      var dtScaled = dtReal * currentSpeed();
      sim.vtime_ms += dtScaled*1000;

      if(sim.phase==='dwell'){
        if(sim.vtime_ms < sim.dwellEndV) return;
        sim.phase='move';
        sim.dwellEndV=null;
      }

      if(sim.phase==='turn'){
        if(sim.vtime_ms < sim.turnEndV){
          var ratio=clamp((sim.vtime_ms - sim.turnStartV)/sim.turnDuration,0,1);
          sim.heading=lerpAngle(sim.turnStartHeading, sim.targetHeading, ratio);
          return;
        }
        sim.heading=sim.targetHeading;
        sim.turnEndV=null; sim.targetHeading=null; sim.turnDuration=null; sim.turnStartHeading=null; sim.turnStartV=null;
        sim.phase='move';
      }

      var path=sim.fullPath;
      var aIdx=sim.segIndex;
      var bIdx=aIdx+1;

      if(bIdx>=path.length){
        sim.segIndex=0;
        sim.pos.x=path[0].x;
        sim.pos.y=path[0].y;

        sim._routeStartDone = {};
        sim._routeEndDone = {};
        sim._waitDone = {};

        var desired = headingOf(path[0], path[1]);
        var d=angleDelta(sim.heading, desired);
        if(d!==0){
          startTurn(sim, d, veh);
          return;
        }else{
          sim.heading=desired;
        }
        return;
      }

      var A=path[aIdx], B=path[bIdx];

      var desiredHeading = headingOf(A,B);
      var delta = angleDelta(sim.heading, desiredHeading);
      if(delta!==0){
        startTurn(sim, delta, veh);
        return;
      }else{
        sim.heading=desiredHeading;
      }

      var move=sim.pixPerSec * dtScaled;

      if(!approx(A.x,B.x)){
        var dirx=Math.sign(B.x-sim.pos.x);
        var remain=Math.abs(B.x-sim.pos.x);
        if(move>=remain){
          sim.pos.x=B.x; sim.pos.y=B.y;
          sim.segIndex=bIdx;
        }else{
          sim.pos.x += dirx*move;
        }
      }else{
        var diry=Math.sign(B.y-sim.pos.y);
        var remainy=Math.abs(B.y-sim.pos.y);
        if(move>=remainy){
          sim.pos.x=B.x; sim.pos.y=B.y;
          sim.segIndex=bIdx;
        }else{
          sim.pos.y += diry*move;
        }
      }

      consumeEventsIfNeeded(sim);
    });

    drawAll();
    requestAnimationFrame(stepSimAll);
  }

  /* ========================
     キー入力
  =========================*/
  function onKeyDown(e){
    if(e.key==='Delete' || e.key==='Backspace'){
      var it=getSelectedImage();
      if(it){
        images=images.filter(function(x){ return x.id!==it.id; });
        selectedImgId=null;
        renderImageList();
        drawAll();
        e.preventDefault();
      }
    }else if(e.key==='Escape'){
      if(selectedImgId){
        selectedImgId=null;
        renderImageList();
        drawAll();
      }
    }
  }

  /* ========================
     resize / init
  =========================*/
  function resize(){
    var sidebar=document.querySelector('.sidebar');
    var sw=sidebar?sidebar.offsetWidth:520;
    var w=Math.max(260, window.innerWidth - sw);
    var h=window.innerHeight;
    canvas.width=w;
    canvas.height=h;
    clampOffsets();
    drawAll();
  }

  function ready(){
    canvas=document.getElementById('map');
    if(!canvas) return;
    ctx=canvas.getContext('2d');
    toastEl=document.getElementById('toast');

    zoomLabelEl=document.getElementById('zoomLabel');
    speedLabelEl=document.getElementById('speedLabel');
    speedDecBtn=document.getElementById('speedDec');
    speedIncBtn=document.getElementById('speedInc');

    panUpBtn=document.getElementById('panUp');
    panDownBtn=document.getElementById('panDown');
    panLeftBtn=document.getElementById('panLeft');
    panRightBtn=document.getElementById('panRight');

    routesListEl=document.getElementById('routesList');
    addRouteBtn=document.getElementById('addRoute');
    removeRouteBtn=document.getElementById('removeRoute');

    jobsListEl=document.getElementById('jobsList');
    addJobBtn=document.getElementById('addJob');
    removeJobBtn=document.getElementById('removeJob');

    undoBtn=document.getElementById('undo');
    clearBtn=document.getElementById('clear');
    simulateBtn=document.getElementById('simulateToggle');

    vehiclesEl=document.getElementById('vehicles');
    exportBtn=document.getElementById('exportBtn');
    importBtn=document.getElementById('importBtn');
    importFile=document.getElementById('importFile');
    exportPngBtn=document.getElementById('exportPngBtn');

    routesSummaryEl=document.getElementById('routesSummary');
    jobsSummaryEl=document.getElementById('jobsSummary');
    availLabelEl=document.getElementById('availLabel');
    availBarFillEl=document.getElementById('availBarFill');

    chargePctEl=document.getElementById('chargePct');
    safetyPctEl=document.getElementById('safetyPct');

    imageFileEl=document.getElementById('imageFile');
    addImageBtn=document.getElementById('addImageBtn');
    imgOpacityEl=document.getElementById('imgOpacity');
    imgOpacityLabelEl=document.getElementById('imgOpacityLabel');
    imgListEl=document.getElementById('imgList');

    addRouteBtn.addEventListener('click', addRoute);
    removeRouteBtn.addEventListener('click', removeLastRoute);

    addJobBtn.addEventListener('click', addJob);
    removeJobBtn.addEventListener('click', removeLastJob);

    undoBtn.addEventListener('click', function(){
      var r=routes[activeRouteId];
      if(!r) return;
      r.points.pop();
      drawAll();
    });

    clearBtn.addEventListener('click', function(){
      var r=routes[activeRouteId];
      if(!r) return;
      r.points.length=0;
      r.start=null; r.goal=null;
      r.waits=[];
      drawAll();
    });

    simulateBtn.addEventListener('click', onSimToggle);

    exportBtn.addEventListener('click', onExport);
    importBtn.addEventListener('click', function(){ importFile.click(); });
    importFile.addEventListener('change', onImport);
    exportPngBtn.addEventListener('click', onExportPNG);

    chargePctEl.addEventListener('change', drawAll);
    safetyPctEl.addEventListener('change', drawAll);

    addImageBtn.addEventListener('click', async function(){
      var f=imageFileEl.files && imageFileEl.files[0];
      if(!f){ toast('画像ファイルを選択してください'); return; }
      var res=await fileToBitmapImageOnly(f);
      if(!res) return;
      addImageLayer(f.name, res.bitmap, res.width, res.height);
      imageFileEl.value='';
    });

    imgOpacityEl.addEventListener('input', function(){
      var it=getSelectedImage();
      if(!it){
        imgOpacityLabelEl.textContent=this.value+'%';
        return;
      }
      it.opacity=clamp((+this.value)/100, 0, 1);
      imgOpacityLabelEl.textContent=this.value+'%';
      drawAll();
    });

    speedDecBtn.addEventListener('click', function(){
      speedIndex=Math.max(0, speedIndex-1);
      drawAll();
    });
    speedIncBtn.addEventListener('click', function(){
      speedIndex=Math.min(SPEED_STEPS.length-1, speedIndex+1);
      drawAll();
    });

    var stepWorld=120;
    bindHold(panUpBtn, function(){ panByWorld(0, -stepWorld); });
    bindHold(panDownBtn, function(){ panByWorld(0,  stepWorld); });
    bindHold(panLeftBtn, function(){ panByWorld(-stepWorld, 0); });
    bindHold(panRightBtn,function(){ panByWorld( stepWorld, 0); });

    window.addEventListener('resize', resize);
    canvas.addEventListener('click', onCanvasClick, {passive:true});
    canvas.addEventListener('dblclick', onCanvasDblClick, {passive:false});
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel, {passive:false});

    window.addEventListener('keydown', function(e){
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){
        var r=routes[activeRouteId];
        if(!r) return;
        r.points.pop();
        drawAll();
      }else{
        onKeyDown(e);
      }
    });

    window.addEventListener('paste', pasteImageFromClipboard);

    resize();
    addRoute();
    addJob();
    activeJobId = getOrderedJobIds()[0] || null;
    renderVehiclesUI();
    renderRoutesUI();
    renderJobsUI();
    renderImageList();
    setActiveRoute(activeRouteId);
    updateCursor();
    drawAll();
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', ready);
  else ready();

})();
</script>
</body>
</html>
