<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AGV Simulator - Job順 無限リピート / 画像レイヤ</title>
<style>
  :root {
    --brand:#006666; --panel:#004d4d; --grid:#e6e6e6; --panelThin:#003c3c;
    --scrollTrack:#e0e5e5; --scrollThumb:#ffffff;
  }
  * { box-sizing:border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Meiryo", sans-serif; }
  html, body { height:100%; }
  body { margin:0; display:flex; height:100vh; overflow:hidden; background:#fff; }

  /* ==== サイドバー ==== */
  .sidebar{
    width:520px; flex-shrink:0; color:#fff; background:var(--brand);
    padding:12px 14px; display:flex; flex-direction:column; gap:12px;
    overflow-y:auto; overflow-x:hidden;
  }
  h1 { font-size:18px; margin:6px 0 8px; font-weight:700; }
  .section { background:var(--panel); border-radius:10px; padding:10px; }
  .row { display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap; }
  .btn { cursor:pointer; border:none; border-radius:8px; padding:6px 8px; font-weight:700; font-size:13px; }
  .btn.primary { background:#fff; color:var(--brand); }
  .btn.ghost { background:transparent; border:1px solid #fff; color:#fff; }
  .btn.slim { padding:4px 8px; font-size:12px; border-radius:8px; }
  .status { background:#003d3d; padding:8px; border-radius:8px; font-size:13px; line-height:1.4; }
  .note { font-size:12px; opacity:.9; }
  .small { font-size:12px; }

  /* ==== キャンバス ==== */
  .canvas-wrap { position:relative; flex:1; background:#fff; min-width:260px; }
  canvas#map { position:absolute; inset:0; width:100%; height:100%; display:block; }

  /* オーバーレイUI */
  .canvas-ui { position:absolute; display:flex; align-items:center; gap:8px; }
  .ui-top-right { top:8px; right:8px; background:rgba(0,0,0,.55); color:#fff; padding:6px 8px; border-radius:10px; z-index:6; }
  .ui-bottom-left { left:8px; bottom:28px; background:rgba(0,0,0,.55); color:#fff; padding:4px 8px; border-radius:8px; font-size:12px; pointer-events:none; z-index:6; }
  .speed-btn { cursor:pointer; border:none; width:28px; height:28px; border-radius:8px; background:#fff; color:#333; font-weight:800; display:grid; place-items:center; }
  .speed-label { min-width:44px; text-align:center; font-weight:700; }

  /* ルート一覧 */
  .routes-list { display:flex; flex-direction:column; gap:8px; }
  .route-item {
    background:#003c3c; border-radius:8px; padding:8px;
    display:grid;
    grid-template-columns: 1.2fr 54px 1fr 1fr 1fr auto;
    gap:8px; align-items:center;
  }
  .route-name { font-weight:700; }
  .route-toggle { min-width:120px; }
  .route-mini { width:100%; }
  .route-mini input, .route-mini select {
    width:100%; padding:4px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.35);
    background:rgba(0,0,0,.12); color:#fff; font-size:12px; outline:none;
  }
  .route-mini label { display:block; font-size:11px; opacity:.9; margin-bottom:2px; }

  /* Job */
  .jobs-list { display:flex; flex-direction:column; gap:8px; }
  .job-item{
    background:#003c3c; border-radius:8px; padding:8px;
    display:grid; grid-template-columns: 1fr auto;
    gap:8px; align-items:center;
  }
  .job-top{ display:flex; justify-content:space-between; gap:8px; align-items:center; }
  .job-name{ font-weight:800; }
  .job-box{ display:flex; flex-direction:column; gap:6px; }
  .job-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .job-row select, .job-row input{
    padding:4px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.35);
    background:rgba(0,0,0,.12); color:#fff; font-size:12px; outline:none;
  }
  .job-row .hint{ font-size:12px; opacity:.9; }
  .job-routechips{ display:flex; flex-wrap:wrap; gap:6px; }
  .chip{
    font-size:12px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.25);
    padding:3px 8px; border-radius:999px;
  }
  .chip b{ margin-right:4px; }
  .chip .x{ margin-left:6px; cursor:pointer; opacity:.9; }

  .toast { position:fixed; left:50%; top:18px; transform:translateX(-50%); background:#333; color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transition:opacity .2s ease; pointer-events:none; z-index:9; }
  .toast.show { opacity:.95; }
  .sim-btn { min-width:260px; }

  .vehicle-grid{
    display:grid;
    grid-template-columns: 56px 84px 96px 84px;
    gap:6px; align-items:center; justify-items:start;
  }
  .vehicle-grid .head { font-weight:700; opacity:.9; }
  .vehicle-grid input { width:60px; padding:2px 3px; font-size:12px; }

  .summary-line { display:flex; justify-content:space-between; gap:8px; }
  .summary-line span{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  /* 画像レイヤ */
  .img-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .img-list { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
  .img-item { background:#003c3c; border-radius:8px; padding:6px 8px; display:grid; grid-template-columns: 1fr auto auto; gap:8px; align-items:center; }
  .img-item strong { font-weight:700; }
  .slider-row { margin-top:8px; display:flex; align-items:center; gap:8px; }
  .slider-row input[type="range"] { flex:1; }

  /* ==== キャンバス用 スクロールバー風スライダー ==== */
  .pan-slider-x,.pan-slider-y{ position:absolute; z-index:7; background:transparent; pointer-events:auto; }
  .pan-slider-x{ left:8px; right:28px; bottom:6px; height:14px; }
  .pan-slider-y{ top:8px; bottom:28px; right:8px; width:14px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]{
    -webkit-appearance:none; appearance:none; width:100%; height:14px; margin:0; background:transparent; outline:none;
  }
  .pan-slider-x input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:14px; height:14px; margin-top:-4px; border-radius:8px;
    background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); box-shadow:0 1px 1px rgba(0,0,0,.05); cursor:pointer;
  }
  .pan-slider-x input[type="range"]::-moz-range-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-x input[type="range"]::-moz-range-thumb{
    width:14px; height:14px; border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); cursor:pointer;
  }
  .pan-slider-y input[type="range"]{
    -webkit-appearance:none; appearance:none; position:absolute; top:50%; left:50%;
    transform: translate(-50%, -50%) rotate(-90deg); transform-origin:center center;
    width: calc(100% - 6px); height:14px; margin:0; background:transparent; outline:none;
  }
  .pan-slider-y input[type="range"]::-webkit-slider-runnable-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-y input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:14px; height:14px; margin-top:-4px; border-radius:8px;
    background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); box-shadow:0 1px 1px rgba(0,0,0,.05); cursor:pointer;
  }
  .pan-slider-y input[type="range"]::-moz-range-track{ height:6px; background:var(--scrollTrack); border-radius:8px; }
  .pan-slider-y input[type="range"]::-moz-range-thumb{
    width:14px; height:14px; border-radius:8px; background:var(--scrollThumb); border:1px solid rgba(0,0,0,.15); cursor:pointer;
  }
</style>
</head>

<body>
  <aside class="sidebar">
    <h1>AGV ルート作成（Job順・無限リピート）</h1>

    <div class="section">
      <div class="row"><strong>操作手順</strong></div>
      <ol class="note" style="margin:6px 0 0 18px;">
        <li>ルートを <b>＋</b> で追加し、AGVを選択</li>
        <li><b>経路生成ON</b> のルートだけ編集可（再押しでOFF）</li>
        <li>交点クリックで <b>P1→P2→…</b> の順にポイント追加（水平/垂直のみ）</li>
        <li>交点ダブルクリックで <b>S または G</b>（途中でも端でもOK）</li>
        <li>Jobは「ルート順」を登録（例：R1→R2→R1）</li>
        <li>シミュはJob順に片道で進み、最後まで行ったら先頭へ戻って<b>無限リピート</b></li>
      </ol>
      <div class="note" style="margin-top:6px;">
        ※ ルート接続は「前G＝次S（同一点）」前提。ズレている場合はエラー停止します。
      </div>
    </div>

    <!-- 画像レイヤ -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>画像レイヤ（JPG/PNG）</strong>
        <span class="note">グリッドは常に前面</span>
      </div>

      <div class="img-controls">
        <input id="imageFile" type="file" accept="image/*" />
        <button id="addImageBtn" class="btn primary">＋ 画像追加</button>
      </div>
      <div class="slider-row">
        <label class="small" for="imgOpacity" style="min-width:64px;">不透明度</label>
        <input id="imgOpacity" type="range" min="0" max="100" value="100" />
        <span id="imgOpacityLabel" class="small" style="min-width:40px; text-align:right;">100%</span>
      </div>
      <div class="note">操作：移動/リサイズは「選択ON」の画像のみ。リサイズ四隅ドラッグ（Shiftで縦横比解除）／削除：Delete</div>
      <div id="imgList" class="img-list"></div>
    </div>

    <!-- Job -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>Job（ルート順）</strong>
        <span class="note">Job単位でKPIも表示</span>
      </div>
      <div id="jobsList" class="jobs-list"></div>
      <div class="row">
        <button id="addJob" class="btn primary">＋ Job追加</button>
        <button id="removeJob" class="btn ghost">− 最後のJob削除</button>
      </div>
    </div>

    <!-- ルート -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ルート一覧</strong>
        <span class="note">（表示番号は小さい順の連番）</span>
      </div>
      <div id="routesList" class="routes-list"></div>
      <div class="row">
        <button id="addRoute" class="btn primary">＋ ルート追加</button>
        <button id="removeRoute" class="btn ghost">− 最後のルート削除</button>
      </div>
      <div class="row">
        <button id="exportPngBtn" class="btn ghost slim" title="PNG書き出し">PNG</button>
        <button id="exportBtn" class="btn ghost">JSON書き出し</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" class="btn ghost">JSON読み込み</button>
      </div>
    </div>

    <!-- 車体 -->
    <div class="section">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>車体一覧（A〜J）</strong>
        <span class="note">速度[m/s]・積み下ろし[s]・旋回[s]</span>
      </div>
      <div id="vehicles" class="vehicle-grid"></div>
    </div>

    <!-- KPI -->
    <div class="section status">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>ステータス（距離・KPI：Job “生成ルート距離”）</strong>
        <span class="note">1マス=1m / 端点反転は無し（片道のみ）</span>
      </div>
      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="chargePct">充電率ダウンタイム（0–30%）</label>
        <input id="chargePct" type="number" min="0" max="30" step="1" value="0" style="width:64px;"/>
        <span class="note">※稼働率=(1-充電率)</span>
      </div>
      <div class="row" style="align-items:center; gap:10px;">
        <label class="note" for="safetyPct">安全率（0–50%）</label>
        <input id="safetyPct" type="number" min="0" max="50" step="1" value="0" style="width:64px;"/>
        <span class="note">※KPIに安全係数=(1-安全率)を乗算</span>
      </div>
      <div id="routesSummary" style="display:flex; flex-direction:column; gap:4px;"></div>
    </div>

    <!-- 操作 -->
    <div class="section">
      <div class="row">
        <button id="undo" class="btn ghost">最後のポイント削除（アクティブルート）</button>
      </div>
      <div class="row">
        <button id="clear" class="btn ghost">アクティブルート全消去</button>
      </div>
      <div class="row">
        <button id="simulateToggle" class="btn primary sim-btn">シミュレーション開始（Job順・無限リピート）</button>
      </div>
      <div class="note">Ctrl+Z でも1つ戻せます / Escで画像選択解除</div>
    </div>
  </aside>

  <!-- キャンバス -->
  <div class="canvas-wrap">
    <canvas id="map"></canvas>

    <!-- パン用スライダー -->
    <div class="pan-slider-y"><input id="panY" type="range" min="0" max="100" value="0" orient="vertical"></div>
    <div class="pan-slider-x"><input id="panX" type="range" min="0" max="100" value="0"></div>

    <div class="canvas-ui ui-top-right" id="speedBox">
      <button id="speedDec" class="speed-btn" title="速度を下げる">◀</button>
      <span class="speed-label" id="speedLabel">1×</span>
      <button id="speedInc" class="speed-btn" title="速度を上げる">▶</button>
    </div>
    <div class="canvas-ui ui-bottom-left"><span id="zoomLabel">100%</span></div>
  </div>

  <div id="toast" class="toast"></div>

<script defer>
(function(){
  /* ========================
     定数・状態
  =========================*/
  var PX_PER_M = 40, GRID = PX_PER_M, EPS = 0.5;
  var WORLD = { width: 8000, height: 6000 };
  var SNAP_TOL_WORLD = 14; // world座標（px）でのS/G吸着許容を強めに

  var ROUTE_COLORS = ['#ff9900','#2e86de','#e74c3c','#27ae60','#8e44ad','#16a085','#f39c12','#c0392b','#2980b9','#7f8c8d'];

  var SPEED_STEPS = [0.5, 1, 2, 4], speedIndex = 1;
  function currentSpeed(){ return SPEED_STEPS[speedIndex]; }

  // ズーム 10%〜200%
  var view = { scale:1.0, min:0.1, max:2.0, offsetX:0, offsetY:0, dragging:false, dragStart:{x:0,y:0}, startOffset:{x:0,y:0} };

  // 画像レイヤ
  var images = []; var nextImgId = 1; var selectedImgId = null; var IMG_HANDLE = 10;
  var imgDrag = { active:false, mode:null, start:{x:0,y:0}, base:{x:0,y:0,w:0,h:0}, keepAR:true };

  // ルート
  var routes = {}; var activeRouteId = null; var nextRouteId = 1;

  // Job
  var jobs = {}; var activeJobId = null; var nextJobId = 1;

  // 車体（共通パラメータ）
  var vehicles = {};
  'ABCDEFGHIJ'.split('').forEach(function(ch){
    vehicles[ch] = { speed:1.0, load:5, turn:2 };
  });

  // シミュ
  var simRunning = false;
  var sims = {}; // key: jobId

  // DOM
  var canvas, ctx, toastEl, zoomLabelEl, speedLabelEl, speedDecBtn, speedIncBtn;
  var panXEl, panYEl;
  var routesListEl, addRouteBtn, removeRouteBtn, undoBtn, clearBtn, simulateBtn;
  var vehiclesEl, exportBtn, importBtn, importFile, routesSummaryEl, chargePctEl, safetyPctEl, exportPngBtn;
  var imageFileEl, addImageBtn, imgOpacityEl, imgOpacityLabelEl, imgListEl;
  var jobsListEl, addJobBtn, removeJobBtn;

  /* Utils */
  function toast(msg){
    if(!toastEl) return;
    toastEl.textContent=msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'),1200);
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function approx(a,b,eps){ return Math.abs(a-b) <= (eps||EPS); }
  function samePoint(a,b,tol){
    tol = (typeof tol === 'number') ? tol : 0.01;
    return Math.abs(a.x-b.x)<=tol && Math.abs(a.y-b.y)<=tol;
  }
  function anyBuilding(){
    return Object.keys(routes).some(k=>!!routes[k].building);
  }

  function clientToCanvasXY(clientX, clientY){
    var r=canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }
  function screenToWorld(sx, sy){
    return { x: (sx - view.offsetX)/view.scale, y: (sy - view.offsetY)/view.scale };
  }
  function worldToScreen(wx, wy){
    return { x: wx*view.scale + view.offsetX, y: wy*view.scale + view.offsetY };
  }

  function clampOffsets(){
    var minX = Math.min(0, canvas.width - WORLD.width * view.scale), maxX = 0;
    var minY = Math.min(0, canvas.height - WORLD.height * view.scale), maxY = 0;
    view.offsetX = clamp(view.offsetX, minX, maxX);
    view.offsetY = clamp(view.offsetY, minY, maxY);
  }
  function updatePanSlidersFromView(){
    var vx = -view.offsetX / view.scale, vy = -view.offsetY / view.scale;
    var spanX = Math.max(1, WORLD.width - canvas.width / view.scale);
    var spanY = Math.max(1, WORLD.height - canvas.height / view.scale);
    panXEl.value = clamp(Math.round((vx / spanX) * 100), 0, 100);
    panYEl.value = clamp(Math.round((vy / spanY) * 100), 0, 100);
  }
  function updateViewFromPanSliders(){
    var spanX = Math.max(0, WORLD.width - canvas.width / view.scale);
    var spanY = Math.max(0, WORLD.height - canvas.height / view.scale);
    var vx = (spanX * (+panXEl.value) / 100);
    var vy = (spanY * (+panYEl.value) / 100);
    view.offsetX = -vx * view.scale; view.offsetY = -vy * view.scale;
    clampOffsets(); drawAll();
  }

  /* ==== 画像レイヤ ==== */
  async function fileToBitmapImageOnly(file){
    if(!file) return null;
    try{
      var url = URL.createObjectURL(file);
      var img = new Image();
      img.decoding='async';
      await new Promise((res,rej)=>{ img.onload=()=>res(true); img.onerror=()=>rej(new Error('画像読み込み失敗')); img.src=url; });
      var bmp = await createImageBitmap(img);
      URL.revokeObjectURL(url);
      return { bitmap:bmp, width:bmp.width, height:bmp.height };
    }catch(e){
      toast('画像読み込み失敗: '+e.message);
      return null;
    }
  }
  function addImageLayer(name, bm, w, h){
    var targetW = Math.min( (canvas.width/ view.scale) * 0.6, w );
    var scale = targetW / w; var targetH = h * scale;
    images.push({ id: nextImgId++, name: name||'image', bitmap: bm, x:40, y:40, w:targetW, h:targetH, opacity:1.0 });
    renderImageList(); drawAll();
  }
  function escapeHtml(s){
    return (s||'').replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
  }
  function getSelectedImage(){
    return selectedImgId ? (images.find(it=>it.id===selectedImgId)||null) : null;
  }
  function renderImageList(){
    imgListEl.innerHTML = '';
    images.forEach(function(it){
      var div = document.createElement('div'); div.className='img-item';
      var name = document.createElement('div');
      name.innerHTML = '<strong>#'+it.id+'</strong> <span class="small">'+escapeHtml(it.name)+'</span>';

      var toggle = document.createElement('button'); toggle.className='btn route-toggle';
      var isOn = (selectedImgId === it.id);
      if(isOn){
        toggle.textContent='選択ON'; toggle.style.background='#fff'; toggle.style.color='#006666'; toggle.style.border='none';
      }else{
        toggle.textContent='選択OFF'; toggle.style.background='transparent'; toggle.style.color='#fff'; toggle.style.border='1px solid #fff';
      }
      toggle.addEventListener('click', function(e){
        e.stopPropagation();
        selectedImgId = (selectedImgId===it.id) ? null : it.id;
        if(selectedImgId===it.id){
          imgOpacityEl.value = Math.round(it.opacity*100);
          imgOpacityLabelEl.textContent=(Math.round(it.opacity*100))+'%';
        }
        renderImageList(); drawAll();
      });

      var delBtn = document.createElement('button'); delBtn.className='btn ghost'; delBtn.textContent='削除';
      delBtn.addEventListener('click', function(e){
        e.stopPropagation();
        images = images.filter(x=>x.id!==it.id);
        if(selectedImgId===it.id) selectedImgId=null;
        renderImageList(); drawAll();
      });

      div.appendChild(name); div.appendChild(toggle); div.appendChild(delBtn);
      imgListEl.appendChild(div);
    });
  }

  /* ==== ルート / 幾何 ==== */
  function getOrderedRouteIds(){
    return Object.keys(routes).map(k=>+k).sort((a,b)=>a-b);
  }
  function getDisplayIndex(id){
    var ids=getOrderedRouteIds();
    var idx=ids.indexOf(id);
    return idx===-1? null : (idx+1);
  }
  function polylineFromPoints(r){
    if(!r || !r.points || r.points.length<2) return [];
    var clean=[];
    for(var i=0;i<r.points.length;i++){
      var p={x:r.points[i][0], y:r.points[i][1]};
      if(!clean.length){ clean.push(p); continue; }
      var a=clean[clean.length-1];
      if(approx(a.x,p.x) && approx(a.y,p.y)) continue;
      if(!approx(a.x,p.x) && !approx(a.y,p.y)) continue; // 斜め禁止
      if(clean.length>=2){
        var b=clean[clean.length-2];
        if(approx(b.x,a.x) && approx(a.x,p.x)){ clean[clean.length-1]=p; continue; }
        if(approx(b.y,a.y) && approx(a.y,p.y)){ clean[clean.length-1]=p; continue; }
      }
      clean.push(p);
    }
    return clean;
  }
  function segLenPx(A,B){ return Math.abs(B.x-A.x) + Math.abs(B.y-A.y); }
  function totalLenPx(path){ var S=0; for(var i=0;i<path.length-1;i++) S+=segLenPx(path[i], path[i+1]); return S; }

  function projectToPolylineWorld(xyWorld, path, tolWorld){
    if(!path || path.length<2) return null;
    var best=null, bestDist=Infinity;
    var tol = (typeof tolWorld==='number') ? tolWorld : SNAP_TOL_WORLD;

    for (var i=0;i<path.length-1;i++){
      var A=path[i], B=path[i+1];
      if(approx(A.x,B.x)){
        var dx=Math.abs(xyWorld.x-A.x);
        if(dx<=tol){
          var y=clamp(xyWorld.y, Math.min(A.y,B.y), Math.max(A.y,B.y));
          var d = Math.hypot(dx, xyWorld.y-y);
          if(d<bestDist){ bestDist=d; best={x:A.x,y:y,i:i}; }
        }
      } else if(approx(A.y,B.y)){
        var dy=Math.abs(xyWorld.y-A.y);
        if(dy<=tol){
          var x=clamp(xyWorld.x, Math.min(A.x,B.x), Math.max(A.x,B.x));
          var d = Math.hypot(xyWorld.x-x, dy);
          if(d<bestDist){ bestDist=d; best={x:x,y:A.y,i:i}; }
        }
      }
    }
    return best;
  }

  function progressAlong(path, point){
    var proj=projectToPolylineWorld(point, path, SNAP_TOL_WORLD);
    if(!proj) return null;
    var s=0;
    for(var k=0;k<proj.i;k++) s += segLenPx(path[k], path[k+1]);
    s += segLenPx(path[proj.i], {x:proj.x, y:proj.y});
    return { s:s, pt:{x:proj.x, y:proj.y} };
  }
  function pointAtProgress(path, s){
    s=clamp(s,0,totalLenPx(path));
    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      if(acc + L >= s - EPS){
        var t=(s-acc)/Math.max(1e-6,L);
        var A=path[i], B=path[i+1];
        return approx(A.x,B.x) ? { x:A.x, y:A.y + (B.y-A.y)*t } : { x:A.x + (B.x-A.x)*t, y:A.y };
      }
      acc+=L;
    }
    return { x:path[path.length-1].x, y:path[path.length-1].y };
  }
  function clipPathByProgress(path, s0, s1){
    if(!path || path.length<2) return [];
    var a=Math.min(s0,s1), b=Math.max(s0,s1);
    if(b-a<EPS) return [];
    var out=[];
    var P0=pointAtProgress(path,a), P1=pointAtProgress(path,b);
    out.push(P0);
    var acc=0;
    for(var i=0;i<path.length-1;i++){
      var L=segLenPx(path[i], path[i+1]);
      var accNext=acc+L;
      if(accNext>a+EPS && accNext<b-EPS){
        out.push({x:path[i+1].x, y:path[i+1].y});
      }
      acc=accNext;
    }
    out.push(P1);
    // clean
    var clean=[];
    for(var m=0;m<out.length;m++){
      if(!clean.length){ clean.push(out[m]); continue; }
      var aP=clean[clean.length-1], bP=out[m];
      if(approx(aP.x,bP.x)&&approx(aP.y,bP.y)) continue;
      clean.push(bP);
    }
    return clean;
  }

  function sgSubpathAndMeters(r){
    if(!r || !r.start || !r.goal) return {path:[], meters:0};
    var base=polylineFromPoints(r);
    if(!base.length) return {path:[], meters:0};
    var prS=progressAlong(base, {x:r.start[0], y:r.start[1]});
    var prG=progressAlong(base, {x:r.goal[0], y:r.goal[1]});
    if(!prS || !prG) return {path:[], meters:0};
    var sub=clipPathByProgress(base, prS.s, prG.s);
    var dist_m=Math.abs(prG.s-prS.s)/PX_PER_M;
    return { path:sub, meters:dist_m };
  }

  function headingOf(A,B){
    if(B.x>A.x) return 0;
    if(B.x<A.x) return 180;
    if(B.y>A.y) return 90;
    if(B.y<A.y) return 270;
    return 0;
  }
  function angleDelta(a,b){
    var d=((b-a+540)%360)-180;
    return Math.round(d);
  }
  function lerpAngle(a,b,t){
    var d=angleDelta(a,b);
    return a + d*t;
  }
  function normHeading(h){
    h=((h%360)+360)%360;
    return h;
  }

  /* ==== 待機点（複数） ==== */
  function waitsToProgressList(r, sgPath){
    // r.waits: [{x,y,sec}, ...] (world)
    if(!r || !Array.isArray(r.waits) || !r.waits.length) return [];
    if(!sgPath || sgPath.length<2) return [];
    var out=[];
    for(var i=0;i<r.waits.length;i++){
      var w=r.waits[i];
      var pr=progressAlong(sgPath, {x:w.x, y:w.y});
      if(!pr) continue;
      out.push({ s:pr.s, sec:Math.max(0, +w.sec||0), x:pr.pt.x, y:pr.pt.y, idx:i });
    }
    out.sort((a,b)=>a.s-b.s);
    return out;
  }

  /* ==== KPI（Job単位） ==== */
  function computeRouteTimeOneWaySeconds(route){
    var sg=sgSubpathAndMeters(route);
    if(!sg.path.length || sg.meters<=0) return null;

    var v=vehicles[route.agv] || {speed:1.0, load:5, turn:2};
    var travel = (sg.meters)/Math.max(0.01, v.speed);

    // ルート固有：turnCount（入力）
    var tcount = Math.max(0, (route.turnCount|0));
    var turnTime = tcount * Math.max(0, v.turn);

    // ルート固有：待機（複数）
    var waitSum = 0;
    if(Array.isArray(route.waits)){
      for(var i=0;i<route.waits.length;i++){
        waitSum += Math.max(0, +route.waits[i].sec||0);
      }
    }

    // ルート固有：終端の積み下ろし（片道の最後に1回）
    var dwell = Math.max(0, v.load);

    return travel + turnTime + waitSum + dwell;
  }

  function computeJobCycleSeconds(job){
    if(!job || !job.routeIds || !job.routeIds.length) return null;
    var sum=0;
    for(var i=0;i<job.routeIds.length;i++){
      var r=routes[job.routeIds[i]];
      if(!r) return null;
      var t=computeRouteTimeOneWaySeconds(r);
      if(t==null) return null;
      sum+=t;
    }
    return sum;
  }

  function renderKPI(){
    routesSummaryEl.innerHTML='';
    var chargePct=Math.min(30, Math.max(0, parseFloat(chargePctEl.value)||0));
    var safetyPct=Math.min(50, Math.max(0, parseFloat(safetyPctEl.value)||0));
    var avail=(1-(chargePct/100))*(1-(safetyPct/100));

    var jobIds = Object.keys(jobs).map(k=>+k).sort((a,b)=>a-b);
    if(!jobIds.length){
      routesSummaryEl.textContent='Job無し';
      return;
    }

    jobIds.forEach(function(jid){
      var job = jobs[jid];
      var cyc = computeJobCycleSeconds(job);
      var perH = (cyc ? (3600*Math.max(0.01,avail)/cyc) : 0);

      var line=document.createElement('div');
      line.className='summary-line';
      line.innerHTML =
        '<span><b>Job'+jid+'</b>（AGV '+(job.agv||'-')+'）</span>' +
        '<span>' + (cyc?('KPI: '+perH.toFixed(2)+' 回/時 / 周期 '+cyc.toFixed(1)+'s'):'KPI: −') + '</span>';
      routesSummaryEl.appendChild(line);

      // ルート内訳も軽く
      if(job.routeIds && job.routeIds.length){
        var detail = document.createElement('div');
        detail.className='note';
        detail.textContent = '順序: ' + job.routeIds.map(function(rid){
          var disp=getDisplayIndex(rid);
          return disp?('R'+disp):('R?');
        }).join(' → ');
        routesSummaryEl.appendChild(detail);
      }
    });
  }

  /* ==== 描画 ==== */
  function applyTransform(){ ctx.setTransform(view.scale,0,0,view.scale,view.offsetX,view.offsetY); }
  function resetTransform(){ ctx.setTransform(1,0,0,1,0,0); }

  function drawGrid(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    var minW=(-view.offsetX)/view.scale, minH=(-view.offsetY)/view.scale;
    var maxW=(canvas.width - view.offsetX)/view.scale, maxH=(canvas.height - view.offsetY)/view.scale;

    applyTransform();
    ctx.fillStyle='#fff';
    ctx.fillRect(0,0,WORLD.width,WORLD.height);

    // 画像（背面）
    drawImages();

    // グリッド（前面）
    ctx.strokeStyle='#e6e6e6';
    ctx.lineWidth=1/view.scale;

    var startX=Math.max(0, Math.floor(minW/GRID)*GRID);
    for(var x=startX; x<=Math.min(maxW, WORLD.width); x+=GRID){
      ctx.beginPath(); ctx.moveTo(x, Math.max(0,minH)); ctx.lineTo(x, Math.min(maxH, WORLD.height)); ctx.stroke();
    }
    var startY=Math.max(0, Math.floor(minH/GRID)*GRID);
    for(var y=startY; y<=Math.min(maxH, WORLD.height); y+=GRID){
      ctx.beginPath(); ctx.moveTo(Math.max(0,minW), y); ctx.lineTo(Math.min(maxW, WORLD.width), y); ctx.stroke();
    }
    resetTransform();
  }

  function drawImages(){
    images.forEach(function(it){
      if(!it.bitmap) return;
      ctx.save();
      ctx.globalAlpha=clamp(it.opacity,0,1);
      ctx.drawImage(it.bitmap, it.x, it.y, it.w, it.h);
      ctx.restore();
    });

    if(selectedImgId){
      var it=getSelectedImage();
      if(it){
        ctx.save();
        ctx.lineWidth=1/view.scale;
        ctx.strokeStyle='#00bcd4';
        ctx.setLineDash([6/view.scale, 4/view.scale]);
        ctx.strokeRect(it.x,it.y,it.w,it.h);
        ctx.setLineDash([]);

        var handles=[{x:it.x,y:it.y},{x:it.x+it.w,y:it.y},{x:it.x,y:it.y+it.h},{x:it.x+it.w,y:it.y+it.h}];
        ctx.fillStyle='#00bcd4';
        handles.forEach(function(h){
          ctx.beginPath();
          ctx.arc(h.x,h.y,IMG_HANDLE/view.scale,0,Math.PI*2);
          ctx.fill();
        });
        ctx.restore();
      }
    }
  }

  function drawRoutes(){
    applyTransform();
    getOrderedRouteIds().forEach(function(id){
      var r=routes[id];
      var dispIdx=getDisplayIndex(id);
      var base=polylineFromPoints(r);

      if(base.length>=2){
        ctx.lineWidth=2/view.scale;
        ctx.strokeStyle=r.color;
        ctx.globalAlpha=0.85;
        ctx.beginPath();
        ctx.moveTo(base[0].x, base[0].y);
        for(var i=1;i<base.length;i++) ctx.lineTo(base[i].x, base[i].y);
        ctx.stroke();
        ctx.globalAlpha=1;
      }

      // 点
      for(var j=0;j<r.points.length;j++){
        var p=r.points[j];
        ctx.fillStyle=r.color;
        ctx.beginPath();
        ctx.arc(p[0],p[1],4/view.scale,0,Math.PI*2);
        ctx.fill();
      }

      // S/G
      ctx.fillStyle='#000';
      ctx.font=(16/view.scale)+'px system-ui, sans-serif';
      ctx.textBaseline='top';
      if(r.start) ctx.fillText('S'+dispIdx, r.start[0]-10/view.scale, r.start[1]-18/view.scale);
      if(r.goal)  ctx.fillText('G'+dispIdx, r.goal[0]-10/view.scale, r.goal[1]-18/view.scale);

      // 待機点表示
      if(Array.isArray(r.waits)){
        ctx.save();
        ctx.fillStyle='#111';
        ctx.font=(12/view.scale)+'px system-ui, sans-serif';
        for(var w=0; w<r.waits.length; w++){
          var wp=r.waits[w];
          ctx.beginPath();
          ctx.arc(wp.x, wp.y, 5/view.scale, 0, Math.PI*2);
          ctx.fill();
          ctx.fillText('W'+(w+1), wp.x+6/view.scale, wp.y-10/view.scale);
        }
        ctx.restore();
      }
    });
    resetTransform();
  }

  // 走行前に「次ルート」を光らせる（誘導）
  function drawGlowRoute(sim){
    if(!sim || !simRunning) return;
    var r = routes[sim.curRouteId];
    if(!r || !r.start || !r.goal) return;
    var sg = sim.sgPath;
    if(!sg || sg.length<2) return;

    applyTransform();
    ctx.save();
    ctx.lineCap='round';
    ctx.globalAlpha=0.28;
    ctx.lineWidth=16/view.scale;
    ctx.strokeStyle=r.color;
    ctx.beginPath();
    ctx.moveTo(sg[0].x, sg[0].y);
    for(var i=1;i<sg.length;i++) ctx.lineTo(sg[i].x, sg[i].y);
    ctx.stroke();

    ctx.globalAlpha=1;
    ctx.lineWidth=4/view.scale;
    ctx.beginPath();
    ctx.moveTo(sg[0].x, sg[0].y);
    for(var j=1;j<sg.length;j++) ctx.lineTo(sg[j].x, sg[j].y);
    ctx.stroke();
    ctx.restore();
    resetTransform();
  }

  function drawAGVs(){
    if(!simRunning) return;
    applyTransform();
    Object.keys(sims).forEach(function(jobIdStr){
      var sim = sims[jobIdStr];
      if(!sim) return;

      var r = routes[sim.curRouteId];
      if(!r) return;

      var L=22, W=14;
      var rad=(sim.heading||0)*Math.PI/180;
      ctx.save();
      ctx.translate(sim.pos.x, sim.pos.y);
      ctx.rotate(rad);
      ctx.fillStyle=r.color;
      ctx.fillRect(-L/2, -W/2, L, W);
      ctx.fillStyle='#000';
      ctx.beginPath();
      ctx.moveTo(L/2,0); ctx.lineTo(L/2-4,-3); ctx.lineTo(L/2-4,3);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    });
    resetTransform();
  }

  function drawAll(){
    clampOffsets();
    drawGrid();
    drawRoutes();

    // 光らせ（各Jobで同時）
    if(simRunning){
      Object.keys(sims).forEach(function(jobIdStr){
        drawGlowRoute(sims[jobIdStr]);
      });
    }
    drawAGVs();

    updatePanSlidersFromView();
    if(zoomLabelEl) zoomLabelEl.textContent = Math.round(view.scale*100) + '%';
    if(speedLabelEl) speedLabelEl.textContent = currentSpeed().toString() + '×';
    renderKPI();
  }

  function resize(){
    var sidebar=document.querySelector('.sidebar');
    var sw=sidebar?sidebar.offsetWidth:520;
    var w=Math.max(260, window.innerWidth - sw);
    var h=window.innerHeight;
    canvas.width=w; canvas.height=h;
    clampOffsets();
    updatePanSlidersFromView();
    drawAll();
  }

  /* ==== ルートUI ==== */
  function addRoute(){
    var id=nextRouteId++;
    var color=ROUTE_COLORS[(id-1)%ROUTE_COLORS.length];
    routes[id]={
      id:id, agv:'A', color:color, building:false,
      points:[], start:null, goal:null,
      turnCount:0,
      waits:[] // [{x,y,sec}]
    };
    activeRouteId=id;
    renderRoutesUI();
    drawAll();
    updateCursor();
  }
  function removeLastRoute(){
    var ids=getOrderedRouteIds();
    if(!ids.length) return;
    var lastId=ids[ids.length-1];
    delete routes[lastId];

    // Jobからも削除
    Object.keys(jobs).forEach(function(jid){
      jobs[jid].routeIds = (jobs[jid].routeIds||[]).filter(rid=>rid!==lastId);
    });

    if(activeRouteId===lastId){
      ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[ids.length-1]:null;
    }

    renderJobsUI();
    renderRoutesUI();
    drawAll();
    updateCursor();
  }
  function setActiveRoute(id){
    if(id==null){
      var ids=getOrderedRouteIds();
      activeRouteId=ids.length?ids[0]:null;
    }else{
      activeRouteId=id;
    }
    drawAll();
    updateCursor();
  }
  function setRouteAGV(id,agv){
    if(routes[id]) routes[id].agv=agv;
    // JobのAGVと整合チェック（JobはAGV固定）
    Object.keys(jobs).forEach(function(jid){
      var job = jobs[jid];
      if(!job.routeIds || !job.routeIds.length) return;
      // job.agv と一致しないルートが入った場合は警告表示だけ
      if(job.agv && job.routeIds.includes(id) && routes[id].agv !== job.agv){
        toast('注意：Job'+jid+'はAGV '+job.agv+'。R'+getDisplayIndex(id)+'のAGVが一致していません');
      }
    });
    renderJobsUI();
    drawAll();
  }
  function toggleRouteBuilding(id){
    if(!routes[id]) return;
    var wasOn=!!routes[id].building;
    Object.keys(routes).forEach(k=>routes[k].building=false);
    routes[id].building=!wasOn;
    activeRouteId=id;
    renderRoutesUI();
    drawAll();
    updateCursor();
  }

  function renderRoutesUI(){
    routesListEl.innerHTML='';
    var ids=getOrderedRouteIds();

    ids.forEach(function(id){
      var r=routes[id];
      var dispIdx=getDisplayIndex(id);

      var item=document.createElement('div');
      item.className='route-item';

      // name
      var name=document.createElement('div');
      name.className='route-name';
      name.textContent='R'+dispIdx+' ';
      var chip=document.createElement('span');
      chip.style.cssText='display:inline-block;width:10px;height:10px;border-radius:999px;background:'+r.color+';margin-left:6px;';
      name.appendChild(chip);

      // agv
      var sel=document.createElement('select');
      sel.className='route-mini';
      'ABCDEFGHIJ'.split('').forEach(function(ch){
        var opt=document.createElement('option');
        opt.value=ch; opt.textContent=ch;
        if(ch===r.agv) opt.selected=true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', function(e){ e.stopPropagation(); setRouteAGV(id, this.value); });

      // build
      var btn=document.createElement('button');
      btn.className='btn route-toggle';
      if(r.building){
        btn.textContent='経路生成ON'; btn.style.background='#fff'; btn.style.color='#006666'; btn.style.border='none';
      }else{
        btn.textContent='経路生成OFF'; btn.style.background='transparent'; btn.style.color='#fff'; btn.style.border='1px solid #fff';
      }
      btn.addEventListener('click', function(e){ e.stopPropagation(); toggleRouteBuilding(id); });

      // turnCount
      var turnBox=document.createElement('div'); turnBox.className='route-mini';
      turnBox.innerHTML='<label>旋回数</label>';
      var turnInp=document.createElement('input');
      turnInp.type='number'; turnInp.min='0'; turnInp.step='1';
      turnInp.value=(r.turnCount||0);
      turnInp.addEventListener('change', function(e){
        e.stopPropagation();
        var v=parseInt(this.value,10);
        if(!isFinite(v) || v<0) v=0;
        routes[id].turnCount=v;
        drawAll();
      });
      turnBox.appendChild(turnInp);

      // waits editor (追加だけ簡易：選択中ルートに対してW追加、削除はリストで)
      var waitBox=document.createElement('div'); waitBox.className='route-mini';
      waitBox.innerHTML='<label>待機点</label>';
      var waitBtn=document.createElement('button');
      waitBtn.className='btn ghost slim';
      waitBtn.textContent='＋W追加';
      waitBtn.title='キャンバス上で次クリックした点を待機点にする';
      waitBtn.addEventListener('click', function(e){
        e.stopPropagation();
        setActiveRoute(id);
        routes[id].placingWait = !routes[id].placingWait;
        toast(routes[id].placingWait ? '待機点追加モード：キャンバスをクリック' : '待機点追加モードOFF');
        renderRoutesUI();
      });
      waitBox.appendChild(waitBtn);

      // sg delete
      var sgBtn=document.createElement('button');
      sgBtn.className='btn ghost';
      sgBtn.textContent='S/G削除';
      sgBtn.addEventListener('click', function(e){
        e.stopPropagation();
        if(routes[id]){
          routes[id].start=null; routes[id].goal=null;
          drawAll();
        }
      });

      item.addEventListener('click', function(){ setActiveRoute(id); });

      item.appendChild(name);
      item.appendChild(sel);
      item.appendChild(btn);
      item.appendChild(turnBox);
      item.appendChild(waitBox);
      item.appendChild(sgBtn);

      routesListEl.appendChild(item);

      // waits list under (compact)
      if(Array.isArray(r.waits) && r.waits.length){
        var list=document.createElement('div');
        list.className='note';
        list.style.margin='2px 0 0 0';
        list.textContent='W: ' + r.waits.map(function(w,i){ return (i+1)+':'+(w.sec||0)+'s'; }).join(' / ') + '（削除：キャンバスで点に近づきDel）';
        routesListEl.appendChild(list);
      }
    });
  }

  /* ==== Job UI ==== */
  function getOrderedJobIds(){
    return Object.keys(jobs).map(k=>+k).sort((a,b)=>a-b);
  }

  function addJob(){
    var id=nextJobId++;
    jobs[id] = { id:id, agv:'A', routeIds:[] };
    activeJobId = id;
    renderJobsUI();
    drawAll();
  }

  function removeLastJob(){
    var ids=getOrderedJobIds();
    if(!ids.length) return;
    var lastId=ids[ids.length-1];
    delete jobs[lastId];
    if(activeJobId===lastId){
      ids=getOrderedJobIds();
      activeJobId=ids.length?ids[ids.length-1]:null;
    }
    renderJobsUI();
    drawAll();
  }

  function setJobAGV(jobId, agv){
    if(!jobs[jobId]) return;
    jobs[jobId].agv = agv;

    // Job内のルートAGV不一致はエラー扱い（シミュ開始時にもチェック）
    var bad = (jobs[jobId].routeIds||[]).some(function(rid){
      return routes[rid] && routes[rid].agv !== agv;
    });
    if(bad) toast('注意：Job'+jobId+'内にAGV不一致のルートがあります');
    renderJobsUI();
    drawAll();
  }

  function addRouteToJob(jobId, routeId){
    var job = jobs[jobId];
    var r = routes[routeId];
    if(!job || !r) return;

    // AGV一致しないとエラー（要望）
    if(r.agv !== job.agv){
      toast('エラー：Job'+jobId+'(AGV '+job.agv+') と R'+getDisplayIndex(routeId)+'(AGV '+r.agv+') が一致しません');
      return;
    }
    job.routeIds.push(routeId);
    renderJobsUI();
    drawAll();
  }

  function removeRouteFromJob(jobId, idx){
    var job = jobs[jobId];
    if(!job || !job.routeIds) return;
    job.routeIds.splice(idx,1);
    renderJobsUI();
    drawAll();
  }

  function renderJobsUI(){
    jobsListEl.innerHTML='';
    var jobIds = getOrderedJobIds();

    jobIds.forEach(function(jobId){
      var job = jobs[jobId];

      var wrap = document.createElement('div');
      wrap.className='job-item';

      var left = document.createElement('div');
      left.className='job-box';

      var top = document.createElement('div');
      top.className='job-top';
      var name = document.createElement('div');
      name.className='job-name';
      name.textContent = 'Job'+jobId;

      var rightBtns = document.createElement('div');
      rightBtns.style.display='flex';
      rightBtns.style.gap='6px';

      var setAct = document.createElement('button');
      setAct.className='btn ghost slim';
      setAct.textContent = (activeJobId===jobId) ? '選択中' : '選択';
      setAct.addEventListener('click', function(e){
        e.stopPropagation();
        activeJobId = jobId;
        renderJobsUI();
      });

      rightBtns.appendChild(setAct);

      top.appendChild(name);
      top.appendChild(rightBtns);

      var row1 = document.createElement('div');
      row1.className='job-row';
      row1.innerHTML = '<span class="hint">AGV:</span>';
      var agvSel = document.createElement('select');
      'ABCDEFGHIJ'.split('').forEach(function(ch){
        var opt=document.createElement('option'); opt.value=ch; opt.textContent=ch;
        if(ch===job.agv) opt.selected=true;
        agvSel.appendChild(opt);
      });
      agvSel.addEventListener('change', function(){ setJobAGV(jobId, this.value); });
      row1.appendChild(agvSel);

      // route add
      var row2 = document.createElement('div');
      row2.className='job-row';
      row2.innerHTML = '<span class="hint">ルート追加:</span>';
      var routeSel = document.createElement('select');
      var ids = getOrderedRouteIds();
      var any=false;
      ids.forEach(function(rid){
        var r=routes[rid];
        var disp=getDisplayIndex(rid);
        var opt=document.createElement('option');
        opt.value=rid;
        opt.textContent='R'+disp+' (AGV '+r.agv+')';
        // JobのAGV一致のものだけ選べるように
        if(r.agv !== job.agv){
          opt.disabled = true;
        }else{
          any=true;
        }
        routeSel.appendChild(opt);
      });
      if(!any){
        var opt=document.createElement('option');
        opt.textContent='（AGV一致のルートなし）';
        opt.disabled=true; opt.selected=true;
        routeSel.appendChild(opt);
      }
      var addBtn = document.createElement('button');
      addBtn.className='btn ghost slim';
      addBtn.textContent='追加';
      addBtn.addEventListener('click', function(){
        var rid = parseInt(routeSel.value,10);
        if(isFinite(rid)) addRouteToJob(jobId, rid);
      });
      row2.appendChild(routeSel);
      row2.appendChild(addBtn);

      // chips
      var chips = document.createElement('div');
      chips.className='job-routechips';
      if(job.routeIds && job.routeIds.length){
        job.routeIds.forEach(function(rid, idx){
          var disp = getDisplayIndex(rid);
          var chip = document.createElement('div');
          chip.className='chip';
          chip.innerHTML = '<b>'+(disp?('R'+disp):('R?'))+'</b><span class="x" title="削除">×</span>';
          chip.querySelector('.x').addEventListener('click', function(e){
            e.stopPropagation();
            removeRouteFromJob(jobId, idx);
          });
          chips.appendChild(chip);
        });
      }else{
        var empty=document.createElement('div');
        empty.className='note';
        empty.textContent='（まだルートが登録されていません）';
        chips.appendChild(empty);
      }

      left.appendChild(top);
      left.appendChild(row1);
      left.appendChild(row2);
      left.appendChild(chips);

      wrap.appendChild(left);
      jobsListEl.appendChild(wrap);
    });
  }

  /* ==== 入力（画像／パン／ズーム／ルート編集） ==== */
  function hitImageHandle(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY), w=screenToWorld(s.x, s.y);
    var pts=[{x:it.x,y:it.y,c:'nw'},{x:it.x+it.w,y:it.y,c:'ne'},{x:it.x,y:it.y+it.h,c:'sw'},{x:it.x+it.w,y:it.y+it.h,c:'se'}];
    for(var i=0;i<pts.length;i++){
      var p=pts[i];
      var dx=Math.abs(w.x-p.x)*view.scale, dy=Math.abs(w.y-p.y)*view.scale;
      if(Math.hypot(dx,dy)<=IMG_HANDLE+2) return p.c;
    }
    return null;
  }
  function hitImageBody(it, clientX, clientY){
    var s=clientToCanvasXY(clientX, clientY), w=screenToWorld(s.x, s.y);
    return (w.x>=it.x && w.x<=it.x+it.w && w.y>=it.y && w.y<=it.y+it.h);
  }
  function pickImage(clientX, clientY){
    for(var i=images.length-1;i>=0;i--){
      var it=images[i];
      var h=hitImageHandle(it, clientX, clientY);
      if(h) return {it:it,mode:h};
      if(hitImageBody(it, clientX, clientY)) return {it:it,mode:'move'};
    }
    return null;
  }

  function snapToGridWorld(w){
    return { x: Math.round(w.x/GRID)*GRID, y: Math.round(w.y/GRID)*GRID };
  }

  function onCanvasClick(e){
    var r=routes[activeRouteId];
    if(!r) return;

    // 待機点追加モード
    if(r.placingWait){
      var s=clientToCanvasXY(e.clientX,e.clientY);
      var w=screenToWorld(s.x,s.y);
      var g=snapToGridWorld(w);
      var sec = 3; // 既定
      r.waits.push({x:g.x, y:g.y, sec:sec});
      r.placingWait=false;
      toast('待機点を追加（'+sec+'s）');
      renderRoutesUI();
      drawAll();
      return;
    }

    // ルート編集
    if(r.building){
      var s2=clientToCanvasXY(e.clientX,e.clientY);
      var w2=screenToWorld(s2.x,s2.y);
      var xy=snapToGridWorld(w2);

      if(r.points.length>0){
        var a={x:r.points[r.points.length-1][0], y:r.points[r.points.length-1][1]};
        if(approx(a.x,xy.x)&&approx(a.y,xy.y)) return;
        if(!approx(a.x,xy.x) && !approx(a.y,xy.y)){
          toast('直前の点と水平/垂直にしてください');
          return;
        }
      }
      r.points.push([xy.x, xy.y]);
      drawAll();
      return;
    }
    // それ以外は何もしない（画像選択はボタン）
  }

  function onCanvasDblClick(e){
    var r=routes[activeRouteId];
    if(!r) return;
    e.preventDefault();
    if(!r.building) return;

    var s=clientToCanvasXY(e.clientX,e.clientY);
    var w=screenToWorld(s.x,s.y);
    var xy=snapToGridWorld(w);

    var base=polylineFromPoints(r);
    if(base.length<2){
      toast('先にポイントを2点以上追加してください');
      return;
    }

    // S/Gは「ルート線上へ強吸着」
    var snapped = projectToPolylineWorld(xy, base, SNAP_TOL_WORLD);
    if(!snapped){
      toast('S/Gはルート線上に設定してください');
      return;
    }
    var sxy=[snapped.x, snapped.y];

    if(!r.start){
      r.start=sxy; drawAll(); return;
    }
    if(!r.goal){
      r.goal=sxy; drawAll(); return;
    }
    toast('S/Gは各ルートで2点まで（S→G）');
  }

  function onMouseDown(e){
    if(anyBuilding()) return; // 経路生成中はパン/画像操作禁止
    var itSel=getSelectedImage();
    if(itSel){
      var pick=pickImage(e.clientX, e.clientY);
      if(pick && pick.it.id===itSel.id){
        imgDrag.active=true; imgDrag.mode=pick.mode; imgDrag.start=clientToCanvasXY(e.clientX,e.clientY);
        imgDrag.keepAR=!e.shiftKey; imgDrag.base={ x:itSel.x, y:itSel.y, w:itSel.w, h:itSel.h };
        e.preventDefault();
        return;
      }
    }
    // パン
    view.dragging=true;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.dragStart=s;
    view.startOffset={ x:view.offsetX, y:view.offsetY };
    canvas.style.cursor='grabbing';
    e.preventDefault();
  }
  function onMouseMove(e){
    if(imgDrag.active && selectedImgId){
      var it=getSelectedImage();
      if(!it) return;
      var cur=clientToCanvasXY(e.clientX,e.clientY);
      var dx=(cur.x-imgDrag.start.x)/view.scale;
      var dy=(cur.y-imgDrag.start.y)/view.scale;

      if(imgDrag.mode==='move'){
        it.x=imgDrag.base.x+dx;
        it.y=imgDrag.base.y+dy;
      }else{
        var bx=imgDrag.base.x, by=imgDrag.base.y, bw=imgDrag.base.w, bh=imgDrag.base.h;
        var ar=bw/Math.max(1e-6,bh);

        var nx=bx, ny=by, nw=bw, nh=bh;

        if(imgDrag.mode==='nw'){ nx=bx+dx; ny=by+dy; nw=bw-dx; nh=bh-dy; }
        else if(imgDrag.mode==='ne'){ ny=by+dy; nw=bw+dx; nh=bh-dy; }
        else if(imgDrag.mode==='sw'){ nx=bx+dx; nw=bw-dx; nh=bh+dy; }
        else if(imgDrag.mode==='se'){ nw=bw+dx; nh=bh+dy; }

        nw=Math.max(10,nw); nh=Math.max(10,nh);

        if(imgDrag.keepAR){
          if(Math.abs(nw-bw) > Math.abs(nh-bh)) nh=nw/ar; else nw=nh*ar;
          if(imgDrag.mode==='nw'){ nx=bx+(bw-nw); ny=by+(bh-nh); }
          if(imgDrag.mode==='ne'){ ny=by+(bh-nh); }
          if(imgDrag.mode==='sw'){ nx=bx+(bw-nw); }
        }
        it.x=nx; it.y=ny; it.w=nw; it.h=nh;
      }
      drawAll();
      return;
    }

    if(!view.dragging) return;
    var s=clientToCanvasXY(e.clientX,e.clientY);
    view.offsetX=view.startOffset.x + (s.x - view.dragStart.x);
    view.offsetY=view.startOffset.y + (s.y - view.dragStart.y);
    clampOffsets();
    drawAll();
  }
  function onMouseUp(){
    if(imgDrag.active){ imgDrag.active=false; imgDrag.mode=null; return; }
    if(!view.dragging) return;
    view.dragging=false;
    updateCursor();
  }

  function zoomAt(newScale, clientX, clientY){
    newScale=clamp(newScale, view.min, view.max);
    var s=clientToCanvasXY(clientX,clientY);
    var w=screenToWorld(s.x,s.y);
    view.scale=newScale;
    var scr=worldToScreen(w.x,w.y);
    view.offsetX += (s.x - scr.x);
    view.offsetY += (s.y - scr.y);
    clampOffsets();
    drawAll();
  }
  function onWheel(e){
    if(anyBuilding()) return;
    e.preventDefault();
    var factor=(e.deltaY<0)?1.1:0.9;
    zoomAt(view.scale*factor, e.clientX, e.clientY);
  }
  function updateCursor(){
    canvas.style.cursor = anyBuilding()? 'crosshair' : 'grab';
  }

  function findNearestWait(route, worldPt, tolWorld){
    tolWorld = (typeof tolWorld==='number') ? tolWorld : 12;
    if(!route || !Array.isArray(route.waits) || !route.waits.length) return -1;
    var best=-1, bestD=Infinity;
    for(var i=0;i<route.waits.length;i++){
      var w=route.waits[i];
      var d=Math.hypot(worldPt.x-w.x, worldPt.y-w.y);
      if(d<bestD){ bestD=d; best=i; }
    }
    return (bestD<=tolWorld) ? best : -1;
  }

  function onKeyDown(e){
    if(e.key==='Delete' || e.key==='Backspace'){
      // 画像削除
      var it=getSelectedImage();
      if(it){
        images=images.filter(x=>x.id!==it.id);
        selectedImgId=null;
        renderImageList();
        drawAll();
        e.preventDefault();
        return;
      }
      // 待機点削除（アクティブルート近傍）
      var r=routes[activeRouteId];
      if(r){
        // マウス位置が取れないので「画面中心」の近傍を消す（簡易）
        var w=screenToWorld(canvas.width/2, canvas.height/2);
        var idx=findNearestWait(r, w, 18);
        if(idx>=0){
          r.waits.splice(idx,1);
          toast('待機点を削除');
          renderRoutesUI();
          drawAll();
          e.preventDefault();
        }
      }
    } else if(e.key==='Escape'){
      if(selectedImgId){
        selectedImgId=null;
        renderImageList();
        drawAll();
      }
    }
  }

  /* ==== 保存/読込/PNG ==== */
  function onExport(){
    var imgMeta=images.map(it=>({ id:it.id, name:it.name, x:it.x, y:it.y, w:it.w, h:it.h, opacity:it.opacity }));
    var data={
      routes: routes,
      jobs: jobs,
      vehicles: vehicles,
      images: imgMeta,
      meta:{ pxPerM:PX_PER_M, world:WORLD, ts:Date.now() }
    };
    var blob=new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    var a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='agv_simulator_job.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function onImport(evt){
    var file=evt.target.files && evt.target.files[0];
    if(!file) return;
    var reader=new FileReader();
    reader.onload=function(){
      try{
        var obj=JSON.parse(reader.result);

        if(obj.meta && obj.meta.world) WORLD=obj.meta.world;
        if(obj.vehicles) vehicles=obj.vehicles;

        if(obj.routes){
          routes={};
          Object.keys(obj.routes).forEach(function(k){
            routes[+k]=obj.routes[k];
          });
        }
        nextRouteId=(Math.max(0, ...Object.keys(routes).map(k=>+k)) || 0)+1;

        if(obj.jobs){
          jobs={};
          Object.keys(obj.jobs).forEach(function(k){
            jobs[+k]=obj.jobs[k];
          });
        }else{
          jobs={};
        }
        nextJobId=(Math.max(0, ...Object.keys(jobs).map(k=>+k)) || 0)+1;

        images=[];
        if(Array.isArray(obj.images)&&obj.images.length){
          toast('JSON内の画像はメタのみ復元（ビットマップは含まれません）');
          obj.images.forEach(function(m){
            images.push({ id:m.id||(nextImgId++), name:m.name||'image', bitmap:null, x:m.x||40, y:m.y||40, w:m.w||200, h:m.h||200, opacity: (typeof m.opacity==='number'?m.opacity:1) });
            nextImgId=Math.max(nextImgId, (m.id||0)+1);
          });
        }

        renderVehiclesUI();
        renderRoutesUI();
        renderJobsUI();

        setActiveRoute(null);
        activeJobId = getOrderedJobIds()[0] || null;

        renderImageList();
        clampOffsets();
        drawAll();
        updateCursor();
      }catch(err){
        toast('読み込みエラー: '+err.message);
      }
    };
    reader.readAsText(file);
  }

  function onExportPNG(){
    drawAll();
    canvas.toBlob(function(blob){
      var a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='agv_simulator.png';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),0);
    }, 'image/png');
  }

  /* ==== シミュ（Job順・片道・無限リピート） ==== */
  function validateJobBeforeSim(job){
    if(!job) return 'Jobがありません';
    if(!job.routeIds || !job.routeIds.length) return 'Jobにルートが登録されていません';

    // ルート存在＆AGV一致
    for(var i=0;i<job.routeIds.length;i++){
      var rid=job.routeIds[i];
      var r=routes[rid];
      if(!r) return 'Job内に存在しないルートがあります';
      if(r.agv !== job.agv) return 'JobのAGVとルートのAGVが一致していません（Job'+job.id+'）';
      if(!r.start || !r.goal) return 'S/G未設定のルートがあります（R'+getDisplayIndex(rid)+'）';
      var sg=sgSubpathAndMeters(r).path;
      if(!sg || sg.length<2) return 'SG区間が無効なルートがあります（R'+getDisplayIndex(rid)+'）';
    }

    // 接続（前G＝次S 同一点）チェック（順番通り）
    for(var k=0;k<job.routeIds.length-1;k++){
      var rA=routes[job.routeIds[k]];
      var rB=routes[job.routeIds[k+1]];
      var sgA=sgSubpathAndMeters(rA).path;
      var sgB=sgSubpathAndMeters(rB).path;
      var GA=sgA[sgA.length-1], SB=sgB[0];
      if(!samePoint(GA, SB, 0.01)){
        return 'ルート接続不一致：R'+getDisplayIndex(rA.id)+'のG と R'+getDisplayIndex(rB.id)+'のS が同一点ではありません';
      }
    }
    // 最後→最初（無限リピート想定）
    var rLast=routes[job.routeIds[job.routeIds.length-1]];
    var rFirst=routes[job.routeIds[0]];
    var sgL=sgSubpathAndMeters(rLast).path;
    var sgF=sgSubpathAndMeters(rFirst).path;
    var GL=sgL[sgL.length-1], SF=sgF[0];
    if(!samePoint(GL, SF, 0.01)){
      return 'リピート接続不一致：最後ルートG と 先頭ルートS が同一点ではありません';
    }

    return null;
  }

  function goNextRouteInJobRepeat(sim){
    var job = jobs[sim.jobId];
    if(!job || !job.routeIds || !job.routeIds.length) return false;

    // 現ルートのG
    var prevPath = sim.sgPath;
    var prevG = (prevPath && prevPath.length) ? prevPath[prevPath.length-1] : null;

    sim.routeIndex++;
    if(sim.routeIndex >= job.routeIds.length){
      sim.routeIndex = 0; // 無限リピート
    }

    var rid = job.routeIds[sim.routeIndex];
    var r = routes[rid];
    if(!r) return false;

    var sg = sgSubpathAndMeters(r).path;
    if(!sg || sg.length<2) return false;

    var nextS = sg[0];

    // 同一点担保（ズレたら停止）
    if(prevG && !samePoint(prevG, nextS, 0.01)){
      simRunning = false;
      sims = {};
      simulateBtn.textContent='シミュレーション開始（Job順・無限リピート）';
      toast('エラー：ルート接続不一致（前Gと次Sが同一点ではありません）');
      return false;
    }

    sim.curRouteId = rid;
    sim.sgPath = sg;
    sim.waitsProg = waitsToProgressList(r, sg);
    sim.waitHit = {};
    sim.segIndex = 0;
    sim.pos = {x: nextS.x, y: nextS.y};
    sim.heading = headingOf(sg[0], sg[1]);

    // 走行前の誘導（光らせ）
    sim.phase = 'glow';
    sim.preGlowUntilV = sim.vtime_ms + 600;
    return true;
  }

  function onSimToggle(){
    if(simRunning){
      simRunning=false;
      sims={};
      simulateBtn.textContent='シミュレーション開始（Job順・無限リピート）';
      drawAll();
      return;
    }

    // 走行中ルート編集中禁止
    if(anyBuilding()){
      toast('経路生成ONをOFFにしてから開始してください');
      return;
    }

    sims = {};
    var jobIds = getOrderedJobIds();
    if(!jobIds.length){
      toast('Jobがありません');
      return;
    }

    // Job全部同時に回す（必要なければ後で「activeJobだけ」に変更可能）
    var any=false;
    for(var j=0;j<jobIds.length;j++){
      var jid = jobIds[j];
      var job = jobs[jid];

      var err = validateJobBeforeSim(job);
      if(err){
        toast('Job'+jid+'：'+err);
        return;
      }

      var rid0 = job.routeIds[0];
      var r0 = routes[rid0];
      var sg0 = sgSubpathAndMeters(r0).path;

      var agv = job.agv;
      var speed = vehicles[agv] ? vehicles[agv].speed : 1.0;

      sims[jid] = {
        jobId: jid,
        routeIndex: 0,
        curRouteId: rid0,
        sgPath: sg0,
        waitsProg: waitsToProgressList(r0, sg0),
        waitHit: {},
        segIndex: 0,
        pixPerSec: speed * PX_PER_M,
        lastRealTs: performance.now(),
        vtime_ms: 0,
        pos: {x: sg0[0].x, y: sg0[0].y},
        heading: headingOf(sg0[0], sg0[1]),
        phase: 'glow',
        preGlowUntilV: 600,
        dwellEndV: null,
        // 旋回アニメ
        turning: false,
        turnStartHeading: 0,
        targetHeading: 0,
        turnStartV: 0,
        turnEndV: 0
      };
      any=true;
    }

    if(!any){
      toast('有効なJobがありません');
      return;
    }

    simRunning=true;
    simulateBtn.textContent='シミュレーション停止';
    requestAnimationFrame(stepSimAll);
  }

  function beginTurn(sim, fromH, toH, turnS){
    sim.turning = true;
    sim.turnStartHeading = fromH;
    sim.targetHeading = toH;
    sim.turnStartV = sim.vtime_ms;
    sim.turnEndV = sim.vtime_ms + Math.max(0, turnS)*1000;
  }

  function stepSimAll(tsReal){
    if(!simRunning) return;

    var still=false;

    Object.keys(sims).forEach(function(jobIdStr){
      var sim = sims[jobIdStr];
      if(!sim) return;
      still=true;

      var job = jobs[sim.jobId];
      var r = routes[sim.curRouteId];
      if(!job || !r) return;

      var agv = job.agv;
      var v = vehicles[agv] || {speed:1.0, load:5, turn:2};
      var turnS = Math.max(0, +v.turn || 0);
      var loadS = Math.max(0, +v.load || 0);

      var dtReal=(tsReal - sim.lastRealTs)/1000;
      sim.lastRealTs=tsReal;
      var dtScaled=dtReal*currentSpeed();
      sim.vtime_ms += dtScaled*1000;

      // 誘導（光らせ）フェーズ
      if(sim.phase==='glow'){
        if(sim.vtime_ms < sim.preGlowUntilV) return;
        sim.phase='move';
      }

      // 旋回中
      if(sim.turning){
        if(sim.vtime_ms < sim.turnEndV){
          var t = (sim.vtime_ms - sim.turnStartV) / Math.max(1, (sim.turnEndV - sim.turnStartV));
          t = clamp(t,0,1);
          sim.heading = lerpAngle(sim.turnStartHeading, sim.targetHeading, t);
          return;
        }else{
          sim.heading = normHeading(sim.targetHeading);
          sim.turning = false;
        }
      }

      // 待機（終端積み下ろし or 待機点）
      if(sim.phase==='dwell'){
        if(sim.vtime_ms < sim.dwellEndV) return;
        sim.phase='move';
        sim.dwellEndV=null;
        // 終端待機だった場合は次ルートへ
        if(sim._dwellReason === 'end'){
          sim._dwellReason = null;
          goNextRouteInJobRepeat(sim);
        }
        return;
      }

      var path = sim.sgPath;
      if(!path || path.length<2) return;

      // 終端チェック（片道）
      var aIdx = sim.segIndex;
      var bIdx = aIdx + 1;

      if(bIdx >= path.length){
        // ルート終端（G）に到達：積み下ろし（片道の最後に1回）→次ルートへ
        sim.phase='dwell';
        sim._dwellReason='end';
        sim.dwellEndV = sim.vtime_ms + loadS*1000;
        return;
      }

      // 旋回要求（進行方向が変わる時）
      var A = path[aIdx], B = path[bIdx];
      var desiredHeading = headingOf(A,B);
      var d = angleDelta(sim.heading, desiredHeading);
      if(d !== 0 && turnS > 0){
        beginTurn(sim, sim.heading, desiredHeading, turnS);
        return;
      }else{
        sim.heading = desiredHeading;
      }

      // 移動
      var move = sim.pixPerSec * dtScaled;

      if(!approx(A.x,B.x)){
        var dirx = Math.sign(B.x - sim.pos.x);
        var remain = Math.abs(B.x - sim.pos.x);
        if(move >= remain){
          sim.pos.x = B.x; sim.pos.y = B.y;
          sim.segIndex = bIdx;
        }else{
          sim.pos.x += dirx*move;
        }
      }else{
        var diry = Math.sign(B.y - sim.pos.y);
        var remainy = Math.abs(B.y - sim.pos.y);
        if(move >= remainy){
          sim.pos.x = B.x; sim.pos.y = B.y;
          sim.segIndex = bIdx;
        }else{
          sim.pos.y += diry*move;
        }
      }

      // 待機点（複数）：progressで一度だけ踏む
      if(sim.waitsProg && sim.waitsProg.length){
        var pr = progressAlong(path, sim.pos);
        if(pr){
          for(var wi=0; wi<sim.waitsProg.length; wi++){
            var W = sim.waitsProg[wi];
            var key = 'w'+W.idx;
            if(sim.waitHit[key]) continue;
            if(pr.s >= W.s - 1.0){ // 少し手前で判定
              sim.waitHit[key]=true;
              sim.phase='dwell';
              sim._dwellReason='wait';
              sim.dwellEndV = sim.vtime_ms + (W.sec*1000);
              return;
            }
          }
        }
      }

      // セグメント到達後、次セグメントで旋回が必要なら先読みして旋回
      if(approx(sim.pos.x,B.x) && approx(sim.pos.y,B.y)){
        var nextA = sim.segIndex;
        var nextB = nextA + 1;
        if(nextB < path.length){
          var nextHeading = headingOf(path[nextA], path[nextB]);
          var d2 = angleDelta(sim.heading, nextHeading);
          if(d2!==0 && turnS>0){
            beginTurn(sim, sim.heading, nextHeading, turnS);
            return;
          }
        }
      }
    });

    drawAll();

    if(still) requestAnimationFrame(stepSimAll);
    else{
      simRunning=false;
      sims={};
      simulateBtn.textContent='シミュレーション開始（Job順・無限リピート）';
    }
  }

  /* ==== 車体UI ==== */
  function renderVehiclesUI(){
    var v=vehicles, html='';
    html += '<div class="head">車体</div><div class="head">速度[m/s]</div><div class="head">積み下ろし[s]</div><div class="head">旋回[s]</div>';
    'ABCDEFGHIJ'.split('').forEach(function(ch){
      html += '<div><strong>'+ch+'</strong></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="speed" type="number" step="0.1" value="'+(v[ch].speed||0)+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="load"  type="number" step="0.1" value="'+(v[ch].load||0)+'"></div>'
           +  '<div><input data-vkey="'+ch+'" data-field="turn"  type="number" step="0.1" value="'+(v[ch].turn||0)+'"></div>';
    });
    vehiclesEl.innerHTML=html;
    vehiclesEl.querySelectorAll('input').forEach(function(inp){
      inp.addEventListener('change', function(){
        var k=this.getAttribute('data-vkey');
        var f=this.getAttribute('data-field');
        var raw=this.value;
        var val=parseFloat(raw);
        if(!isFinite(val)||val<0) val=0;
        vehicles[k][f]=val;
        drawAll();
      });
    });
  }

  /* ==== Ready ==== */
  function ready(){
    canvas=document.getElementById('map'); if(!canvas) return;
    ctx=canvas.getContext('2d');
    toastEl=document.getElementById('toast');

    panXEl=document.getElementById('panX');
    panYEl=document.getElementById('panY');

    zoomLabelEl=document.getElementById('zoomLabel');
    speedLabelEl=document.getElementById('speedLabel');
    speedDecBtn=document.getElementById('speedDec');
    speedIncBtn=document.getElementById('speedInc');

    routesListEl=document.getElementById('routesList');
    addRouteBtn=document.getElementById('addRoute');
    removeRouteBtn=document.getElementById('removeRoute');
    undoBtn=document.getElementById('undo');
    clearBtn=document.getElementById('clear');
    simulateBtn=document.getElementById('simulateToggle');
    vehiclesEl=document.getElementById('vehicles');

    exportBtn=document.getElementById('exportBtn');
    importBtn=document.getElementById('importBtn');
    importFile=document.getElementById('importFile');

    routesSummaryEl=document.getElementById('routesSummary');
    chargePctEl=document.getElementById('chargePct');
    safetyPctEl=document.getElementById('safetyPct');
    exportPngBtn=document.getElementById('exportPngBtn');

    imageFileEl=document.getElementById('imageFile');
    addImageBtn=document.getElementById('addImageBtn');
    imgOpacityEl=document.getElementById('imgOpacity');
    imgOpacityLabelEl=document.getElementById('imgOpacityLabel');
    imgListEl=document.getElementById('imgList');

    jobsListEl=document.getElementById('jobsList');
    addJobBtn=document.getElementById('addJob');
    removeJobBtn=document.getElementById('removeJob');

    addRouteBtn.addEventListener('click', addRoute);
    removeRouteBtn.addEventListener('click', removeLastRoute);

    undoBtn.addEventListener('click', function(){
      var r=routes[activeRouteId];
      if(!r) return;
      r.points.pop();
      drawAll();
    });
    clearBtn.addEventListener('click', function(){
      var r=routes[activeRouteId];
      if(!r) return;
      r.points.length=0;
      r.start=null; r.goal=null;
      r.waits=[];
      r.placingWait=false;
      drawAll();
      renderRoutesUI();
    });

    simulateBtn.addEventListener('click', onSimToggle);

    exportBtn.addEventListener('click', onExport);
    importBtn.addEventListener('click', function(){ importFile.click(); });
    importFile.addEventListener('change', onImport);
    exportPngBtn.addEventListener('click', onExportPNG);

    chargePctEl.addEventListener('change', renderKPI);
    safetyPctEl.addEventListener('change', renderKPI);

    addImageBtn.addEventListener('click', async function(){
      var f=imageFileEl.files && imageFileEl.files[0];
      if(!f){ toast('JPG/PNGファイルを選択してください'); return; }
      var res=await fileToBitmapImageOnly(f);
      if(!res) return;
      addImageLayer(f.name, res.bitmap, res.width, res.height);
      imageFileEl.value='';
    });
    imgOpacityEl.addEventListener('input', function(){
      var it=getSelectedImage();
      if(!it){ imgOpacityLabelEl.textContent=this.value+'%'; return; }
      it.opacity=clamp((+this.value)/100, 0, 1);
      imgOpacityLabelEl.textContent=this.value+'%';
      drawAll();
    });

    speedDecBtn.addEventListener('click', function(){ speedIndex=Math.max(0, speedIndex-1); drawAll(); });
    speedIncBtn.addEventListener('click', function(){ speedIndex=Math.min(SPEED_STEPS.length-1, speedIndex+1); drawAll(); });

    addJobBtn.addEventListener('click', addJob);
    removeJobBtn.addEventListener('click', removeLastJob);

    window.addEventListener('resize', resize);
    canvas.addEventListener('click', onCanvasClick, {passive:true});
    canvas.addEventListener('dblclick', onCanvasDblClick, {passive:false});
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel, {passive:false});

    window.addEventListener('keydown', function(e){
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){
        var r=routes[activeRouteId];
        if(!r) return;
        r.points.pop();
        drawAll();
      } else {
        onKeyDown(e);
      }
    });

    panXEl.addEventListener('input', updateViewFromPanSliders);
    panYEl.addEventListener('input', updateViewFromPanSliders);

    // 初期
    resize();
    addRoute();
    addJob();
    activeJobId = getOrderedJobIds()[0] || null;
    setActiveRoute(activeRouteId);
    renderVehiclesUI();
    renderRoutesUI();
    renderJobsUI();
    updateCursor();
    drawAll();
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', ready);
  else ready();
})();
</script>
</body>
</html>
